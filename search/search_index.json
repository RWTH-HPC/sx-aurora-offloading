{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Aurora OpenMP Offloading Documentation! This Project's aim is, to create a prototype infrastructure to offload OpenMP target code written in C to NEC's new SX-Aurora VE architecture. It uses Clang as driver and host compiler, libomptarget, NEC's AVEO interface to run the code on the VE . As compiler the target code, the project can work with NEC's ncc compiler or with a Clang compiler which supports VE as a target for LLVM. Usage To compile a source file which contains target code for the VE architecture with ncc as target compiler, compile the source code with this project's Clang and set the OpenMP target triple to aurora-nec-veort-unknown e.g. clang -fopenmp -fopenmp-targets = aurora-nec-veort-unknown input.c More information can be found in the Usage section. Overview To provide OpenMP offloading to SX-Aurora VE devices with Clang as host compiler, this project provides the following components: A version of LLVM, modified so that Clang can recognize a new target triple for the VE architecture (Regardless of whether Clang/LLVM is actually used as target compiler). A modified version of Clang that can invoke the projects source transformation tool and a target compiler for offloading. As part of the Clang repository: A source transformation tool to extract target code from an input file and rewrite it as input for a target compiler. A set of wrapper tools that Clang can call to automatically transform and compile the input code with the selected target compiler. A plugin for LLVM's libomptarget which offloads the target code at runtime using NEC's AVEO API. All these components are provided within a single llvm-project repository.","title":"Introduction"},{"location":"#welcome-to-the-aurora-openmp-offloading-documentation","text":"This Project's aim is, to create a prototype infrastructure to offload OpenMP target code written in C to NEC's new SX-Aurora VE architecture. It uses Clang as driver and host compiler, libomptarget, NEC's AVEO interface to run the code on the VE . As compiler the target code, the project can work with NEC's ncc compiler or with a Clang compiler which supports VE as a target for LLVM.","title":"Welcome to the Aurora OpenMP Offloading Documentation!"},{"location":"#usage","text":"To compile a source file which contains target code for the VE architecture with ncc as target compiler, compile the source code with this project's Clang and set the OpenMP target triple to aurora-nec-veort-unknown e.g. clang -fopenmp -fopenmp-targets = aurora-nec-veort-unknown input.c More information can be found in the Usage section.","title":"Usage"},{"location":"#overview","text":"To provide OpenMP offloading to SX-Aurora VE devices with Clang as host compiler, this project provides the following components: A version of LLVM, modified so that Clang can recognize a new target triple for the VE architecture (Regardless of whether Clang/LLVM is actually used as target compiler). A modified version of Clang that can invoke the projects source transformation tool and a target compiler for offloading. As part of the Clang repository: A source transformation tool to extract target code from an input file and rewrite it as input for a target compiler. A set of wrapper tools that Clang can call to automatically transform and compile the input code with the selected target compiler. A plugin for LLVM's libomptarget which offloads the target code at runtime using NEC's AVEO API. All these components are provided within a single llvm-project repository.","title":"Overview"},{"location":"build_wrapper/","text":"Build Wrapper The project comes with a wrapper tool, necaurora-ofld-wrapper , which helps to integrate the target compiler and the source transformation tool (see Source Transformation ) and static linking into the build process of the Clang driver. When the Clang driver compiles a *.c file for a target, it calls the wrapper tool instead of a compiler. The wrapper tool then applies the source transformation tool to the input *.c file and saves the output in a temporary file. Then the wrapper tool forwards the compiler arguments it got from the Clang driver to the real target compiler, substituting the real input *.c file with the output of the source transformation. When the Clang driver tries to statically link object files into a static target image (with -Xlinker -fopenmp-static ), then the wrapper tool intercepts that call to the linker, creates a *.c file with a symbol table required by the VEO API and constructs a correct command line to call ncc for static linking. In all other cases, the wrapper tool just passes on its command line to the target compiler. Command Line Arguments The wrapper tool tries forwards all input arguments to the target compiler (except in case of static linking). It has only two command line arguments that are its own and are never forwarded: --sotoc-path= : With this argument, the driver can set the path to the source transformation tool to be used during compilation by the wrapper. -fopenmp-nec-compiler= selects the compiler for target compilation. This flag has the same semantics as the -fopenmp-nec-compiler= flag of the Clang driver (the argument is passed through from the Clang driver). See usage for details. -Xlinker -fopenmp-target : With this argument, the driver can instruct the wrapper to use static linking of the target image. Environment Variables The behaviour of the wrapper can be influenced by the following environment variables TMPDIR , TEMP , TMP Like Clang, the wrapper tool checks each of these environment variables in that order, to find the place to store its temporary files (for the source transformation and the static linking symbol table). When none of these exist, it falls back to /tmp . When the environment variable NECAURORA_KEEP_FILES_DIR is set, the specified path is used instead. NECAURORA_KEEP_FILES_DIR If this environment variable is set, the wrapper tools will store its temporary files in the specified directory and will not delete them after the tool is done.","title":"Build Wrapper"},{"location":"build_wrapper/#build-wrapper","text":"The project comes with a wrapper tool, necaurora-ofld-wrapper , which helps to integrate the target compiler and the source transformation tool (see Source Transformation ) and static linking into the build process of the Clang driver. When the Clang driver compiles a *.c file for a target, it calls the wrapper tool instead of a compiler. The wrapper tool then applies the source transformation tool to the input *.c file and saves the output in a temporary file. Then the wrapper tool forwards the compiler arguments it got from the Clang driver to the real target compiler, substituting the real input *.c file with the output of the source transformation. When the Clang driver tries to statically link object files into a static target image (with -Xlinker -fopenmp-static ), then the wrapper tool intercepts that call to the linker, creates a *.c file with a symbol table required by the VEO API and constructs a correct command line to call ncc for static linking. In all other cases, the wrapper tool just passes on its command line to the target compiler.","title":"Build Wrapper"},{"location":"build_wrapper/#command-line-arguments","text":"The wrapper tool tries forwards all input arguments to the target compiler (except in case of static linking). It has only two command line arguments that are its own and are never forwarded: --sotoc-path= : With this argument, the driver can set the path to the source transformation tool to be used during compilation by the wrapper. -fopenmp-nec-compiler= selects the compiler for target compilation. This flag has the same semantics as the -fopenmp-nec-compiler= flag of the Clang driver (the argument is passed through from the Clang driver). See usage for details. -Xlinker -fopenmp-target : With this argument, the driver can instruct the wrapper to use static linking of the target image.","title":"Command Line Arguments"},{"location":"build_wrapper/#environment-variables","text":"The behaviour of the wrapper can be influenced by the following environment variables TMPDIR , TEMP , TMP Like Clang, the wrapper tool checks each of these environment variables in that order, to find the place to store its temporary files (for the source transformation and the static linking symbol table). When none of these exist, it falls back to /tmp . When the environment variable NECAURORA_KEEP_FILES_DIR is set, the specified path is used instead. NECAURORA_KEEP_FILES_DIR If this environment variable is set, the wrapper tools will store its temporary files in the specified directory and will not delete them after the tool is done.","title":"Environment Variables"},{"location":"debugging/","text":"Debugging For debugging purposes NEC provides a number of helpful tools. Libomptarget If the debug-version of libomptarget was build, LIBOMPTARGET_DEBUG=1 can be used to show additional debugging information at runtime. Tip Use LIBOMPTARGET_DEBUG=4 to dump host-target pointer mappings. log4crc See Debugging with log4crc by Erich Focht NEC Parallel Debugger The NEC parallel debugger can be invoked from within the eclipse IDE. For detailed instructions see the users guide . GDB NEC provides a ported version of gdb for VE with specific commands and abilities for them. There are the following difference points between the ported version of GDB for VE and GDB for Linux: GDB internally executes ve_exec command with --traceme option in order to execute VE program. VE_NODE_NUMBER environment variable can be used to specify VE node to execute VE program. If the environment variable is not set, VE program is executed on VE node 0. Only local debugging is supported. Remote debugging using GDB server or GDB stub is not supported. The directory where separate debug symbols are searched for is /opt/nec/ve/lib/debug . GDB can not deal with thread-local variables correctly, because DWARF information about them is invalid. The following commands don't show information for VE side but show for VH side using procfs of it. info proc info proc all info proc cmdline info proc cwd info proc exe info proc mappings info proc stat info proc status info auxv command is available only in debugging with core file. GDB and VEOS does not handle invocation of execve() system call from a VE program properly. When a VE program invokes execve() system call, GDB detects SIGTRAP , or can not find the process or the thread, and then it does not reload a new program. In this case, quit command need to be executed to terminate GDB. The debugged process will be killed when GDB terminates, if it has been executed from GDB. call command can be used to invoke a function of a VE program. But, if stack area beyond page boundary is required, call command fails due to access error. IC will be far from the address which causes a HW exception when the program is stopped by the HW exception. advance off mode can be set in order to check the precise state when HW exception occurs. In this mode, instruction execution is held until the preceding instructions have completed. As the result, GDB shows the precise state when HW exception occurs. A full list of differences can be found here . Helpers Delay Target Code Execution To be able to attach a debugger to the target code more easily the NEC_TARGET_DELAY environment variable is provided. When compiling an application with NEC_TARGET_DELAY , code is injected into the target executable, which, at runtime, applies the value of this variable to the C sleep function, as to delay the start of execution by that number of seconds. Note If NEC_TARGET_DELAY is not set at runtime, then its value will default to zero.","title":"Debugging"},{"location":"debugging/#debugging","text":"For debugging purposes NEC provides a number of helpful tools.","title":"Debugging"},{"location":"debugging/#libomptarget","text":"If the debug-version of libomptarget was build, LIBOMPTARGET_DEBUG=1 can be used to show additional debugging information at runtime. Tip Use LIBOMPTARGET_DEBUG=4 to dump host-target pointer mappings.","title":"Libomptarget"},{"location":"debugging/#log4crc","text":"See Debugging with log4crc by Erich Focht","title":"log4crc"},{"location":"debugging/#nec-parallel-debugger","text":"The NEC parallel debugger can be invoked from within the eclipse IDE. For detailed instructions see the users guide .","title":"NEC Parallel Debugger"},{"location":"debugging/#gdb","text":"NEC provides a ported version of gdb for VE with specific commands and abilities for them. There are the following difference points between the ported version of GDB for VE and GDB for Linux: GDB internally executes ve_exec command with --traceme option in order to execute VE program. VE_NODE_NUMBER environment variable can be used to specify VE node to execute VE program. If the environment variable is not set, VE program is executed on VE node 0. Only local debugging is supported. Remote debugging using GDB server or GDB stub is not supported. The directory where separate debug symbols are searched for is /opt/nec/ve/lib/debug . GDB can not deal with thread-local variables correctly, because DWARF information about them is invalid. The following commands don't show information for VE side but show for VH side using procfs of it. info proc info proc all info proc cmdline info proc cwd info proc exe info proc mappings info proc stat info proc status info auxv command is available only in debugging with core file. GDB and VEOS does not handle invocation of execve() system call from a VE program properly. When a VE program invokes execve() system call, GDB detects SIGTRAP , or can not find the process or the thread, and then it does not reload a new program. In this case, quit command need to be executed to terminate GDB. The debugged process will be killed when GDB terminates, if it has been executed from GDB. call command can be used to invoke a function of a VE program. But, if stack area beyond page boundary is required, call command fails due to access error. IC will be far from the address which causes a HW exception when the program is stopped by the HW exception. advance off mode can be set in order to check the precise state when HW exception occurs. In this mode, instruction execution is held until the preceding instructions have completed. As the result, GDB shows the precise state when HW exception occurs. A full list of differences can be found here .","title":"GDB"},{"location":"debugging/#helpers","text":"","title":"Helpers"},{"location":"debugging/#delay-target-code-execution","text":"To be able to attach a debugger to the target code more easily the NEC_TARGET_DELAY environment variable is provided. When compiling an application with NEC_TARGET_DELAY , code is injected into the target executable, which, at runtime, applies the value of this variable to the C sleep function, as to delay the start of execution by that number of seconds. Note If NEC_TARGET_DELAY is not set at runtime, then its value will default to zero.","title":"Delay Target Code Execution"},{"location":"install/","text":"Installation This page details, how to install or build all components for SX-Aurora offloading. Installing the Package NEC provides LLVM including our OpenMP offloading implementation as package in a YUM repository. The packaged version is build from the hpce/stable branch of the NEC llvm-project repository at the llvm-ve-rv-1.9.0 tag. Thus, the included version of our OpenMP offloading implementation will not be at the latest state of development. However, further functionality and SX-Aurora specific fixes and extensions are included. Install from RPM Download llvm-ve-rv-1.9.0-1.9.0-1.el8.x86_64.rpm wget https://sx-aurora.com/repos/llvm/x86_64/llvm-ve-rv-1.9.0-1.9.0-1.el8.x86_64.rpm Install RPM sudo yum install ./llvm-ve-rv-1.9.0-1.9.0-1.el8.x86_64.rpm Install from YUM Repository Add the https://sx-aurora.com/repos/llvm/x86_64/ yum repository to your /etc/yum.repo.d (consult How to add a Yum repository by Red Hat) Install llvm-ve-rv-1.9.0 sudo yum install llvm-ve-rv-1.9.0 Release Notes LLVM for NEC SX-Aurora VE (llvm-ve-rv 1.8-dev) This is a fork of the LLVM repositoy with support for the NEC SX-Aurora TSUBASA Vector Engine ( VE ). Features C, C++ support. VEL intrinsics for low-level vector programming. Automatic vectorization through LLVM's loop and SLP vectorizers. When combined with RV for SX-Aurora, provides user-guided (and some automatic) outer-loop vectorization through the Region Vectorizer. Two OpenMP offloading modes: VE to VH and VH to VE . Build instructions To build llvm-ve from source refer to llvm-dev and Compile.rst . General Usage To compile C/C++ code for the VE run Clang/Clang++ with the following command line: $ clang -target ve-linux -O3 ... OpenMP offloading for/from SX-Aurora To compile with OpenMP offloading from VE to VH (VHCall) use: $ clang -target ve-linux -fopenmp -fopenmp-targets=x86_64-pc-linux -O3 ... To compile with OpenMP offloading from VH to VE ( VEO ) use: $ clang -march=native -fopenmp -fopenmp-targets=ve-linux -O3 ... Outer-loop Vectorization LLVM for SX-Aurora provides outer-loop vectorization, provided it is build with the Region Vectorizer. The following usage examples require an RV-enabled build. To use user-guided outer-loop vectorization with RV annotate the loops to vectorize with #pragma omp simd and use: $ clang -fopenmp-simd -mllvm -rv -O3 ... This release comes with a preview feature for automatic outer-loop vectorization with RV. This will work for some loops that use int64_t for their iteration variables (loop counters). To enable automatic outer-loop vectorization with RV use: $ clang -mllvm -rv -mllvm -rv-autovec -O3 ... VEL Intrinsics for direct vector programming See the manual . To use VEL intrinsics, pass the compiler option -mattr=+packed . The resulting LLVM bitcode and objects are compatible with those compiler without this option. Clang Experimental Options To enable packed mode support, call Clang with -mve-packed . This sets the machine attribute +packed . LLVM Experimental Options Clang and llc accept these flags directly, prefix them with -mllvm to use them with Clang. -ve-regalloc=0 disable the experimental improvements to the vector register allocator. Building the Project This project now comes as a single llvm-project repository, forked from LLVM's upstream repository. All components can be checked out from a single source and built, closely following the Clang build instructions . To build the project, first check out the llvm-project repository and switch to the aurora-offloading branch before configuring the project with CMake. Configure with CMake After checking out the aurora-offloading branch, change the working directory to llvm-project/llvm and run CMake with, at least, the following CMake variables: Set LLVM_ENABLE_PROJECTS to clang;openmp;libcxx;libcxxabi to enable at least clang , openmp , libcxx and libcxxabi . Set OPENMP_LIBOMPTARGET to ON to enable libomptarget Additionally, make sure that: LIBOMPTARGET_DEP_VEO_LIBRARIES Points to an installation of libveo.so (usually found under /opt/nec/ve/veos/lib64/ ) LIBOMPTARGET_DEP_VEOSINFO_LIBRARIES Points to an installation of libveosinfo.so (usually found under /opt/nec/ve/veos/lib64/ ) NECAURORA_TARGET_COMPILER_NCC points to your installation of ncc (usually found under /opt/nec/ve/bin ). Static Linking To be able to statically link the target image, please make sure that, additionally, the following CMake variables are set NECAURORA_LIBAVEOVE_STATIC , pointing to libaveoVE.a NECAURORA_LIBURPCVE_STATIC , pointing to liburpcVE_omp.a NECAURORA_LIBVEIO , pointing to libveio.so Usually these libraries are installed at /opt/nec/ve/lib . Enable Testing To enable the test suite for the source transformation, simply set SOTOC_ENABLE_TESTS to ON . The test suite uses the llvm-lit and FileCheck tool build together with the project and uses the project's Clang as test compiler. CMake Options NECAURORA_LIBELF_INCLUDE_DIR Points to the include directory containing the headers for libelf.so (required for static linking). NECAURORA_LIBELF_LIBRARIES Points to a libelf.so (required for static linking). NECAURORA_LIBAVEOVE_STATIC Points to libaveoVE.a (required for static linking). NECAURORA_LIBURPCVE_STATIC Points to liburpcVE_omp.a (required for static linking). NECAURORA_LIBVEIO Points to libveio.so (required for static linking). NECAURORA_TARGET_COMPILER_CLANG The path to the Clang compiler used for target compilations with the option -fopenmp-nec-compiler=clang . NECAURORA_TARGET_COMPILER_RVCLANG The path to the target compiler used for target compilations with the option -fopenmp-nec-compiler=rclang preset. NECAURORA_TARGET_COMPILER_NCC The path to the target compiler used for target compilations with the option -fopenmp-nec-compiler=ncc . NECAURORA_DEFAULT_TARGET_OPTION The default option for -fopenmp-nec-compiler= (defaults to ncc ). SOTOC_DEBUG_OUTPUT Enables debug output for sotoc (when the env-var SOTOC_DEBUG=1 is set). SOTOC_ENABLE_TESTS Enables the test suite for sotoc (can be called with make check-sotoc ). SOTOC_LLVM_LIT_EXECUTABLE The llvm-lit executable required for testing. LIBOMPTARGET_DEP_LIBFFI_INCLUDE_DIR The include-directory for a libffi installation (required for Run-On-Host). LIBOMPTARGET_DEP_LIBFFI_LIBRARIES The path to a libffi.so (required for Run-On-Host). LIBOMPTARGET_DEP_VEO_INCLUDE_DIR The include-directory for ve_offload.h . LIBOMPTARGET_DEP_VEO_LIBRARIES Path to libveo.so / libaveo.so . Building the NEC packaged version To build the packaged version by NEC (e.g. if debug information is needed) some Makefiles are provided. To get those clone the llvm-dev repository. git clone https://github.com/sx-aurora-dev/llvm-dev.git -b hpce/develop The actual LLVM repository and all required submodules can be cloned by doing: LLVM_BUILD_TYPE=Debug BUILD_TYPE=Debug BRANCH=hpce/develop REPOS=https://github.com/sx-aurora-dev make clone For the build process cmake, ninja and clang are required. module purge && module load DEVELOP cmake ninja-build clang Afterwards LLVM can be build by issuing the following command: LLVM_BUILD_TYPE=Debug BUILD_TYPE=Debug BRANCH=hpce/develop REPOS=https://github.com/sx-aurora-dev make install","title":"Installation"},{"location":"install/#installation","text":"This page details, how to install or build all components for SX-Aurora offloading.","title":"Installation"},{"location":"install/#installing-the-package","text":"NEC provides LLVM including our OpenMP offloading implementation as package in a YUM repository. The packaged version is build from the hpce/stable branch of the NEC llvm-project repository at the llvm-ve-rv-1.9.0 tag. Thus, the included version of our OpenMP offloading implementation will not be at the latest state of development. However, further functionality and SX-Aurora specific fixes and extensions are included. Install from RPM Download llvm-ve-rv-1.9.0-1.9.0-1.el8.x86_64.rpm wget https://sx-aurora.com/repos/llvm/x86_64/llvm-ve-rv-1.9.0-1.9.0-1.el8.x86_64.rpm Install RPM sudo yum install ./llvm-ve-rv-1.9.0-1.9.0-1.el8.x86_64.rpm Install from YUM Repository Add the https://sx-aurora.com/repos/llvm/x86_64/ yum repository to your /etc/yum.repo.d (consult How to add a Yum repository by Red Hat) Install llvm-ve-rv-1.9.0 sudo yum install llvm-ve-rv-1.9.0 Release Notes","title":"Installing the Package"},{"location":"install/#llvm-for-nec-sx-aurora-ve-llvm-ve-rv-18-dev","text":"This is a fork of the LLVM repositoy with support for the NEC SX-Aurora TSUBASA Vector Engine ( VE ).","title":"LLVM for NEC SX-Aurora VE (llvm-ve-rv 1.8-dev)"},{"location":"install/#features","text":"C, C++ support. VEL intrinsics for low-level vector programming. Automatic vectorization through LLVM's loop and SLP vectorizers. When combined with RV for SX-Aurora, provides user-guided (and some automatic) outer-loop vectorization through the Region Vectorizer. Two OpenMP offloading modes: VE to VH and VH to VE .","title":"Features"},{"location":"install/#build-instructions","text":"To build llvm-ve from source refer to llvm-dev and Compile.rst .","title":"Build instructions"},{"location":"install/#general-usage","text":"To compile C/C++ code for the VE run Clang/Clang++ with the following command line: $ clang -target ve-linux -O3 ...","title":"General Usage"},{"location":"install/#openmp-offloading-forfrom-sx-aurora","text":"To compile with OpenMP offloading from VE to VH (VHCall) use: $ clang -target ve-linux -fopenmp -fopenmp-targets=x86_64-pc-linux -O3 ... To compile with OpenMP offloading from VH to VE ( VEO ) use: $ clang -march=native -fopenmp -fopenmp-targets=ve-linux -O3 ...","title":"OpenMP offloading for/from SX-Aurora"},{"location":"install/#outer-loop-vectorization","text":"LLVM for SX-Aurora provides outer-loop vectorization, provided it is build with the Region Vectorizer. The following usage examples require an RV-enabled build. To use user-guided outer-loop vectorization with RV annotate the loops to vectorize with #pragma omp simd and use: $ clang -fopenmp-simd -mllvm -rv -O3 ... This release comes with a preview feature for automatic outer-loop vectorization with RV. This will work for some loops that use int64_t for their iteration variables (loop counters). To enable automatic outer-loop vectorization with RV use: $ clang -mllvm -rv -mllvm -rv-autovec -O3 ...","title":"Outer-loop Vectorization"},{"location":"install/#vel-intrinsics-for-direct-vector-programming","text":"See the manual . To use VEL intrinsics, pass the compiler option -mattr=+packed . The resulting LLVM bitcode and objects are compatible with those compiler without this option.","title":"VEL Intrinsics for direct vector programming"},{"location":"install/#clang-experimental-options","text":"To enable packed mode support, call Clang with -mve-packed . This sets the machine attribute +packed .","title":"Clang Experimental Options"},{"location":"install/#llvm-experimental-options","text":"Clang and llc accept these flags directly, prefix them with -mllvm to use them with Clang. -ve-regalloc=0 disable the experimental improvements to the vector register allocator.","title":"LLVM Experimental Options"},{"location":"install/#building-the-project","text":"This project now comes as a single llvm-project repository, forked from LLVM's upstream repository. All components can be checked out from a single source and built, closely following the Clang build instructions . To build the project, first check out the llvm-project repository and switch to the aurora-offloading branch before configuring the project with CMake.","title":"Building the Project"},{"location":"install/#configure-with-cmake","text":"After checking out the aurora-offloading branch, change the working directory to llvm-project/llvm and run CMake with, at least, the following CMake variables: Set LLVM_ENABLE_PROJECTS to clang;openmp;libcxx;libcxxabi to enable at least clang , openmp , libcxx and libcxxabi . Set OPENMP_LIBOMPTARGET to ON to enable libomptarget Additionally, make sure that: LIBOMPTARGET_DEP_VEO_LIBRARIES Points to an installation of libveo.so (usually found under /opt/nec/ve/veos/lib64/ ) LIBOMPTARGET_DEP_VEOSINFO_LIBRARIES Points to an installation of libveosinfo.so (usually found under /opt/nec/ve/veos/lib64/ ) NECAURORA_TARGET_COMPILER_NCC points to your installation of ncc (usually found under /opt/nec/ve/bin ).","title":"Configure with CMake"},{"location":"install/#static-linking","text":"To be able to statically link the target image, please make sure that, additionally, the following CMake variables are set NECAURORA_LIBAVEOVE_STATIC , pointing to libaveoVE.a NECAURORA_LIBURPCVE_STATIC , pointing to liburpcVE_omp.a NECAURORA_LIBVEIO , pointing to libveio.so Usually these libraries are installed at /opt/nec/ve/lib .","title":"Static Linking"},{"location":"install/#enable-testing","text":"To enable the test suite for the source transformation, simply set SOTOC_ENABLE_TESTS to ON . The test suite uses the llvm-lit and FileCheck tool build together with the project and uses the project's Clang as test compiler.","title":"Enable Testing"},{"location":"install/#cmake-options","text":"NECAURORA_LIBELF_INCLUDE_DIR Points to the include directory containing the headers for libelf.so (required for static linking). NECAURORA_LIBELF_LIBRARIES Points to a libelf.so (required for static linking). NECAURORA_LIBAVEOVE_STATIC Points to libaveoVE.a (required for static linking). NECAURORA_LIBURPCVE_STATIC Points to liburpcVE_omp.a (required for static linking). NECAURORA_LIBVEIO Points to libveio.so (required for static linking). NECAURORA_TARGET_COMPILER_CLANG The path to the Clang compiler used for target compilations with the option -fopenmp-nec-compiler=clang . NECAURORA_TARGET_COMPILER_RVCLANG The path to the target compiler used for target compilations with the option -fopenmp-nec-compiler=rclang preset. NECAURORA_TARGET_COMPILER_NCC The path to the target compiler used for target compilations with the option -fopenmp-nec-compiler=ncc . NECAURORA_DEFAULT_TARGET_OPTION The default option for -fopenmp-nec-compiler= (defaults to ncc ). SOTOC_DEBUG_OUTPUT Enables debug output for sotoc (when the env-var SOTOC_DEBUG=1 is set). SOTOC_ENABLE_TESTS Enables the test suite for sotoc (can be called with make check-sotoc ). SOTOC_LLVM_LIT_EXECUTABLE The llvm-lit executable required for testing. LIBOMPTARGET_DEP_LIBFFI_INCLUDE_DIR The include-directory for a libffi installation (required for Run-On-Host). LIBOMPTARGET_DEP_LIBFFI_LIBRARIES The path to a libffi.so (required for Run-On-Host). LIBOMPTARGET_DEP_VEO_INCLUDE_DIR The include-directory for ve_offload.h . LIBOMPTARGET_DEP_VEO_LIBRARIES Path to libveo.so / libaveo.so .","title":"CMake Options"},{"location":"install/#building-the-nec-packaged-version","text":"To build the packaged version by NEC (e.g. if debug information is needed) some Makefiles are provided. To get those clone the llvm-dev repository. git clone https://github.com/sx-aurora-dev/llvm-dev.git -b hpce/develop The actual LLVM repository and all required submodules can be cloned by doing: LLVM_BUILD_TYPE=Debug BUILD_TYPE=Debug BRANCH=hpce/develop REPOS=https://github.com/sx-aurora-dev make clone For the build process cmake, ninja and clang are required. module purge && module load DEVELOP cmake ninja-build clang Afterwards LLVM can be build by issuing the following command: LLVM_BUILD_TYPE=Debug BUILD_TYPE=Debug BRANCH=hpce/develop REPOS=https://github.com/sx-aurora-dev make install","title":"Building the NEC packaged version"},{"location":"perf/","text":"Performance Analysis The following tools are provided to display additional execution information. PROGINF PROGINF provides program execution analysis information throughout the execution of program. To use PROGINF compile your C code using ncc . The PROGINF -library is linked by default. When setting VE_PROGINF to YES or DETAIL at runtime, additional information will be displayed. For additional information see the PROGINF and FTRACE users guide . FTRACE FTRACE is used to obtain performance information such as the CPU usage and vectorization aspect of each function in a program, as well as user regions. To use FTRACE compile your C code using ncc with the -ftrace flag. When executing, a ftrace.out.* file is generated, which can be viewed using ftrace -f ftrace.out.* . For additional information see the PROGINF and FTRACE users guide and the NEC FTRACE Viewer users guide . To pass the -ftrace flag to ncc while using our OpenMP offloading implementation use the -Xopenmp-target clang flag as described in Passing Arguments to the Target Compiler .","title":"Performance Analysis"},{"location":"perf/#performance-analysis","text":"The following tools are provided to display additional execution information.","title":"Performance Analysis"},{"location":"perf/#proginf","text":"PROGINF provides program execution analysis information throughout the execution of program. To use PROGINF compile your C code using ncc . The PROGINF -library is linked by default. When setting VE_PROGINF to YES or DETAIL at runtime, additional information will be displayed. For additional information see the PROGINF and FTRACE users guide .","title":"PROGINF"},{"location":"perf/#ftrace","text":"FTRACE is used to obtain performance information such as the CPU usage and vectorization aspect of each function in a program, as well as user regions. To use FTRACE compile your C code using ncc with the -ftrace flag. When executing, a ftrace.out.* file is generated, which can be viewed using ftrace -f ftrace.out.* . For additional information see the PROGINF and FTRACE users guide and the NEC FTRACE Viewer users guide . To pass the -ftrace flag to ncc while using our OpenMP offloading implementation use the -Xopenmp-target clang flag as described in Passing Arguments to the Target Compiler .","title":"FTRACE"},{"location":"publications/","text":"Publications Evaluating the Performance of OpenMP Offloading on the NEC SX-Aurora TSUBASA Vector Engine (2021) Abstract The NEC SX-Aurora TSUBASA vector engine ( VE ) follows the tradition of long vector processors for high-performance computing ( HPC ). The technology combines the vector computing capabilities with the popularity of standard x86 architecture by integrating it as an accelerator. To decrease the burden of code porting for different accelerator types, the OpenMP specification is designed to be single parallel programming model for all of them. Besides the availability of compiler and runtime implementations, the functionality as well as the performance is important for the usability and acceptance of this paradigm. In this work, we present LLVM-based solutions for OpenMP target device offloading from the host to the vector engine and vice versa (reverse offloading). Therefore, we use our source-to-source transformation tool sotoc as well as the native LLVM- VE code path. We assess the functionality and present the first performance numbers of real-world HPC kernels. We discuss the advantages and disadvantage of the different approaches and show that our implementation is competitive to other GPU OpenMP runtime implementations. Our work gives scientific programmers new opportunities and flexibilities for the development of scalable OpenMP offloading applications for SX-Aurora TSUBASA. Cite Cramer, T., Kosmynin, B., Moll, S., R\u00f6mmer, M., Focht, E., & M\u00fcller, M. (2021). Evaluating the Performance of OpenMP Offloading on the NEC SX-Aurora TSUBASA Vector Engine. Supercomputing Frontiers And Innovations, 8(2), 59-74. doi:http://dx.doi.org/10.14529/jsfi210204 BibTeX @article { ref:Cramer2021 , title = {{E}valuating the {P}erformance of {O}pen{MP} {O}ffloading on the {NEC} {SX}-{A}urora {TSUBASA} {V}ector {E}ngine} , author = {Tim Cramer and Boris Kosmynin and Simon Moll and Manoel R\u00f6mmer and Erich Focht and Matthias M\u00fcller} , journal = {Supercomputing Frontiers and Innovations} , volume = {8} , number = {2} , year = {2021} , keywords = {HPC, OpenMP, offloading, reverse offloading, vector computing, performance} , abstract = {The NEC SX-Aurora TSUBASA vector engine (VE) follows the tradition of long vector processors for high-performance computing (HPC). The technology combines the vector computing capabilities with the popularity of standard x86 architecture by integrating it as an accelerator. To decrease the burden of code porting for different accelerator types, the OpenMP specification is designed to be single parallel programming model for all of them. Besides the availability of compiler and runtime implementations, the functionality as well as the performance is important for the usability and acceptance of this paradigm. In this work, we present LLVM-based solutions for OpenMP target device offloading from the host to the vector engine and vice versa (reverse offloading). Therefore, we use our source-to-source transformation tool sotoc as well as the native LLVM-VE code path. We assess the functionality and present the first performance numbers of real-world HPC kernels. We discuss the advantages and disadvantage of the different approaches and show that our implementation is competitive to other GPU OpenMP runtime implementations. Our work gives scientific programmers new opportunities and flexibilities for the development of scalable OpenMP offloading applications for SX-Aurora TSUBASA.} , issn = {2313-8734} , url = {https://superfri.org/superfri/article/view/385} } OpenMP Target Device Offloading for the SX-Aurora TSUBASA Vector Engine (2020) Abstract Driven by the heterogeneity trend in modern supercomputers, OpenMP provides support for heterogeneous systems since 2013. Having a single programming model for all kinds of accelerator-based systems decreases the burden of code porting to different device types. The acceptance of this heterogeneous paradigm requires the availability of corresponding OpenMP compiler and runtime environments supporting different target device architectures. The LLVM/Clang infrastructure is designated to extend the offloading features for any new target platform. However, this supposes a compatible compiler backend for the target architecture. In order to overcome this limitation we present a source-to-source code transformation technique which outlines the OpenMP code regions for the target device. By combining this technique with a corresponding communication layer, we enable OpenMP target offloading to the NEC SX-Aurora TSUBASA vector engine, which represents the new generation of vector computing. Cite Cramer T., R\u00f6mmer M., Kosmynin B., Focht E., M\u00fcller M.S. (2020) OpenMP Target Device Offloading for the SX-Aurora TSUBASA Vector Engine. In: Wyrzykowski R., Deelman E., Dongarra J., Karczewski K. (eds) Parallel Processing and Applied Mathematics. PPAM 2019. Lecture Notes in Computer Science, vol 12043. Springer, Cham. https://doi.org/10.1007/978-3-030-43229-4_21 BibTeX @inproceedings { ref:Cramer2020 , title = {{O}pen{MP} {T}arget {D}evice {O}ffloading for the {SX}-{A}urora {TSUBASA} {V}ector {E}ngine} , author = {Cramer, Tim and R\u00f6mmer, Manoel and Kosmynin, Boris and Focht, Erich and M\u00fcller, Matthias S.} , year = 2020 , booktitle = {Parallel Processing and Applied Mathematics : 13th International Conference, PPAM 2019, Bialystok, Poland, September 8-11, 2019, Revised Selected Papers, edited by Roman Wyrzykowski, Ewa Deelman, Jack Dongarra, Konrad Karczewski} , publisher = {Springer International Publishing [2020.] ; Cham : Imprint: Springer [2020.]} , address = {Cham} , series = {Theoretical Computer Science and General Issues} , volume = 12043 , pages = {237--249} , reportid = {RWTH-2020-04830} , comment = {Parallel Processing and Applied Mathematics : 13th International Conference, PPAM 2019, Bialystok, Poland, September 8-11, 2019, Revised Selected Papers, Part I / edited by Roman Wyrzykowski, Ewa Deelman, Jack Dongarra, Konrad Karczewski} , organization = {13th International Conference on Parallel Processing and Applied Mathematics} }","title":"Publications"},{"location":"publications/#publications","text":"","title":"Publications"},{"location":"publications/#evaluating-the-performance-of-openmp-offloading-on-the-nec-sx-aurora-tsubasa-vector-engine-2021","text":"Abstract The NEC SX-Aurora TSUBASA vector engine ( VE ) follows the tradition of long vector processors for high-performance computing ( HPC ). The technology combines the vector computing capabilities with the popularity of standard x86 architecture by integrating it as an accelerator. To decrease the burden of code porting for different accelerator types, the OpenMP specification is designed to be single parallel programming model for all of them. Besides the availability of compiler and runtime implementations, the functionality as well as the performance is important for the usability and acceptance of this paradigm. In this work, we present LLVM-based solutions for OpenMP target device offloading from the host to the vector engine and vice versa (reverse offloading). Therefore, we use our source-to-source transformation tool sotoc as well as the native LLVM- VE code path. We assess the functionality and present the first performance numbers of real-world HPC kernels. We discuss the advantages and disadvantage of the different approaches and show that our implementation is competitive to other GPU OpenMP runtime implementations. Our work gives scientific programmers new opportunities and flexibilities for the development of scalable OpenMP offloading applications for SX-Aurora TSUBASA. Cite Cramer, T., Kosmynin, B., Moll, S., R\u00f6mmer, M., Focht, E., & M\u00fcller, M. (2021). Evaluating the Performance of OpenMP Offloading on the NEC SX-Aurora TSUBASA Vector Engine. Supercomputing Frontiers And Innovations, 8(2), 59-74. doi:http://dx.doi.org/10.14529/jsfi210204 BibTeX @article { ref:Cramer2021 , title = {{E}valuating the {P}erformance of {O}pen{MP} {O}ffloading on the {NEC} {SX}-{A}urora {TSUBASA} {V}ector {E}ngine} , author = {Tim Cramer and Boris Kosmynin and Simon Moll and Manoel R\u00f6mmer and Erich Focht and Matthias M\u00fcller} , journal = {Supercomputing Frontiers and Innovations} , volume = {8} , number = {2} , year = {2021} , keywords = {HPC, OpenMP, offloading, reverse offloading, vector computing, performance} , abstract = {The NEC SX-Aurora TSUBASA vector engine (VE) follows the tradition of long vector processors for high-performance computing (HPC). The technology combines the vector computing capabilities with the popularity of standard x86 architecture by integrating it as an accelerator. To decrease the burden of code porting for different accelerator types, the OpenMP specification is designed to be single parallel programming model for all of them. Besides the availability of compiler and runtime implementations, the functionality as well as the performance is important for the usability and acceptance of this paradigm. In this work, we present LLVM-based solutions for OpenMP target device offloading from the host to the vector engine and vice versa (reverse offloading). Therefore, we use our source-to-source transformation tool sotoc as well as the native LLVM-VE code path. We assess the functionality and present the first performance numbers of real-world HPC kernels. We discuss the advantages and disadvantage of the different approaches and show that our implementation is competitive to other GPU OpenMP runtime implementations. Our work gives scientific programmers new opportunities and flexibilities for the development of scalable OpenMP offloading applications for SX-Aurora TSUBASA.} , issn = {2313-8734} , url = {https://superfri.org/superfri/article/view/385} }","title":"Evaluating the Performance of OpenMP Offloading on the NEC SX-Aurora TSUBASA Vector Engine (2021)"},{"location":"publications/#openmp-target-device-offloading-for-the-sx-aurora-tsubasa-vector-engine-2020","text":"Abstract Driven by the heterogeneity trend in modern supercomputers, OpenMP provides support for heterogeneous systems since 2013. Having a single programming model for all kinds of accelerator-based systems decreases the burden of code porting to different device types. The acceptance of this heterogeneous paradigm requires the availability of corresponding OpenMP compiler and runtime environments supporting different target device architectures. The LLVM/Clang infrastructure is designated to extend the offloading features for any new target platform. However, this supposes a compatible compiler backend for the target architecture. In order to overcome this limitation we present a source-to-source code transformation technique which outlines the OpenMP code regions for the target device. By combining this technique with a corresponding communication layer, we enable OpenMP target offloading to the NEC SX-Aurora TSUBASA vector engine, which represents the new generation of vector computing. Cite Cramer T., R\u00f6mmer M., Kosmynin B., Focht E., M\u00fcller M.S. (2020) OpenMP Target Device Offloading for the SX-Aurora TSUBASA Vector Engine. In: Wyrzykowski R., Deelman E., Dongarra J., Karczewski K. (eds) Parallel Processing and Applied Mathematics. PPAM 2019. Lecture Notes in Computer Science, vol 12043. Springer, Cham. https://doi.org/10.1007/978-3-030-43229-4_21 BibTeX @inproceedings { ref:Cramer2020 , title = {{O}pen{MP} {T}arget {D}evice {O}ffloading for the {SX}-{A}urora {TSUBASA} {V}ector {E}ngine} , author = {Cramer, Tim and R\u00f6mmer, Manoel and Kosmynin, Boris and Focht, Erich and M\u00fcller, Matthias S.} , year = 2020 , booktitle = {Parallel Processing and Applied Mathematics : 13th International Conference, PPAM 2019, Bialystok, Poland, September 8-11, 2019, Revised Selected Papers, edited by Roman Wyrzykowski, Ewa Deelman, Jack Dongarra, Konrad Karczewski} , publisher = {Springer International Publishing [2020.] ; Cham : Imprint: Springer [2020.]} , address = {Cham} , series = {Theoretical Computer Science and General Issues} , volume = 12043 , pages = {237--249} , reportid = {RWTH-2020-04830} , comment = {Parallel Processing and Applied Mathematics : 13th International Conference, PPAM 2019, Bialystok, Poland, September 8-11, 2019, Revised Selected Papers, Part I / edited by Roman Wyrzykowski, Ewa Deelman, Jack Dongarra, Konrad Karczewski} , organization = {13th International Conference on Parallel Processing and Applied Mathematics} }","title":"OpenMP Target Device Offloading for the SX-Aurora TSUBASA Vector Engine (2020)"},{"location":"source_transformation/","text":"Source Transformation with sotoc The source transformation tool sotoc is now part of the llvm-project repository (under clang/tools/sotoc ) and is build automatically with Clang. Please see Installation for installation or build instructions. Overview sotoc itself is invoked during compilation by the wrapper tool (see Build Wrapper ), which itself is called by the Clang driver instead of the actual target compiler. sotoc itself only needs to be invoked directly during development and testing. The tool can be invoked (both by the wrapper tools and during testing) by the following command line: sotoc input.c -- <clang command line> Where <clang command line> contains all command line options that Clang uses to compile the target code. This has, at least, to include -fopenmp but does not include the -fopenmp-targets option (passing the -fopenmp-targets option will result in an error). When invoked, sotoc searches for all variables, function, and type declarations in the input file that are either annotated by a directive, #pragma omp declare target , or are referenced in a target region or another function required on the target. It then copies them into the output source file. sotoc also searches for all target regions in the input file and transforms them into functions, so the region's code can be called independently of its original context. During this transformation, sotoc generates function arguments for all variables captured by the region and generates code to copy those variables into the scope of the new function. Warning To work around limitations of the LLVM/Clang offloading infrastructure, global static variables which are copied into the output source file, have their static -keyword removed. This will probably break some code, but there is currently no better workaround available. Example Original Code 1 2 3 4 5 6 7 8 9 10 11 12 # pragma omp declare target int n = 10240 ; # pragma omp end declare target void saxpy () { float a = 42.0f ; float b = 23.0f ; float * x , * y ; // Allocate and init x , y ... # pragma omp target map (to: x[0:n], a) map(tofrom: y[0:n]) # pragma omp parallel for for ( int i = 0 ; i < n ; ++ i ) { y [ i ] = a * x [ i ] + y [ i ]; } } Transformed Code 1 2 3 4 5 6 7 8 9 int n = 10240 ; void __omp_ofld_b73b_saxpy_l4 ( int n , float * y , float * __sotoc_var_a , float * x ) { float a = * __sotoc_var_a ; # pragma omp parallel for for ( int i = 0 ; i < n ; ++ i ) { y [ i ] = a * x [ i ] + y [ i ]; } * __sotoc_var_a = a ; } Testing The tool comes with a regression test suite using llvm-lit . If the CMake option SOTOC_ENABLE_TESTS is set to ON , The tests can be run with: make check-sotoc Make sure that LLVM's FileCheck tool is in the path, then the test suite can be run with make check-sotoc","title":"Source Transformation"},{"location":"source_transformation/#source-transformation-with-sotoc","text":"The source transformation tool sotoc is now part of the llvm-project repository (under clang/tools/sotoc ) and is build automatically with Clang. Please see Installation for installation or build instructions.","title":"Source Transformation with sotoc"},{"location":"source_transformation/#overview","text":"sotoc itself is invoked during compilation by the wrapper tool (see Build Wrapper ), which itself is called by the Clang driver instead of the actual target compiler. sotoc itself only needs to be invoked directly during development and testing. The tool can be invoked (both by the wrapper tools and during testing) by the following command line: sotoc input.c -- <clang command line> Where <clang command line> contains all command line options that Clang uses to compile the target code. This has, at least, to include -fopenmp but does not include the -fopenmp-targets option (passing the -fopenmp-targets option will result in an error). When invoked, sotoc searches for all variables, function, and type declarations in the input file that are either annotated by a directive, #pragma omp declare target , or are referenced in a target region or another function required on the target. It then copies them into the output source file. sotoc also searches for all target regions in the input file and transforms them into functions, so the region's code can be called independently of its original context. During this transformation, sotoc generates function arguments for all variables captured by the region and generates code to copy those variables into the scope of the new function. Warning To work around limitations of the LLVM/Clang offloading infrastructure, global static variables which are copied into the output source file, have their static -keyword removed. This will probably break some code, but there is currently no better workaround available. Example Original Code 1 2 3 4 5 6 7 8 9 10 11 12 # pragma omp declare target int n = 10240 ; # pragma omp end declare target void saxpy () { float a = 42.0f ; float b = 23.0f ; float * x , * y ; // Allocate and init x , y ... # pragma omp target map (to: x[0:n], a) map(tofrom: y[0:n]) # pragma omp parallel for for ( int i = 0 ; i < n ; ++ i ) { y [ i ] = a * x [ i ] + y [ i ]; } } Transformed Code 1 2 3 4 5 6 7 8 9 int n = 10240 ; void __omp_ofld_b73b_saxpy_l4 ( int n , float * y , float * __sotoc_var_a , float * x ) { float a = * __sotoc_var_a ; # pragma omp parallel for for ( int i = 0 ; i < n ; ++ i ) { y [ i ] = a * x [ i ] + y [ i ]; } * __sotoc_var_a = a ; }","title":"Overview"},{"location":"source_transformation/#testing","text":"The tool comes with a regression test suite using llvm-lit . If the CMake option SOTOC_ENABLE_TESTS is set to ON , The tests can be run with: make check-sotoc Make sure that LLVM's FileCheck tool is in the path, then the test suite can be run with make check-sotoc","title":"Testing"},{"location":"usage/","text":"Usage The project's Clang compiler can be used to compile OpenMP code with offloading to SX-Aurora VE cards using aurora-nec-veort-unknown as target triple for offloading. For example: clang -fopenmp -fopenmp-targets = aurora-nec-veort-unknown input.c Will apply source transformation for target regions and declare target functions in input.c and compile an offloading binary for the VE architecture from it using the target compiler (by default this is Clang). Clang embeds this binary into the host executable as it would any other offloading binary. The host executable generated by Clang can then be executed and will try to use the libomptarget plugin for SX-Aurora VE to offload target regions onto the VE cards. The VE card used for the execution can be controlled by the OMP_DEFAULT_DEVICE environment variable during runtime, or with OpenMP 's device clause in the program. Selecting a Target Compiler When using the project's Clang compiler to compile OpenMP code with offloading, you can choose which compiler will be used for the target code with the compiler flag --fopenmp-nec-compiler= . This flag supports compilers configured as presets at build time, and compilers set at run time by full path. --fopenmp-nec-compiler=clang (default) will use the preset for Clang with the LLVM back-end for VE . The path to the Clang compiler for this preset can be configured with CMake at build time and defaults to the installation path of the clang compiler built with this project. --fopenmp-nec-compiler=rvclang will use the preset for Clang with region vectorizer (rvclang) and an LLVM back-end for VE . The path to the compiler for this preset can be configured with CMake at build time and defaults to the installation path of the rvclang compiler built with this project. --fopenmp-nec-compiler=ncc will use the ncc compiler. The path to the ncc compiler can be configured with CMake at build time and defaults to the standard ncc install location. A target compiler can also be set with a full path using the syntax --fopenmp-nec-compiler=path:$PATH_TO_COMPILER . If this is a Clang compiler you may also need to manually pass the compiler target to it, for example with -Xopenmp-target \"--target=ve-linux\" . This is NOT necessary when using one of the compiler presets above. The path for the compiler presets can be configured with CMake at build time of the project with the NECAURORA_TARGET_COMPILER_* CMake flags. The default preset can be configured with CMake at build time with the CMake flag NECAURORA_DEFAULT_TARGET_OPTION which defaults to ncc . See the section CMake Options in Installation . Passing Arguments to the Target Compiler Not all arguments from the host compilation are automatically converted or passed on to the target compiler (although some are). To explicitly pass an argument to the wrapper and target compiler, Clang offers the argument -Xopenmp-target . For example, to pass the argument -fno-fast-math to the target compiler, use the command line: clang -fopenmp -fopenmp-targets = aurora-nec-veort-unknown -Xopenmp-target \"-fno-fast-math\" input.c -o program Any option passed via -Xopenmp-target is not used for parsing and source transformation. Static Linking To link your target image statically, pass the option -Xlinker -fopenmp-static to the wrapper/target compiler via -Xopenmp-target , For example: clang -fopenmp -fopenmp-targets = aurora-nec-veort-unknown -Xopenmp-target \"-Xlinker -fopenmp-static\" input.c -o program Danger Static linking is currently experimental, and the wrapper tool will not forward arguments to the linker from Clang. Warning Due to limitations with the VEO / AVEO API, target regions which are nested in a parallel region are not executed in parallel but one after the other (with the order being determined by which thread in the parallel region calls libomptarget first, and thus non-deterministic).","title":"Usage"},{"location":"usage/#usage","text":"The project's Clang compiler can be used to compile OpenMP code with offloading to SX-Aurora VE cards using aurora-nec-veort-unknown as target triple for offloading. For example: clang -fopenmp -fopenmp-targets = aurora-nec-veort-unknown input.c Will apply source transformation for target regions and declare target functions in input.c and compile an offloading binary for the VE architecture from it using the target compiler (by default this is Clang). Clang embeds this binary into the host executable as it would any other offloading binary. The host executable generated by Clang can then be executed and will try to use the libomptarget plugin for SX-Aurora VE to offload target regions onto the VE cards. The VE card used for the execution can be controlled by the OMP_DEFAULT_DEVICE environment variable during runtime, or with OpenMP 's device clause in the program.","title":"Usage"},{"location":"usage/#selecting-a-target-compiler","text":"When using the project's Clang compiler to compile OpenMP code with offloading, you can choose which compiler will be used for the target code with the compiler flag --fopenmp-nec-compiler= . This flag supports compilers configured as presets at build time, and compilers set at run time by full path. --fopenmp-nec-compiler=clang (default) will use the preset for Clang with the LLVM back-end for VE . The path to the Clang compiler for this preset can be configured with CMake at build time and defaults to the installation path of the clang compiler built with this project. --fopenmp-nec-compiler=rvclang will use the preset for Clang with region vectorizer (rvclang) and an LLVM back-end for VE . The path to the compiler for this preset can be configured with CMake at build time and defaults to the installation path of the rvclang compiler built with this project. --fopenmp-nec-compiler=ncc will use the ncc compiler. The path to the ncc compiler can be configured with CMake at build time and defaults to the standard ncc install location. A target compiler can also be set with a full path using the syntax --fopenmp-nec-compiler=path:$PATH_TO_COMPILER . If this is a Clang compiler you may also need to manually pass the compiler target to it, for example with -Xopenmp-target \"--target=ve-linux\" . This is NOT necessary when using one of the compiler presets above. The path for the compiler presets can be configured with CMake at build time of the project with the NECAURORA_TARGET_COMPILER_* CMake flags. The default preset can be configured with CMake at build time with the CMake flag NECAURORA_DEFAULT_TARGET_OPTION which defaults to ncc . See the section CMake Options in Installation .","title":"Selecting a Target Compiler"},{"location":"usage/#passing-arguments-to-the-target-compiler","text":"Not all arguments from the host compilation are automatically converted or passed on to the target compiler (although some are). To explicitly pass an argument to the wrapper and target compiler, Clang offers the argument -Xopenmp-target . For example, to pass the argument -fno-fast-math to the target compiler, use the command line: clang -fopenmp -fopenmp-targets = aurora-nec-veort-unknown -Xopenmp-target \"-fno-fast-math\" input.c -o program Any option passed via -Xopenmp-target is not used for parsing and source transformation.","title":"Passing Arguments to the Target Compiler"},{"location":"usage/#static-linking","text":"To link your target image statically, pass the option -Xlinker -fopenmp-static to the wrapper/target compiler via -Xopenmp-target , For example: clang -fopenmp -fopenmp-targets = aurora-nec-veort-unknown -Xopenmp-target \"-Xlinker -fopenmp-static\" input.c -o program Danger Static linking is currently experimental, and the wrapper tool will not forward arguments to the linker from Clang. Warning Due to limitations with the VEO / AVEO API, target regions which are nested in a parallel region are not executed in parallel but one after the other (with the order being determined by which thread in the parallel region calls libomptarget first, and thus non-deterministic).","title":"Static Linking"},{"location":"internal/codegen/","text":"Target Code Generation Attention This page is for internal and development use only. The general process to the target code generation is as follows: The code's AST is processed with RecursiveASTVisitor s ( clang/tools/sotoc/Visitors.{h,cpp} ) The found target code is recorded in TargetCodeFragment ( clang/tools/sotoc/TargetCode.{h,pp} and clang/tools/sotoc/TargetCodeFragment.{h,cpp} ) The fragments are then 'reconstituted' into valid target code. This transforms C code like 1 2 3 4 5 6 7 8 9 10 int main ( void ) { int x = 0 ; int y = 1 ; int z = 2 ; #pragma omp target map(tofrom:x) { x = x + y + z ; } } into 1 2 3 4 5 6 7 8 9 10 void __omp_offloading_38_272a6c6b_main_l7 ( int * __sotoc_var_x , int y , int z ) { int x = * __sotoc_var_x ; { x = x + y + z ; } * __sotoc_var_x = x ; } The target code is thereby transformed into a function with the mapped variables as arguments. Extracting Target Code from the AST The Clang AST of a source file can be viewed using the following command: clang -Xclang -ast-dump -fsyntax-only -fopenmp code.c Info Without the -fopenmp flag Clang ignores #pragma omp . Target regions are separate statements in the AST and functions and variables declared with #pragma omp declare target get a special attribute added to their AST node. The FindTargetCodeVisitor in Visitors.{h,cpp} is used for that. Warning This does not apply the type declarations and there is no guaranty that all functions used in the target region are declared in #pragma omp declare target . To solve the issue we search all target regions, declared functions and variables to additional types, functions, and variables. This is done by the DiscoverTypesInDeclVisitor and DiscoverFunctionsInDeclVisitor . As types can be derived from other types (e.g., struct s or typedef -chains) and functions can depend on other functions and additional types, those dependencies have to be resolved using the DeclResolver (in clang/tools/sotoc/DeclResolver.{h,cpp} ). Analysing and Recording the Target Code Before target code can be generated, additional information about variable mappings have to be collected. Private variables are not mapped. For those we have to create a declaration in the target region using the FindPrivateVariablesVisitor . First-private variables (which is the default) are passed by value into the target region. Variables mapped using from or tofrom , are passed by pointer. For ncc to process them, we bring the variable into scope by copying them into a local variable and afterwards back. Arrays are mapped as pointer. If only an array slice (e.g., map ( to : array [ 10 : ]) ) is mapped, we have to detect the bounds with the FindArraySectionVisitor and move the returned pointer ( array [ 10 ] ) in the target region. Multi-dimensional arrays have to be cast, so they can be accessed using the array [ x ] notation. To recognize the variable form we use the TargetRegionVariable class in clang/tools/sotoc/TargetRegionVariable.{h,cpp} . In addition, we have to rewrite the OpenMP pragma directive and add the appropriate clauses ( OmpPragma.{h,cpp} ). For example if a #pragma omp target parallel is encountered, an additional parallel region has to be added. Some clauses are not supported by the reduced #pragma . Those are filtered out or replaced. Parameters to clauses are also transferred as function arguments of the target function. Code Generation An Object of the TargetCode class, serves as a collection of TargetCodeFragment s and generates the code. When adding code fragments, TargetCode sorts them according to their position in the original source file. We try to generate as little code as possible ourselves and let Clangs PrettyPrinter do most of the work, like functions and global variables. Bug Clangs PrettyPrinter is designed for compiler diagnostics and can not do e.g., anonymous struct s and enum s. Note We extended the PrettyPrinter to handle Decl s. We still have to generate functions for regions with mapped variables and clause parameters as arguments and local declarations to bring variables into scope as mentioned above . Bug Mappings with missing elements in the middle are currently not completely mapped by libomptarget/the OpenMP runtime.","title":"Target Code Generation"},{"location":"internal/codegen/#target-code-generation","text":"Attention This page is for internal and development use only. The general process to the target code generation is as follows: The code's AST is processed with RecursiveASTVisitor s ( clang/tools/sotoc/Visitors.{h,cpp} ) The found target code is recorded in TargetCodeFragment ( clang/tools/sotoc/TargetCode.{h,pp} and clang/tools/sotoc/TargetCodeFragment.{h,cpp} ) The fragments are then 'reconstituted' into valid target code. This transforms C code like 1 2 3 4 5 6 7 8 9 10 int main ( void ) { int x = 0 ; int y = 1 ; int z = 2 ; #pragma omp target map(tofrom:x) { x = x + y + z ; } } into 1 2 3 4 5 6 7 8 9 10 void __omp_offloading_38_272a6c6b_main_l7 ( int * __sotoc_var_x , int y , int z ) { int x = * __sotoc_var_x ; { x = x + y + z ; } * __sotoc_var_x = x ; } The target code is thereby transformed into a function with the mapped variables as arguments.","title":"Target Code Generation"},{"location":"internal/codegen/#extracting-target-code-from-the-ast","text":"The Clang AST of a source file can be viewed using the following command: clang -Xclang -ast-dump -fsyntax-only -fopenmp code.c Info Without the -fopenmp flag Clang ignores #pragma omp . Target regions are separate statements in the AST and functions and variables declared with #pragma omp declare target get a special attribute added to their AST node. The FindTargetCodeVisitor in Visitors.{h,cpp} is used for that. Warning This does not apply the type declarations and there is no guaranty that all functions used in the target region are declared in #pragma omp declare target . To solve the issue we search all target regions, declared functions and variables to additional types, functions, and variables. This is done by the DiscoverTypesInDeclVisitor and DiscoverFunctionsInDeclVisitor . As types can be derived from other types (e.g., struct s or typedef -chains) and functions can depend on other functions and additional types, those dependencies have to be resolved using the DeclResolver (in clang/tools/sotoc/DeclResolver.{h,cpp} ).","title":"Extracting Target Code from the AST"},{"location":"internal/codegen/#analysing-and-recording-the-target-code","text":"Before target code can be generated, additional information about variable mappings have to be collected. Private variables are not mapped. For those we have to create a declaration in the target region using the FindPrivateVariablesVisitor . First-private variables (which is the default) are passed by value into the target region. Variables mapped using from or tofrom , are passed by pointer. For ncc to process them, we bring the variable into scope by copying them into a local variable and afterwards back. Arrays are mapped as pointer. If only an array slice (e.g., map ( to : array [ 10 : ]) ) is mapped, we have to detect the bounds with the FindArraySectionVisitor and move the returned pointer ( array [ 10 ] ) in the target region. Multi-dimensional arrays have to be cast, so they can be accessed using the array [ x ] notation. To recognize the variable form we use the TargetRegionVariable class in clang/tools/sotoc/TargetRegionVariable.{h,cpp} . In addition, we have to rewrite the OpenMP pragma directive and add the appropriate clauses ( OmpPragma.{h,cpp} ). For example if a #pragma omp target parallel is encountered, an additional parallel region has to be added. Some clauses are not supported by the reduced #pragma . Those are filtered out or replaced. Parameters to clauses are also transferred as function arguments of the target function.","title":"Analysing and Recording the Target Code"},{"location":"internal/codegen/#code-generation","text":"An Object of the TargetCode class, serves as a collection of TargetCodeFragment s and generates the code. When adding code fragments, TargetCode sorts them according to their position in the original source file. We try to generate as little code as possible ourselves and let Clangs PrettyPrinter do most of the work, like functions and global variables. Bug Clangs PrettyPrinter is designed for compiler diagnostics and can not do e.g., anonymous struct s and enum s. Note We extended the PrettyPrinter to handle Decl s. We still have to generate functions for regions with mapped variables and clause parameters as arguments and local declarations to bring variables into scope as mentioned above . Bug Mappings with missing elements in the middle are currently not completely mapped by libomptarget/the OpenMP runtime.","title":"Code Generation"},{"location":"internal/design/","text":"Basic Structure and Design Attention This page is for internal and development use only. Libomptarget Libomptarget provides the offloading implementation for the target devices via plugins. Libomptarget and the plugins can be found in the llvm repository in the openmp/libomptarget and openmp/libomptarget/plugins* directories respectively. Note The plugin API is in openmp/libomptarget/include/omptargetplugin.h . The Aurora VE plugin ( openmp/libomptarget/plugins/ve ) is based on the generic x64 offloading plugin generic-elf-64bit ( openmp/libomptarget/plugins/generic-elf-64bit/ ). The AVEO library is used to implement the plugin functions and NECs libveosinfo provides with veo_node_info additional information about the nodes. These are used to provide the number of present devices in the __tgt_rtl_number_of_devices plugin function. The target image can be either linked dynamically as a normal shared library or as statically linked executable ( ELF ). Target Table In addition to the target image , a target table is inserted by the compiler into the host-binary. This table has entries for every target region and global variable in the form of an array of struct __tgt_offload_entry ( openmp/libomptarget/include/omptarget.h ). Note The Table does not include functions marked by #pragma omp declare target . The libomptarget plugin function __tgt_rtl_load_binary passes the target table of the host binary to the plugin and expects a target table with the host addresses of all the symbols in return. veo_get_sym is used to resolve all the symbols in the table. To examine the target table of a host binary, the following command can be used: objdump -s -j omp_offloading_entries a.out Clang integration The compilation pipeline is scheduled by the Clang driver ( clang/lib/Driver/ ). The toolchains for the different architectures can be found in clang/lib/Driver/ToolChains . For the offloading pipeline, additional compile and link jobs are added to the usual compilation pipeline. Those will produce the target image. Afterwards the clang-offload-wrapper is used to wrap the image into the LLVM bitcode file, so it can be linked into the host binary. Note In case the user splits the compilation and linking (e.g., clang -c ), the clang-offload-bundler is used to combine the files to one. The Aurora pipeline is defined in clang/lib/Driver/ToolChains/NECAuroraOffload.{h,cpp} , which, in the end, calls ncc . Some additional code is located in clang/lib/Driver/Driver.cpp and clang/lib/Driver/Compilation.cpp . Because ncc is the host compiler for the VE , the code received by Clang has to be split up in the host and target sections. This is done with the source transformation tool sotoc . For that the toolchain calls clang/tools/nec-aurora-build .","title":"Design"},{"location":"internal/design/#basic-structure-and-design","text":"Attention This page is for internal and development use only.","title":"Basic Structure and Design"},{"location":"internal/design/#libomptarget","text":"Libomptarget provides the offloading implementation for the target devices via plugins. Libomptarget and the plugins can be found in the llvm repository in the openmp/libomptarget and openmp/libomptarget/plugins* directories respectively. Note The plugin API is in openmp/libomptarget/include/omptargetplugin.h . The Aurora VE plugin ( openmp/libomptarget/plugins/ve ) is based on the generic x64 offloading plugin generic-elf-64bit ( openmp/libomptarget/plugins/generic-elf-64bit/ ). The AVEO library is used to implement the plugin functions and NECs libveosinfo provides with veo_node_info additional information about the nodes. These are used to provide the number of present devices in the __tgt_rtl_number_of_devices plugin function. The target image can be either linked dynamically as a normal shared library or as statically linked executable ( ELF ).","title":"Libomptarget"},{"location":"internal/design/#target-table","text":"In addition to the target image , a target table is inserted by the compiler into the host-binary. This table has entries for every target region and global variable in the form of an array of struct __tgt_offload_entry ( openmp/libomptarget/include/omptarget.h ). Note The Table does not include functions marked by #pragma omp declare target . The libomptarget plugin function __tgt_rtl_load_binary passes the target table of the host binary to the plugin and expects a target table with the host addresses of all the symbols in return. veo_get_sym is used to resolve all the symbols in the table. To examine the target table of a host binary, the following command can be used: objdump -s -j omp_offloading_entries a.out","title":"Target Table"},{"location":"internal/design/#clang-integration","text":"The compilation pipeline is scheduled by the Clang driver ( clang/lib/Driver/ ). The toolchains for the different architectures can be found in clang/lib/Driver/ToolChains . For the offloading pipeline, additional compile and link jobs are added to the usual compilation pipeline. Those will produce the target image. Afterwards the clang-offload-wrapper is used to wrap the image into the LLVM bitcode file, so it can be linked into the host binary. Note In case the user splits the compilation and linking (e.g., clang -c ), the clang-offload-bundler is used to combine the files to one. The Aurora pipeline is defined in clang/lib/Driver/ToolChains/NECAuroraOffload.{h,cpp} , which, in the end, calls ncc . Some additional code is located in clang/lib/Driver/Driver.cpp and clang/lib/Driver/Compilation.cpp . Because ncc is the host compiler for the VE , the code received by Clang has to be split up in the host and target sections. This is done with the source transformation tool sotoc . For that the toolchain calls clang/tools/nec-aurora-build .","title":"Clang integration"},{"location":"internal/install_helpers/","text":"Installation Attention This page is for internal and development use only. Installation Script 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/bin/bash set -e module purge module load DEVELOP cmake clang FILE_SYS = \"/scratch/ ${ USER } \" BUILD_DIR = \" ${ FILE_SYS } /clang-dev/BUILD\" SRC_DIR = \" ${ HOME } /llvm-project/llvm\" INSTALL_DIR = \" ${ HOME } /install/clang-dev/install\" echo \"Building in $BUILD_DIR \" mkdir -p \" ${ BUILD_DIR } \" ( cd \" ${ BUILD_DIR } \" cmake -DCMAKE_C_COMPILER = clang \\ -DCMAKE_CXX_COMPILER = clang++ \\ -DLLVM_ENABLE_PROJECTS = \"clang;openmp;libcxx;libcxxabi\" \\ -DCMAKE_BUILD_TYPE = Debug \\ -DBUILD_SHARED_LIBS = ON \\ -DCMAKE_INSTALL_PREFIX = \" ${ INSTALL_DIR } \" \\ -DLLVM_INSTALL_UTILS = OFF \\ -DLIBOMP_TSAN_SUPPORT = OFF \\ -DLLVM_TOOL_LLDB_BUILD = OFF \\ -DLLVM_BUILD_DOCS = OFF \\ -DOPENMP_ENABLE_LIBOMPTARGET = ON \\ -DNECAURORA_TARGET_COMPILER = /opt/nec/ve/ncc/3.0.8/bin/ncc \\ -DSOTOC_ENABLE_TESTS = ON \\ \" ${ SRC_DIR } \" || exit 21 nice make -j 31 install || exit 42 ) Module File Note Don't forget to set $MODULEPATH 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #%Module1.0##################################################################### ### ### clang-dev ### set MAJORVERSION \"13\" set MINORVERSION \"0\" set REVISION \"0\" set VERSION \"13.0.0\" set BASE \" ${ HOME } /install/clang-dev/install\" set AVEO \" ${ HOME } /aveo/install\" set module_base_path /usr/local_rwth/modules/modulefiles/source source \" $module_base_path /FUNCTIONS/output\" source \" $module_base_path /FUNCTIONS/module_management\" source \" $module_base_path /FUNCTIONS/compiler_env\" source \" $module_base_path /FUNCTIONS/usage_log\" log_module_load clang-dev/ $VERSION proc ModulesHelp { } { global VERSION puts stderr \"This module initializes the llvm environment including clang and libomp\" puts stderr \"See \\thttps://github.com/llvm-mirror/\" } module-whatis \"initialize clang-dev ( $VERSION )\" # machine specific names/directories set runTimeLinker \"\" if ! [ info exists HOST ] { switch [ uname machine ] { i686 { set HOST \"i686-pc-linux-gnu\" set runTimeLinker \"-Wl,-rpath=\" } x86_64 { set HOST \"x86_64-unknown-linux-gnu\" set EXTRALIB \"lib64\" set runTimeLinker \"-Wl,-rpath=\" } } } set CLANG \" $BASE \" # if module should be loaded, check for conflicts and print info switch [ module-info mode ] { load { # is this module already loaded? set conflict clang-dev/ $VERSION if { [ is-loaded $conflict ]} { # print a yellow waring at the end of the line m_warning \" $conflict already loaded, doing nothing\" exit } # define conflicts here (example the conflicting module) set conflict clang if { [ is-loaded $conflict ]} { #print a red error at the end of the line m_error \" $conflict already loaded and conflicts with clang.\\nTry unloading $conflict first\" break } # check if software is really installed, if not error if { ! [ file isdirectory $CLANG /bin ] } { m_error \"This software is not installed on this machine. Please try anotherone\" break } # if no conflicts are found print string and a green ok at the end of the line m_success \"Loading clang-dev $VERSION \" } unload { m_success \"Unloading clang-dev $VERSION \" } } prepend-path PATH $CLANG /bin prepend-path MANPATH $CLANG /share/man prepend-path LD_LIBRARY_PATH $CLANG /lib prepend-path LD_LIBRARY_PATH $AVEO /lib prepend-path LIBRARY_PATH $CLANG /lib set linkflags \"-L $CLANG /lib \" set RUNPATH \" $rpathreplacestring$CLANG /lib\" set GCCRPATH \"\" setenv LLVM_ROOT $CLANG setenv CLANG_ROOT $CLANG prepend-path C_INCLUDE_PATH $CLANG /include prepend-path CPLUS_INCLUDE_PATH $CLANG /include prepend-path CPATH $CLANG /include prepend-path CPATH $CLANG /lib/clang/ $VERSION /include init_compiler \"clang\" $MAJORVERSION $MINORVERSION $REVISION set_compiler \"CLANG_\" FC \" \" set_compiler \"CLANG_\" F77 \" \" set_compiler \"CLANG_\" CC clang set_compiler \"CLANG_\" CXX clang++ set_compiler \"CLANG_\" OBJC clang set_compiler \"CLANG_\" OBJCXX clang++ set_compiler_flags \"CLANG_\" \"DEBUG\" \"-g\" set_compiler_flags \"CLANG_\" \"FAST\" \"-O3 -ffast-math -mtune=native\" set_compiler_flags \"CLANG_\" \"FAST_NO_FPOPT\" \"-O3 -mtune=native\" set_compiler_flags \"CLANG_\" \"AUTOPAR\" \" \" set_compiler_flags \"CLANG_\" \"OPENMP\" \" -fopenmp \" set_compiler_flags \"CLANG_\" \"ARCH32\" \" -m32 \" set_compiler_flags \"CLANG_\" \"ARCH64\" \" -m64 \" set_compiler_flags \"CLANG_\" \"FREE\" \" -ffree-form \" set_compiler_flags \"CLANG_\" \"LINKER\" \" $linkflags \" set_compiler_flags \"CLANG_\" \"PIC\" \"-fPIC -DPIC -shared\" #needed for MPI and lapacks set_compiler_flags \"CLANG_\" \"RUNTIME_LINKER\" \" $runTimeLinker \" #FLAGS_L|RPATH shared beween all modules prependable_variable_list \"FLAGS_LPATH\" \" $linkflags \" \"clang\" prependable_variable_list_withreplace \"FLAGS_RPATH\" \" $RUNPATH $GCCRPATH \" \"clang\" $rpathreplacestring $runTimeLinker","title":"Install Helpers"},{"location":"internal/install_helpers/#installation","text":"Attention This page is for internal and development use only.","title":"Installation"},{"location":"internal/install_helpers/#installation-script","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/bin/bash set -e module purge module load DEVELOP cmake clang FILE_SYS = \"/scratch/ ${ USER } \" BUILD_DIR = \" ${ FILE_SYS } /clang-dev/BUILD\" SRC_DIR = \" ${ HOME } /llvm-project/llvm\" INSTALL_DIR = \" ${ HOME } /install/clang-dev/install\" echo \"Building in $BUILD_DIR \" mkdir -p \" ${ BUILD_DIR } \" ( cd \" ${ BUILD_DIR } \" cmake -DCMAKE_C_COMPILER = clang \\ -DCMAKE_CXX_COMPILER = clang++ \\ -DLLVM_ENABLE_PROJECTS = \"clang;openmp;libcxx;libcxxabi\" \\ -DCMAKE_BUILD_TYPE = Debug \\ -DBUILD_SHARED_LIBS = ON \\ -DCMAKE_INSTALL_PREFIX = \" ${ INSTALL_DIR } \" \\ -DLLVM_INSTALL_UTILS = OFF \\ -DLIBOMP_TSAN_SUPPORT = OFF \\ -DLLVM_TOOL_LLDB_BUILD = OFF \\ -DLLVM_BUILD_DOCS = OFF \\ -DOPENMP_ENABLE_LIBOMPTARGET = ON \\ -DNECAURORA_TARGET_COMPILER = /opt/nec/ve/ncc/3.0.8/bin/ncc \\ -DSOTOC_ENABLE_TESTS = ON \\ \" ${ SRC_DIR } \" || exit 21 nice make -j 31 install || exit 42 )","title":"Installation Script"},{"location":"internal/install_helpers/#module-file","text":"Note Don't forget to set $MODULEPATH 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 #%Module1.0##################################################################### ### ### clang-dev ### set MAJORVERSION \"13\" set MINORVERSION \"0\" set REVISION \"0\" set VERSION \"13.0.0\" set BASE \" ${ HOME } /install/clang-dev/install\" set AVEO \" ${ HOME } /aveo/install\" set module_base_path /usr/local_rwth/modules/modulefiles/source source \" $module_base_path /FUNCTIONS/output\" source \" $module_base_path /FUNCTIONS/module_management\" source \" $module_base_path /FUNCTIONS/compiler_env\" source \" $module_base_path /FUNCTIONS/usage_log\" log_module_load clang-dev/ $VERSION proc ModulesHelp { } { global VERSION puts stderr \"This module initializes the llvm environment including clang and libomp\" puts stderr \"See \\thttps://github.com/llvm-mirror/\" } module-whatis \"initialize clang-dev ( $VERSION )\" # machine specific names/directories set runTimeLinker \"\" if ! [ info exists HOST ] { switch [ uname machine ] { i686 { set HOST \"i686-pc-linux-gnu\" set runTimeLinker \"-Wl,-rpath=\" } x86_64 { set HOST \"x86_64-unknown-linux-gnu\" set EXTRALIB \"lib64\" set runTimeLinker \"-Wl,-rpath=\" } } } set CLANG \" $BASE \" # if module should be loaded, check for conflicts and print info switch [ module-info mode ] { load { # is this module already loaded? set conflict clang-dev/ $VERSION if { [ is-loaded $conflict ]} { # print a yellow waring at the end of the line m_warning \" $conflict already loaded, doing nothing\" exit } # define conflicts here (example the conflicting module) set conflict clang if { [ is-loaded $conflict ]} { #print a red error at the end of the line m_error \" $conflict already loaded and conflicts with clang.\\nTry unloading $conflict first\" break } # check if software is really installed, if not error if { ! [ file isdirectory $CLANG /bin ] } { m_error \"This software is not installed on this machine. Please try anotherone\" break } # if no conflicts are found print string and a green ok at the end of the line m_success \"Loading clang-dev $VERSION \" } unload { m_success \"Unloading clang-dev $VERSION \" } } prepend-path PATH $CLANG /bin prepend-path MANPATH $CLANG /share/man prepend-path LD_LIBRARY_PATH $CLANG /lib prepend-path LD_LIBRARY_PATH $AVEO /lib prepend-path LIBRARY_PATH $CLANG /lib set linkflags \"-L $CLANG /lib \" set RUNPATH \" $rpathreplacestring$CLANG /lib\" set GCCRPATH \"\" setenv LLVM_ROOT $CLANG setenv CLANG_ROOT $CLANG prepend-path C_INCLUDE_PATH $CLANG /include prepend-path CPLUS_INCLUDE_PATH $CLANG /include prepend-path CPATH $CLANG /include prepend-path CPATH $CLANG /lib/clang/ $VERSION /include init_compiler \"clang\" $MAJORVERSION $MINORVERSION $REVISION set_compiler \"CLANG_\" FC \" \" set_compiler \"CLANG_\" F77 \" \" set_compiler \"CLANG_\" CC clang set_compiler \"CLANG_\" CXX clang++ set_compiler \"CLANG_\" OBJC clang set_compiler \"CLANG_\" OBJCXX clang++ set_compiler_flags \"CLANG_\" \"DEBUG\" \"-g\" set_compiler_flags \"CLANG_\" \"FAST\" \"-O3 -ffast-math -mtune=native\" set_compiler_flags \"CLANG_\" \"FAST_NO_FPOPT\" \"-O3 -mtune=native\" set_compiler_flags \"CLANG_\" \"AUTOPAR\" \" \" set_compiler_flags \"CLANG_\" \"OPENMP\" \" -fopenmp \" set_compiler_flags \"CLANG_\" \"ARCH32\" \" -m32 \" set_compiler_flags \"CLANG_\" \"ARCH64\" \" -m64 \" set_compiler_flags \"CLANG_\" \"FREE\" \" -ffree-form \" set_compiler_flags \"CLANG_\" \"LINKER\" \" $linkflags \" set_compiler_flags \"CLANG_\" \"PIC\" \"-fPIC -DPIC -shared\" #needed for MPI and lapacks set_compiler_flags \"CLANG_\" \"RUNTIME_LINKER\" \" $runTimeLinker \" #FLAGS_L|RPATH shared beween all modules prependable_variable_list \"FLAGS_LPATH\" \" $linkflags \" \"clang\" prependable_variable_list_withreplace \"FLAGS_RPATH\" \" $RUNPATH $GCCRPATH \" \"clang\" $rpathreplacestring $runTimeLinker","title":"Module File"},{"location":"internal/doxygen/","text":"sotoc - Source Transformation for OpenMP Code sotoc is written as a Clang tool and makes use of the Clang tooling infrastructure to parse C source files, search for target regions and other code that will be offloaded to a target device, and then extract and transform this code into new C code that can then be compiled by a target compiler into a target image to be used as a OpenMP device binary. The tool is part of this Clang repository and is automatically build together with clang. The tool comes with a regression test suite that uses llvm-lit . The tests can be run using the CMake generated build script when the CMake option SOTOC_ENABLE_TESTS is set to ON by running $ make check-sotoc To run the tests, make sure that LLVM's FileCheck tool is in the path.","title":"sotoc - Source Transformation for OpenMP Code"},{"location":"internal/doxygen/#sotoc-source-transformation-for-openmp-code","text":"sotoc is written as a Clang tool and makes use of the Clang tooling infrastructure to parse C source files, search for target regions and other code that will be offloaded to a target device, and then extract and transform this code into new C code that can then be compiled by a target compiler into a target image to be used as a OpenMP device binary. The tool is part of this Clang repository and is automatically build together with clang. The tool comes with a regression test suite that uses llvm-lit . The tests can be run using the CMake generated build script when the CMake option SOTOC_ENABLE_TESTS is set to ON by running $ make check-sotoc To run the tests, make sure that LLVM's FileCheck tool is in the path.","title":"sotoc - Source Transformation for OpenMP Code"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVarsVisitor/","text":"CollectOMPClauseParamsVarsVisitor OMP clause visitor. Inherits from clang::RecursiveASTVisitor< CollectOMPClauseParamsVarsVisitor > Public Functions Name CollectOMPClauseParamsVarsVisitor (std::shared_ptr< TargetCodeRegion > & TCR) bool VisitStmt (clang::Stmt * S) Private Attributes Name std::shared_ptr< TargetCodeRegion > TCR Public Functions Documentation function CollectOMPClauseParamsVarsVisitor 1 2 3 inline CollectOMPClauseParamsVarsVisitor ( std :: shared_ptr < TargetCodeRegion > & TCR ) function VisitStmt 1 2 3 inline bool VisitStmt ( clang :: Stmt * S ) Private Attributes Documentation variable TCR 1 std :: shared_ptr < TargetCodeRegion > TCR ;","title":"CollectOMPClauseParamsVarsVisitor"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVarsVisitor/#collectompclauseparamsvarsvisitor","text":"OMP clause visitor. Inherits from clang::RecursiveASTVisitor< CollectOMPClauseParamsVarsVisitor >","title":"CollectOMPClauseParamsVarsVisitor"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVarsVisitor/#public-functions","text":"Name CollectOMPClauseParamsVarsVisitor (std::shared_ptr< TargetCodeRegion > & TCR) bool VisitStmt (clang::Stmt * S)","title":"Public Functions"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVarsVisitor/#private-attributes","text":"Name std::shared_ptr< TargetCodeRegion > TCR","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVarsVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVarsVisitor/#function-collectompclauseparamsvarsvisitor","text":"1 2 3 inline CollectOMPClauseParamsVarsVisitor ( std :: shared_ptr < TargetCodeRegion > & TCR )","title":"function CollectOMPClauseParamsVarsVisitor"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVarsVisitor/#function-visitstmt","text":"1 2 3 inline bool VisitStmt ( clang :: Stmt * S )","title":"function VisitStmt"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVarsVisitor/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVarsVisitor/#variable-tcr","text":"1 std :: shared_ptr < TargetCodeRegion > TCR ;","title":"variable TCR"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVisitor/","text":"CollectOMPClauseParamsVisitor OMP clause parameter visitor. Inherits from clang::RecursiveASTVisitor< CollectOMPClauseParamsVisitor > Public Functions Name CollectOMPClauseParamsVisitor (std::shared_ptr< TargetCodeRegion > & TCR) bool VisitStmt (clang::Stmt * S) Private Attributes Name CollectOMPClauseParamsVarsVisitor VarsVisitor bool InExplicitCast Public Functions Documentation function CollectOMPClauseParamsVisitor 1 2 3 inline CollectOMPClauseParamsVisitor ( std :: shared_ptr < TargetCodeRegion > & TCR ) function VisitStmt 1 2 3 inline bool VisitStmt ( clang :: Stmt * S ) Private Attributes Documentation variable VarsVisitor 1 CollectOMPClauseParamsVarsVisitor VarsVisitor ; variable InExplicitCast 1 bool InExplicitCast ;","title":"CollectOMPClauseParamsVisitor"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVisitor/#collectompclauseparamsvisitor","text":"OMP clause parameter visitor. Inherits from clang::RecursiveASTVisitor< CollectOMPClauseParamsVisitor >","title":"CollectOMPClauseParamsVisitor"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVisitor/#public-functions","text":"Name CollectOMPClauseParamsVisitor (std::shared_ptr< TargetCodeRegion > & TCR) bool VisitStmt (clang::Stmt * S)","title":"Public Functions"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVisitor/#private-attributes","text":"Name CollectOMPClauseParamsVarsVisitor VarsVisitor bool InExplicitCast","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVisitor/#function-collectompclauseparamsvisitor","text":"1 2 3 inline CollectOMPClauseParamsVisitor ( std :: shared_ptr < TargetCodeRegion > & TCR )","title":"function CollectOMPClauseParamsVisitor"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVisitor/#function-visitstmt","text":"1 2 3 inline bool VisitStmt ( clang :: Stmt * S )","title":"function VisitStmt"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVisitor/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVisitor/#variable-varsvisitor","text":"1 CollectOMPClauseParamsVarsVisitor VarsVisitor ;","title":"variable VarsVisitor"},{"location":"internal/doxygen/Classes/classCollectOMPClauseParamsVisitor/#variable-inexplicitcast","text":"1 bool InExplicitCast ;","title":"variable InExplicitCast"},{"location":"internal/doxygen/Classes/classDeclResolver/","text":"DeclResolver Records, orders and finds the dependencies of Decls (TypeDecls or FunctionDecls) #include <DeclResolver.h> Inherited by FunctionDeclResolver , TypeDeclResolver Public Functions Name virtual ~DeclResolver () =0 void addDecl (clang::Decl * D) Records a Decl and automatically adds all Decls that this Decl depends on. void orderAndAddFragments ( TargetCode & TC) Creates a TargetCodeFragment for each recorded Decl and adds them to the TargetCode object in the correct order. Protected Functions Name virtual void runOwnVisitor (clang::Decl * D, std::function< void(clang::Decl *Dep)> Fn) =0 With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. virtual void findDependDecls (clang::Decl * D, std::unordered_set< clang::Decl * > & UnresolvedDecls) This function uses a visitor to find references to other declarations in the declaration being added. Private Functions Name void topoSort (std::stack< clang::Decl * > & q) This functions does a topological sorting on the dependency graph of all Decls recorded into this object by calling addDecl . void topoSortUtil (std::stack< clang::Decl * > & q, std::map< clang::Decl *, bool > & visited, clang::Decl * D) Helper function for topoSort , to do an recursive DFS. Private Attributes Name DeclMap AllDecls Records all declarations added to the resolver. std::set< clang::Decl * > NonDependentDecls All declarations which do not depend on other declarations. std::set< std::string > RequiredSystemHeaders When a declaration is inside a system header, that header is recorded here instead of the declaratoin. Public Functions Documentation function ~DeclResolver 1 virtual ~ DeclResolver () = 0 function addDecl 1 2 3 void addDecl ( clang :: Decl * D ) Records a Decl and automatically adds all Decls that this Decl depends on. Parameters : D the Decl to be added to the resolver. function orderAndAddFragments 1 2 3 void orderAndAddFragments ( TargetCode & TC ) Creates a TargetCodeFragment for each recorded Decl and adds them to the TargetCode object in the correct order. Parameters : TC the TargetCode object, the fragments will be added to. Protected Functions Documentation function runOwnVisitor 1 2 3 4 virtual void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) = 0 With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. Reimplemented by : TypeDeclResolver::runOwnVisitor , FunctionDeclResolver::runOwnVisitor function findDependDecls 1 2 3 4 virtual void findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl * > & UnresolvedDecls ) This function uses a visitor to find references to other declarations in the declaration being added. Parameters : D the declaration that was added via addDecl . UnresolvedDecls a set of declarations which D depends on and which are currently unresolved. Reimplemented by : FunctionDeclResolver::findDependDecls If the declaration being added references other declarations outside the standard library, we need to add those declaration to the target code too. Private Functions Documentation function topoSort 1 2 3 void topoSort ( std :: stack < clang :: Decl * > & q ) This functions does a topological sorting on the dependency graph of all Decls recorded into this object by calling addDecl . Parameters : q an queue where the ordered Decls are save to. This method uses an DFS approach to be able to deal with possible cycles. function topoSortUtil 1 2 3 4 5 void topoSortUtil ( std :: stack < clang :: Decl * > & q , std :: map < clang :: Decl * , bool > & visited , clang :: Decl * D ) Helper function for topoSort , to do an recursive DFS. Private Attributes Documentation variable AllDecls 1 DeclMap AllDecls ; Records all declarations added to the resolver. variable NonDependentDecls 1 std :: set < clang :: Decl * > NonDependentDecls ; All declarations which do not depend on other declarations. variable RequiredSystemHeaders 1 std :: set < std :: string > RequiredSystemHeaders ; When a declaration is inside a system header, that header is recorded here instead of the declaratoin.","title":"DeclResolver"},{"location":"internal/doxygen/Classes/classDeclResolver/#declresolver","text":"Records, orders and finds the dependencies of Decls (TypeDecls or FunctionDecls) #include <DeclResolver.h> Inherited by FunctionDeclResolver , TypeDeclResolver","title":"DeclResolver"},{"location":"internal/doxygen/Classes/classDeclResolver/#public-functions","text":"Name virtual ~DeclResolver () =0 void addDecl (clang::Decl * D) Records a Decl and automatically adds all Decls that this Decl depends on. void orderAndAddFragments ( TargetCode & TC) Creates a TargetCodeFragment for each recorded Decl and adds them to the TargetCode object in the correct order.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classDeclResolver/#protected-functions","text":"Name virtual void runOwnVisitor (clang::Decl * D, std::function< void(clang::Decl *Dep)> Fn) =0 With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. virtual void findDependDecls (clang::Decl * D, std::unordered_set< clang::Decl * > & UnresolvedDecls) This function uses a visitor to find references to other declarations in the declaration being added.","title":"Protected Functions"},{"location":"internal/doxygen/Classes/classDeclResolver/#private-functions","text":"Name void topoSort (std::stack< clang::Decl * > & q) This functions does a topological sorting on the dependency graph of all Decls recorded into this object by calling addDecl . void topoSortUtil (std::stack< clang::Decl * > & q, std::map< clang::Decl *, bool > & visited, clang::Decl * D) Helper function for topoSort , to do an recursive DFS.","title":"Private Functions"},{"location":"internal/doxygen/Classes/classDeclResolver/#private-attributes","text":"Name DeclMap AllDecls Records all declarations added to the resolver. std::set< clang::Decl * > NonDependentDecls All declarations which do not depend on other declarations. std::set< std::string > RequiredSystemHeaders When a declaration is inside a system header, that header is recorded here instead of the declaratoin.","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classDeclResolver/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classDeclResolver/#function-declresolver","text":"1 virtual ~ DeclResolver () = 0","title":"function ~DeclResolver"},{"location":"internal/doxygen/Classes/classDeclResolver/#function-adddecl","text":"1 2 3 void addDecl ( clang :: Decl * D ) Records a Decl and automatically adds all Decls that this Decl depends on. Parameters : D the Decl to be added to the resolver.","title":"function addDecl"},{"location":"internal/doxygen/Classes/classDeclResolver/#function-orderandaddfragments","text":"1 2 3 void orderAndAddFragments ( TargetCode & TC ) Creates a TargetCodeFragment for each recorded Decl and adds them to the TargetCode object in the correct order. Parameters : TC the TargetCode object, the fragments will be added to.","title":"function orderAndAddFragments"},{"location":"internal/doxygen/Classes/classDeclResolver/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"internal/doxygen/Classes/classDeclResolver/#function-runownvisitor","text":"1 2 3 4 virtual void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) = 0 With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. Reimplemented by : TypeDeclResolver::runOwnVisitor , FunctionDeclResolver::runOwnVisitor","title":"function runOwnVisitor"},{"location":"internal/doxygen/Classes/classDeclResolver/#function-finddependdecls","text":"1 2 3 4 virtual void findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl * > & UnresolvedDecls ) This function uses a visitor to find references to other declarations in the declaration being added. Parameters : D the declaration that was added via addDecl . UnresolvedDecls a set of declarations which D depends on and which are currently unresolved. Reimplemented by : FunctionDeclResolver::findDependDecls If the declaration being added references other declarations outside the standard library, we need to add those declaration to the target code too.","title":"function findDependDecls"},{"location":"internal/doxygen/Classes/classDeclResolver/#private-functions-documentation","text":"","title":"Private Functions Documentation"},{"location":"internal/doxygen/Classes/classDeclResolver/#function-toposort","text":"1 2 3 void topoSort ( std :: stack < clang :: Decl * > & q ) This functions does a topological sorting on the dependency graph of all Decls recorded into this object by calling addDecl . Parameters : q an queue where the ordered Decls are save to. This method uses an DFS approach to be able to deal with possible cycles.","title":"function topoSort"},{"location":"internal/doxygen/Classes/classDeclResolver/#function-toposortutil","text":"1 2 3 4 5 void topoSortUtil ( std :: stack < clang :: Decl * > & q , std :: map < clang :: Decl * , bool > & visited , clang :: Decl * D ) Helper function for topoSort , to do an recursive DFS.","title":"function topoSortUtil"},{"location":"internal/doxygen/Classes/classDeclResolver/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classDeclResolver/#variable-alldecls","text":"1 DeclMap AllDecls ; Records all declarations added to the resolver.","title":"variable AllDecls"},{"location":"internal/doxygen/Classes/classDeclResolver/#variable-nondependentdecls","text":"1 std :: set < clang :: Decl * > NonDependentDecls ; All declarations which do not depend on other declarations.","title":"variable NonDependentDecls"},{"location":"internal/doxygen/Classes/classDeclResolver/#variable-requiredsystemheaders","text":"1 std :: set < std :: string > RequiredSystemHeaders ; When a declaration is inside a system header, that header is recorded here instead of the declaratoin.","title":"variable RequiredSystemHeaders"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/","text":"DiscoverFunctionsInDeclVisitor Traverses (parts of) the AST to find DeclRefExpr that refer to functions that need to be present for that part of the AST to compile correctly. More... #include <Visitors.h> Inherits from clang::RecursiveASTVisitor< DiscoverFunctionsInDeclVisitor > Public Functions Name DiscoverFunctionsInDeclVisitor ( FunctionDeclResolver & Functions) Construct a new Discover Functions In Decl Visitor:: Discover Functions In Decl Visitor object. bool VisitExpr (clang::Expr * E) Visit function for Expressions. Public Attributes Name pad0 Private Attributes Name std::function< void(clang::FunctionDecl *)> OnEachFuncRef Detailed Description 1 class DiscoverFunctionsInDeclVisitor ; Traverses (parts of) the AST to find DeclRefExpr that refer to functions that need to be present for that part of the AST to compile correctly. This way functions declared and defined in the same compilation unit do not need to be annotated by the 'omp declare target' pragma. The Visitor is not only used to search through target regions, but also through the found functions themselves and through functions that are annotated with the 'omp declare target' pragma, to find all necessary dependencies recursively. Public Functions Documentation function DiscoverFunctionsInDeclVisitor 1 2 3 DiscoverFunctionsInDeclVisitor ( FunctionDeclResolver & Functions ) Construct a new Discover Functions In Decl Visitor:: Discover Functions In Decl Visitor object. Parameters : Functions function VisitExpr 1 2 3 bool VisitExpr ( clang :: Expr * E ) Visit function for Expressions. Parameters : E Given expression Expression Visitor in DiscoverFunctionsInDeclVisitor Public Attributes Documentation variable pad0 1 __pad0__ ; Private Attributes Documentation variable OnEachFuncRef 1 std :: function < void ( clang :: FunctionDecl * ) > OnEachFuncRef ;","title":"DiscoverFunctionsInDeclVisitor"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#discoverfunctionsindeclvisitor","text":"Traverses (parts of) the AST to find DeclRefExpr that refer to functions that need to be present for that part of the AST to compile correctly. More... #include <Visitors.h> Inherits from clang::RecursiveASTVisitor< DiscoverFunctionsInDeclVisitor >","title":"DiscoverFunctionsInDeclVisitor"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#public-functions","text":"Name DiscoverFunctionsInDeclVisitor ( FunctionDeclResolver & Functions) Construct a new Discover Functions In Decl Visitor:: Discover Functions In Decl Visitor object. bool VisitExpr (clang::Expr * E) Visit function for Expressions.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#public-attributes","text":"Name pad0","title":"Public Attributes"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#private-attributes","text":"Name std::function< void(clang::FunctionDecl *)> OnEachFuncRef","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#detailed-description","text":"1 class DiscoverFunctionsInDeclVisitor ; Traverses (parts of) the AST to find DeclRefExpr that refer to functions that need to be present for that part of the AST to compile correctly. This way functions declared and defined in the same compilation unit do not need to be annotated by the 'omp declare target' pragma. The Visitor is not only used to search through target regions, but also through the found functions themselves and through functions that are annotated with the 'omp declare target' pragma, to find all necessary dependencies recursively.","title":"Detailed Description"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#function-discoverfunctionsindeclvisitor","text":"1 2 3 DiscoverFunctionsInDeclVisitor ( FunctionDeclResolver & Functions ) Construct a new Discover Functions In Decl Visitor:: Discover Functions In Decl Visitor object. Parameters : Functions","title":"function DiscoverFunctionsInDeclVisitor"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#function-visitexpr","text":"1 2 3 bool VisitExpr ( clang :: Expr * E ) Visit function for Expressions. Parameters : E Given expression Expression Visitor in DiscoverFunctionsInDeclVisitor","title":"function VisitExpr"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#variable-pad0","text":"1 __pad0__ ;","title":"variable pad0"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classDiscoverFunctionsInDeclVisitor/#variable-oneachfuncref","text":"1 std :: function < void ( clang :: FunctionDecl * ) > OnEachFuncRef ;","title":"variable OnEachFuncRef"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/","text":"DiscoverTypesInDeclVisitor Traverses (parts of) the AST to find DeclRefExpr that refer to types that need to be present for that part of the AST to compile correctly. More... #include <Visitors.h> Inherits from clang::RecursiveASTVisitor< DiscoverTypesInDeclVisitor > Public Functions Name DiscoverTypesInDeclVisitor ( TypeDeclResolver & Types) Construct a new Discover Types In Decl Visitor:: Discover Types In Decl Visitor object. bool VisitDecl (clang::Decl * D) Visit function for declaration. bool VisitExpr (clang::Expr * D) Visit function for expressions. bool VisitType (clang::Type * T) Visit function for types. Private Functions Name void processType (const clang::Type * D) Retrieves the declaration of the type found and passes it on. Public Attributes Name pad0 Private Attributes Name std::function< void(clang::TypeDecl *)> OnEachTypeRef Function run on the declaration of each type found by the visitor. Detailed Description 1 class DiscoverTypesInDeclVisitor ; Traverses (parts of) the AST to find DeclRefExpr that refer to types that need to be present for that part of the AST to compile correctly. The visitor is not only used to search through target regions and functions, but also through type declarations themselves, in order to also find types that the already found types depend on to compile. Public Functions Documentation function DiscoverTypesInDeclVisitor 1 2 3 DiscoverTypesInDeclVisitor ( TypeDeclResolver & Types ) Construct a new Discover Types In Decl Visitor:: Discover Types In Decl Visitor object. Parameters : Types function VisitDecl 1 2 3 bool VisitDecl ( clang :: Decl * D ) Visit function for declaration. Parameters : D Given declaration Declaration Visitor for the DiscoverTypesInDeclVisitor function VisitExpr 1 2 3 bool VisitExpr ( clang :: Expr * D ) Visit function for expressions. Parameters : E Given expression Expression Visitor for DiscoverTypesInDeclVisitor function VisitType 1 2 3 bool VisitType ( clang :: Type * T ) Visit function for types. Parameters : T Given Type Type Visitor for DiscoverTypesInDeclVisitor Private Functions Documentation function processType 1 2 3 void processType ( const clang :: Type * D ) Retrieves the declaration of the type found and passes it on. Parameters : TP Processing function for types. Processes types found by the DiscoverTypesInDeclVisitor Public Attributes Documentation variable pad0 1 __pad0__ ; Private Attributes Documentation variable OnEachTypeRef 1 std :: function < void ( clang :: TypeDecl * ) > OnEachTypeRef ; Function run on the declaration of each type found by the visitor.","title":"DiscoverTypesInDeclVisitor"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#discovertypesindeclvisitor","text":"Traverses (parts of) the AST to find DeclRefExpr that refer to types that need to be present for that part of the AST to compile correctly. More... #include <Visitors.h> Inherits from clang::RecursiveASTVisitor< DiscoverTypesInDeclVisitor >","title":"DiscoverTypesInDeclVisitor"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#public-functions","text":"Name DiscoverTypesInDeclVisitor ( TypeDeclResolver & Types) Construct a new Discover Types In Decl Visitor:: Discover Types In Decl Visitor object. bool VisitDecl (clang::Decl * D) Visit function for declaration. bool VisitExpr (clang::Expr * D) Visit function for expressions. bool VisitType (clang::Type * T) Visit function for types.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#private-functions","text":"Name void processType (const clang::Type * D) Retrieves the declaration of the type found and passes it on.","title":"Private Functions"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#public-attributes","text":"Name pad0","title":"Public Attributes"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#private-attributes","text":"Name std::function< void(clang::TypeDecl *)> OnEachTypeRef Function run on the declaration of each type found by the visitor.","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#detailed-description","text":"1 class DiscoverTypesInDeclVisitor ; Traverses (parts of) the AST to find DeclRefExpr that refer to types that need to be present for that part of the AST to compile correctly. The visitor is not only used to search through target regions and functions, but also through type declarations themselves, in order to also find types that the already found types depend on to compile.","title":"Detailed Description"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#function-discovertypesindeclvisitor","text":"1 2 3 DiscoverTypesInDeclVisitor ( TypeDeclResolver & Types ) Construct a new Discover Types In Decl Visitor:: Discover Types In Decl Visitor object. Parameters : Types","title":"function DiscoverTypesInDeclVisitor"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#function-visitdecl","text":"1 2 3 bool VisitDecl ( clang :: Decl * D ) Visit function for declaration. Parameters : D Given declaration Declaration Visitor for the DiscoverTypesInDeclVisitor","title":"function VisitDecl"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#function-visitexpr","text":"1 2 3 bool VisitExpr ( clang :: Expr * D ) Visit function for expressions. Parameters : E Given expression Expression Visitor for DiscoverTypesInDeclVisitor","title":"function VisitExpr"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#function-visittype","text":"1 2 3 bool VisitType ( clang :: Type * T ) Visit function for types. Parameters : T Given Type Type Visitor for DiscoverTypesInDeclVisitor","title":"function VisitType"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#private-functions-documentation","text":"","title":"Private Functions Documentation"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#function-processtype","text":"1 2 3 void processType ( const clang :: Type * D ) Retrieves the declaration of the type found and passes it on. Parameters : TP Processing function for types. Processes types found by the DiscoverTypesInDeclVisitor","title":"function processType"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#variable-pad0","text":"1 __pad0__ ;","title":"variable pad0"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classDiscoverTypesInDeclVisitor/#variable-oneachtyperef","text":"1 std :: function < void ( clang :: TypeDecl * ) > OnEachTypeRef ; Function run on the declaration of each type found by the visitor.","title":"variable OnEachTypeRef"},{"location":"internal/doxygen/Classes/classFindArraySectionVisitor/","text":"FindArraySectionVisitor #include <Visitors.h> Inherits from clang::RecursiveASTVisitor< FindArraySectionVisitor > Public Functions Name FindArraySectionVisitor (std::map< clang::VarDecl *, clang::Expr * > & LowerBoundsMap) bool VisitExpr (clang::Expr * E) Visit function for Expressions. Private Attributes Name std::map< clang::VarDecl *, clang::Expr * > & LowerBoundsMap Public Functions Documentation function FindArraySectionVisitor 1 2 3 inline FindArraySectionVisitor ( std :: map < clang :: VarDecl * , clang :: Expr * > & LowerBoundsMap ) function VisitExpr 1 2 3 bool VisitExpr ( clang :: Expr * E ) Visit function for Expressions. Parameters : E Given expression Expression Visitor in FindArraySectionVisitor Private Attributes Documentation variable LowerBoundsMap 1 std :: map < clang :: VarDecl * , clang :: Expr * > & LowerBoundsMap ;","title":"FindArraySectionVisitor"},{"location":"internal/doxygen/Classes/classFindArraySectionVisitor/#findarraysectionvisitor","text":"#include <Visitors.h> Inherits from clang::RecursiveASTVisitor< FindArraySectionVisitor >","title":"FindArraySectionVisitor"},{"location":"internal/doxygen/Classes/classFindArraySectionVisitor/#public-functions","text":"Name FindArraySectionVisitor (std::map< clang::VarDecl *, clang::Expr * > & LowerBoundsMap) bool VisitExpr (clang::Expr * E) Visit function for Expressions.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classFindArraySectionVisitor/#private-attributes","text":"Name std::map< clang::VarDecl *, clang::Expr * > & LowerBoundsMap","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classFindArraySectionVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classFindArraySectionVisitor/#function-findarraysectionvisitor","text":"1 2 3 inline FindArraySectionVisitor ( std :: map < clang :: VarDecl * , clang :: Expr * > & LowerBoundsMap )","title":"function FindArraySectionVisitor"},{"location":"internal/doxygen/Classes/classFindArraySectionVisitor/#function-visitexpr","text":"1 2 3 bool VisitExpr ( clang :: Expr * E ) Visit function for Expressions. Parameters : E Given expression Expression Visitor in FindArraySectionVisitor","title":"function VisitExpr"},{"location":"internal/doxygen/Classes/classFindArraySectionVisitor/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classFindArraySectionVisitor/#variable-lowerboundsmap","text":"1 std :: map < clang :: VarDecl * , clang :: Expr * > & LowerBoundsMap ;","title":"variable LowerBoundsMap"},{"location":"internal/doxygen/Classes/classFindDeclRefExprVisitor/","text":"FindDeclRefExprVisitor #include <Visitors.h> Inherits from clang::RecursiveASTVisitor< FindDeclRefExprVisitor > Public Functions Name FindDeclRefExprVisitor () bool VisitStmt (clang::Stmt * S) Visit function for statements. std::unordered_set< clang::VarDecl * > * getVarSet () Private Attributes Name std::unordered_set< clang::VarDecl * > VarSet Public Functions Documentation function FindDeclRefExprVisitor 1 inline FindDeclRefExprVisitor () function VisitStmt 1 2 3 bool VisitStmt ( clang :: Stmt * S ) Visit function for statements. Parameters : S Given statement Statement Visitor for the FindDeclRefExprVisitor function getVarSet 1 inline std :: unordered_set < clang :: VarDecl * > * getVarSet () Private Attributes Documentation variable VarSet 1 std :: unordered_set < clang :: VarDecl * > VarSet ;","title":"FindDeclRefExprVisitor"},{"location":"internal/doxygen/Classes/classFindDeclRefExprVisitor/#finddeclrefexprvisitor","text":"#include <Visitors.h> Inherits from clang::RecursiveASTVisitor< FindDeclRefExprVisitor >","title":"FindDeclRefExprVisitor"},{"location":"internal/doxygen/Classes/classFindDeclRefExprVisitor/#public-functions","text":"Name FindDeclRefExprVisitor () bool VisitStmt (clang::Stmt * S) Visit function for statements. std::unordered_set< clang::VarDecl * > * getVarSet ()","title":"Public Functions"},{"location":"internal/doxygen/Classes/classFindDeclRefExprVisitor/#private-attributes","text":"Name std::unordered_set< clang::VarDecl * > VarSet","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classFindDeclRefExprVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classFindDeclRefExprVisitor/#function-finddeclrefexprvisitor","text":"1 inline FindDeclRefExprVisitor ()","title":"function FindDeclRefExprVisitor"},{"location":"internal/doxygen/Classes/classFindDeclRefExprVisitor/#function-visitstmt","text":"1 2 3 bool VisitStmt ( clang :: Stmt * S ) Visit function for statements. Parameters : S Given statement Statement Visitor for the FindDeclRefExprVisitor","title":"function VisitStmt"},{"location":"internal/doxygen/Classes/classFindDeclRefExprVisitor/#function-getvarset","text":"1 inline std :: unordered_set < clang :: VarDecl * > * getVarSet ()","title":"function getVarSet"},{"location":"internal/doxygen/Classes/classFindDeclRefExprVisitor/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classFindDeclRefExprVisitor/#variable-varset","text":"1 std :: unordered_set < clang :: VarDecl * > VarSet ;","title":"variable VarSet"},{"location":"internal/doxygen/Classes/classFindLoopStmtVisitor/","text":"FindLoopStmtVisitor #include <Visitors.h> Inherits from clang::RecursiveASTVisitor< FindLoopStmtVisitor > Public Functions Name FindLoopStmtVisitor () bool VisitStmt (clang::Stmt * S) Visit function for statements. std::unordered_set< clang::VarDecl * > * getVarSet () Private Attributes Name FindDeclRefExprVisitor FindDeclRefVisitor Public Functions Documentation function FindLoopStmtVisitor 1 inline FindLoopStmtVisitor () function VisitStmt 1 2 3 bool VisitStmt ( clang :: Stmt * S ) Visit function for statements. Parameters : S Given statement Statement Visitor for the FindLoopStmtVisitor function getVarSet 1 inline std :: unordered_set < clang :: VarDecl * > * getVarSet () Private Attributes Documentation variable FindDeclRefVisitor 1 FindDeclRefExprVisitor FindDeclRefVisitor ;","title":"FindLoopStmtVisitor"},{"location":"internal/doxygen/Classes/classFindLoopStmtVisitor/#findloopstmtvisitor","text":"#include <Visitors.h> Inherits from clang::RecursiveASTVisitor< FindLoopStmtVisitor >","title":"FindLoopStmtVisitor"},{"location":"internal/doxygen/Classes/classFindLoopStmtVisitor/#public-functions","text":"Name FindLoopStmtVisitor () bool VisitStmt (clang::Stmt * S) Visit function for statements. std::unordered_set< clang::VarDecl * > * getVarSet ()","title":"Public Functions"},{"location":"internal/doxygen/Classes/classFindLoopStmtVisitor/#private-attributes","text":"Name FindDeclRefExprVisitor FindDeclRefVisitor","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classFindLoopStmtVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classFindLoopStmtVisitor/#function-findloopstmtvisitor","text":"1 inline FindLoopStmtVisitor ()","title":"function FindLoopStmtVisitor"},{"location":"internal/doxygen/Classes/classFindLoopStmtVisitor/#function-visitstmt","text":"1 2 3 bool VisitStmt ( clang :: Stmt * S ) Visit function for statements. Parameters : S Given statement Statement Visitor for the FindLoopStmtVisitor","title":"function VisitStmt"},{"location":"internal/doxygen/Classes/classFindLoopStmtVisitor/#function-getvarset","text":"1 inline std :: unordered_set < clang :: VarDecl * > * getVarSet ()","title":"function getVarSet"},{"location":"internal/doxygen/Classes/classFindLoopStmtVisitor/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classFindLoopStmtVisitor/#variable-finddeclrefvisitor","text":"1 FindDeclRefExprVisitor FindDeclRefVisitor ;","title":"variable FindDeclRefVisitor"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/","text":"FindPrivateVariablesVisitor #include <Visitors.h> Inherits from clang::RecursiveASTVisitor< FindPrivateVariablesVisitor > Public Functions Name FindPrivateVariablesVisitor (clang::SourceLocation TopSourceLocation, clang::SourceManager & SM) bool VisitExpr (clang::Expr * E) Visit function for Expressions. std::set< clang::VarDecl * > & getVarSet () Private Attributes Name clang::SourceManager & SM clang::SourceLocation RegionTopSourceLocation std::set< clang::VarDecl * > VarSet Public Functions Documentation function FindPrivateVariablesVisitor 1 2 3 4 inline FindPrivateVariablesVisitor ( clang :: SourceLocation TopSourceLocation , clang :: SourceManager & SM ) function VisitExpr 1 2 3 bool VisitExpr ( clang :: Expr * E ) Visit function for Expressions. Parameters : E Given expression Expression Visitor in FindPrivateVariablesVisitor function getVarSet 1 inline std :: set < clang :: VarDecl * > & getVarSet () Private Attributes Documentation variable SM 1 clang :: SourceManager & SM ; variable RegionTopSourceLocation 1 clang :: SourceLocation RegionTopSourceLocation ; variable VarSet 1 std :: set < clang :: VarDecl * > VarSet ;","title":"FindPrivateVariablesVisitor"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#findprivatevariablesvisitor","text":"#include <Visitors.h> Inherits from clang::RecursiveASTVisitor< FindPrivateVariablesVisitor >","title":"FindPrivateVariablesVisitor"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#public-functions","text":"Name FindPrivateVariablesVisitor (clang::SourceLocation TopSourceLocation, clang::SourceManager & SM) bool VisitExpr (clang::Expr * E) Visit function for Expressions. std::set< clang::VarDecl * > & getVarSet ()","title":"Public Functions"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#private-attributes","text":"Name clang::SourceManager & SM clang::SourceLocation RegionTopSourceLocation std::set< clang::VarDecl * > VarSet","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#function-findprivatevariablesvisitor","text":"1 2 3 4 inline FindPrivateVariablesVisitor ( clang :: SourceLocation TopSourceLocation , clang :: SourceManager & SM )","title":"function FindPrivateVariablesVisitor"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#function-visitexpr","text":"1 2 3 bool VisitExpr ( clang :: Expr * E ) Visit function for Expressions. Parameters : E Given expression Expression Visitor in FindPrivateVariablesVisitor","title":"function VisitExpr"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#function-getvarset","text":"1 inline std :: set < clang :: VarDecl * > & getVarSet ()","title":"function getVarSet"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#variable-sm","text":"1 clang :: SourceManager & SM ;","title":"variable SM"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#variable-regiontopsourcelocation","text":"1 clang :: SourceLocation RegionTopSourceLocation ;","title":"variable RegionTopSourceLocation"},{"location":"internal/doxygen/Classes/classFindPrivateVariablesVisitor/#variable-varset","text":"1 std :: set < clang :: VarDecl * > VarSet ;","title":"variable VarSet"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/","text":"FindTargetCodeVisitor Traverses the AST to find target and process target regions and function and variables that are annotated by an 'omp declare target' target pragma. #include <Visitors.h> Inherits from clang::RecursiveASTVisitor< FindTargetCodeVisitor > Public Functions Name FindTargetCodeVisitor ( TargetCode & Code, TypeDeclResolver & Types, FunctionDeclResolver & Functions, clang::ASTContext & Context) bool TraverseDecl (clang::Decl * D) Traverse declarations. bool VisitStmt (clang::Stmt * S) Visit function for statements. bool VisitDecl (clang::Decl * D) Visit function for declarations. Private Functions Name bool processTargetRegion (clang::OMPExecutableDirective * TargetDirective) Extracts the necessary information about the target region from the AST, such as captured variables and relevant OpenMP clauses, and adds an TargetCodeRegion to the TargetCode instance. void addTargetRegionArgs (clang::CapturedStmt * S, clang::OMPExecutableDirective * TargetDirective, std::shared_ptr< TargetCodeRegion > TCR) Finds and adds all variables required by the target regions as arguments to the generated function. Private Attributes Name clang::ASTContext & Context TargetCode & TargetCodeInfo The collection where target regions and other code is added to. DiscoverTypesInDeclVisitor DiscoverTypeVisitor A Visitor to find references to the types required by the target code. DiscoverFunctionsInDeclVisitor DiscoverFunctionVisitor A Visitor to find references to all functions required by the target code. FunctionDeclResolver & Functions Collection of all functions referenced and required by target code (and referenced by other required functions). FindDeclRefExprVisitor FindDeclRefVisitor std::stack< clang::FunctionDecl * > LastVisitedFuncDecl The last function the visitor traversed. std::unordered_set< std::string > FuncDeclWithoutBody Function with 'omp declare target' pragma, for which the visitor has not yet found a body. Public Functions Documentation function FindTargetCodeVisitor 1 2 3 4 5 6 inline FindTargetCodeVisitor ( TargetCode & Code , TypeDeclResolver & Types , FunctionDeclResolver & Functions , clang :: ASTContext & Context ) function TraverseDecl 1 2 3 bool TraverseDecl ( clang :: Decl * D ) Traverse declarations. Parameters : D Declaration to traverse Return : true While traversing false If NULL function VisitStmt 1 2 3 bool VisitStmt ( clang :: Stmt * S ) Visit function for statements. Parameters : S Given statement Statement visitor in the FindTargetCodeVisitor . function VisitDecl 1 2 3 bool VisitDecl ( clang :: Decl * D ) Visit function for declarations. Parameters : D Given declaration Declaration Visitor in the FindTargetCodeVisitor Private Functions Documentation function processTargetRegion 1 2 3 bool processTargetRegion ( clang :: OMPExecutableDirective * TargetDirective ) Extracts the necessary information about the target region from the AST, such as captured variables and relevant OpenMP clauses, and adds an TargetCodeRegion to the TargetCode instance. Parameters : TargetDirective Target directive Process the target region. function addTargetRegionArgs 1 2 3 4 5 void addTargetRegionArgs ( clang :: CapturedStmt * S , clang :: OMPExecutableDirective * TargetDirective , std :: shared_ptr < TargetCodeRegion > TCR ) Finds and adds all variables required by the target regions as arguments to the generated function. Parameters : S TargetDirective TCR Add target region arguments. Private Attributes Documentation variable Context 1 clang :: ASTContext & Context ; variable TargetCodeInfo 1 TargetCode & TargetCodeInfo ; The collection where target regions and other code is added to. variable DiscoverTypeVisitor 1 DiscoverTypesInDeclVisitor DiscoverTypeVisitor ; A Visitor to find references to the types required by the target code. variable DiscoverFunctionVisitor 1 DiscoverFunctionsInDeclVisitor DiscoverFunctionVisitor ; A Visitor to find references to all functions required by the target code. variable Functions 1 FunctionDeclResolver & Functions ; Collection of all functions referenced and required by target code (and referenced by other required functions). variable FindDeclRefVisitor 1 FindDeclRefExprVisitor FindDeclRefVisitor ; variable LastVisitedFuncDecl 1 std :: stack < clang :: FunctionDecl * > LastVisitedFuncDecl ; The last function the visitor traversed. This is stored to be able to later compute the function name for the target region. variable FuncDeclWithoutBody 1 std :: unordered_set < std :: string > FuncDeclWithoutBody ; Function with 'omp declare target' pragma, for which the visitor has not yet found a body.","title":"FindTargetCodeVisitor"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#findtargetcodevisitor","text":"Traverses the AST to find target and process target regions and function and variables that are annotated by an 'omp declare target' target pragma. #include <Visitors.h> Inherits from clang::RecursiveASTVisitor< FindTargetCodeVisitor >","title":"FindTargetCodeVisitor"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#public-functions","text":"Name FindTargetCodeVisitor ( TargetCode & Code, TypeDeclResolver & Types, FunctionDeclResolver & Functions, clang::ASTContext & Context) bool TraverseDecl (clang::Decl * D) Traverse declarations. bool VisitStmt (clang::Stmt * S) Visit function for statements. bool VisitDecl (clang::Decl * D) Visit function for declarations.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#private-functions","text":"Name bool processTargetRegion (clang::OMPExecutableDirective * TargetDirective) Extracts the necessary information about the target region from the AST, such as captured variables and relevant OpenMP clauses, and adds an TargetCodeRegion to the TargetCode instance. void addTargetRegionArgs (clang::CapturedStmt * S, clang::OMPExecutableDirective * TargetDirective, std::shared_ptr< TargetCodeRegion > TCR) Finds and adds all variables required by the target regions as arguments to the generated function.","title":"Private Functions"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#private-attributes","text":"Name clang::ASTContext & Context TargetCode & TargetCodeInfo The collection where target regions and other code is added to. DiscoverTypesInDeclVisitor DiscoverTypeVisitor A Visitor to find references to the types required by the target code. DiscoverFunctionsInDeclVisitor DiscoverFunctionVisitor A Visitor to find references to all functions required by the target code. FunctionDeclResolver & Functions Collection of all functions referenced and required by target code (and referenced by other required functions). FindDeclRefExprVisitor FindDeclRefVisitor std::stack< clang::FunctionDecl * > LastVisitedFuncDecl The last function the visitor traversed. std::unordered_set< std::string > FuncDeclWithoutBody Function with 'omp declare target' pragma, for which the visitor has not yet found a body.","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#function-findtargetcodevisitor","text":"1 2 3 4 5 6 inline FindTargetCodeVisitor ( TargetCode & Code , TypeDeclResolver & Types , FunctionDeclResolver & Functions , clang :: ASTContext & Context )","title":"function FindTargetCodeVisitor"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#function-traversedecl","text":"1 2 3 bool TraverseDecl ( clang :: Decl * D ) Traverse declarations. Parameters : D Declaration to traverse Return : true While traversing false If NULL","title":"function TraverseDecl"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#function-visitstmt","text":"1 2 3 bool VisitStmt ( clang :: Stmt * S ) Visit function for statements. Parameters : S Given statement Statement visitor in the FindTargetCodeVisitor .","title":"function VisitStmt"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#function-visitdecl","text":"1 2 3 bool VisitDecl ( clang :: Decl * D ) Visit function for declarations. Parameters : D Given declaration Declaration Visitor in the FindTargetCodeVisitor","title":"function VisitDecl"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#private-functions-documentation","text":"","title":"Private Functions Documentation"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#function-processtargetregion","text":"1 2 3 bool processTargetRegion ( clang :: OMPExecutableDirective * TargetDirective ) Extracts the necessary information about the target region from the AST, such as captured variables and relevant OpenMP clauses, and adds an TargetCodeRegion to the TargetCode instance. Parameters : TargetDirective Target directive Process the target region.","title":"function processTargetRegion"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#function-addtargetregionargs","text":"1 2 3 4 5 void addTargetRegionArgs ( clang :: CapturedStmt * S , clang :: OMPExecutableDirective * TargetDirective , std :: shared_ptr < TargetCodeRegion > TCR ) Finds and adds all variables required by the target regions as arguments to the generated function. Parameters : S TargetDirective TCR Add target region arguments.","title":"function addTargetRegionArgs"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#variable-context","text":"1 clang :: ASTContext & Context ;","title":"variable Context"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#variable-targetcodeinfo","text":"1 TargetCode & TargetCodeInfo ; The collection where target regions and other code is added to.","title":"variable TargetCodeInfo"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#variable-discovertypevisitor","text":"1 DiscoverTypesInDeclVisitor DiscoverTypeVisitor ; A Visitor to find references to the types required by the target code.","title":"variable DiscoverTypeVisitor"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#variable-discoverfunctionvisitor","text":"1 DiscoverFunctionsInDeclVisitor DiscoverFunctionVisitor ; A Visitor to find references to all functions required by the target code.","title":"variable DiscoverFunctionVisitor"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#variable-functions","text":"1 FunctionDeclResolver & Functions ; Collection of all functions referenced and required by target code (and referenced by other required functions).","title":"variable Functions"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#variable-finddeclrefvisitor","text":"1 FindDeclRefExprVisitor FindDeclRefVisitor ;","title":"variable FindDeclRefVisitor"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#variable-lastvisitedfuncdecl","text":"1 std :: stack < clang :: FunctionDecl * > LastVisitedFuncDecl ; The last function the visitor traversed. This is stored to be able to later compute the function name for the target region.","title":"variable LastVisitedFuncDecl"},{"location":"internal/doxygen/Classes/classFindTargetCodeVisitor/#variable-funcdeclwithoutbody","text":"1 std :: unordered_set < std :: string > FuncDeclWithoutBody ; Function with 'omp declare target' pragma, for which the visitor has not yet found a body.","title":"variable FuncDeclWithoutBody"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/","text":"FunctionDeclResolver Implements DeclResolver for functions used in target regions. More... #include <DeclResolver.h> Inherits from DeclResolver Public Functions Name FunctionDeclResolver ( TypeDeclResolver & Types) Private Functions Name virtual void runOwnVisitor (clang::Decl * D, std::function< void(clang::Decl *Dep)> Fn) override With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. virtual void findDependDecls (clang::Decl * D, std::unordered_set< clang::Decl * > & UnresolvedDecls) override Overrides DeclResolver::findDependDecls to also find types required by this function. Private Attributes Name TypeDeclResolver & Types Additional inherited members Public Functions inherited from DeclResolver Name virtual ~DeclResolver () =0 void addDecl (clang::Decl * D) Records a Decl and automatically adds all Decls that this Decl depends on. void orderAndAddFragments ( TargetCode & TC) Creates a TargetCodeFragment for each recorded Decl and adds them to the TargetCode object in the correct order. Private Functions inherited from DeclResolver Name void topoSort (std::stack< clang::Decl * > & q) This functions does a topological sorting on the dependency graph of all Decls recorded into this object by calling addDecl . void topoSortUtil (std::stack< clang::Decl * > & q, std::map< clang::Decl *, bool > & visited, clang::Decl * D) Helper function for topoSort , to do an recursive DFS. Private Attributes inherited from DeclResolver Name DeclMap AllDecls Records all declarations added to the resolver. std::set< clang::Decl * > NonDependentDecls All declarations which do not depend on other declarations. std::set< std::string > RequiredSystemHeaders When a declaration is inside a system header, that header is recorded here instead of the declaratoin. Detailed Description 1 class FunctionDeclResolver ; Implements DeclResolver for functions used in target regions. Does also search for additional types in the functions found and adds them to a TypeDeclResolver instance. Public Functions Documentation function FunctionDeclResolver 1 2 3 inline FunctionDeclResolver ( TypeDeclResolver & Types ) Private Functions Documentation function runOwnVisitor 1 2 3 4 virtual void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) override With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. Reimplements : DeclResolver::runOwnVisitor function findDependDecls 1 2 3 4 virtual void findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl * > & UnresolvedDecls ) override Overrides DeclResolver::findDependDecls to also find types required by this function. Reimplements : DeclResolver::findDependDecls Private Attributes Documentation variable Types 1 TypeDeclResolver & Types ;","title":"FunctionDeclResolver"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#functiondeclresolver","text":"Implements DeclResolver for functions used in target regions. More... #include <DeclResolver.h> Inherits from DeclResolver","title":"FunctionDeclResolver"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#public-functions","text":"Name FunctionDeclResolver ( TypeDeclResolver & Types)","title":"Public Functions"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#private-functions","text":"Name virtual void runOwnVisitor (clang::Decl * D, std::function< void(clang::Decl *Dep)> Fn) override With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. virtual void findDependDecls (clang::Decl * D, std::unordered_set< clang::Decl * > & UnresolvedDecls) override Overrides DeclResolver::findDependDecls to also find types required by this function.","title":"Private Functions"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#private-attributes","text":"Name TypeDeclResolver & Types","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#additional-inherited-members","text":"Public Functions inherited from DeclResolver Name virtual ~DeclResolver () =0 void addDecl (clang::Decl * D) Records a Decl and automatically adds all Decls that this Decl depends on. void orderAndAddFragments ( TargetCode & TC) Creates a TargetCodeFragment for each recorded Decl and adds them to the TargetCode object in the correct order. Private Functions inherited from DeclResolver Name void topoSort (std::stack< clang::Decl * > & q) This functions does a topological sorting on the dependency graph of all Decls recorded into this object by calling addDecl . void topoSortUtil (std::stack< clang::Decl * > & q, std::map< clang::Decl *, bool > & visited, clang::Decl * D) Helper function for topoSort , to do an recursive DFS. Private Attributes inherited from DeclResolver Name DeclMap AllDecls Records all declarations added to the resolver. std::set< clang::Decl * > NonDependentDecls All declarations which do not depend on other declarations. std::set< std::string > RequiredSystemHeaders When a declaration is inside a system header, that header is recorded here instead of the declaratoin.","title":"Additional inherited members"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#detailed-description","text":"1 class FunctionDeclResolver ; Implements DeclResolver for functions used in target regions. Does also search for additional types in the functions found and adds them to a TypeDeclResolver instance.","title":"Detailed Description"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#function-functiondeclresolver","text":"1 2 3 inline FunctionDeclResolver ( TypeDeclResolver & Types )","title":"function FunctionDeclResolver"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#private-functions-documentation","text":"","title":"Private Functions Documentation"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#function-runownvisitor","text":"1 2 3 4 virtual void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) override With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. Reimplements : DeclResolver::runOwnVisitor","title":"function runOwnVisitor"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#function-finddependdecls","text":"1 2 3 4 virtual void findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl * > & UnresolvedDecls ) override Overrides DeclResolver::findDependDecls to also find types required by this function. Reimplements : DeclResolver::findDependDecls","title":"function findDependDecls"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classFunctionDeclResolver/#variable-types","text":"1 TypeDeclResolver & Types ;","title":"variable Types"},{"location":"internal/doxygen/Classes/classOmpPragma/","text":"OmpPragma A helper class to rewrite some \"pragma omp\" (mostly teams and similar combined constructs), which are not supported by sotoc. More... #include <OmpPragma.h> Public Functions Name OmpPragma ( TargetCodeRegion * TCR) OmpPragma (clang::OMPExecutableDirective * Directive, clang::PrintingPolicy PP) bool needsStructuredBlock () Returns true if the omp pragma encapsulated, needs to be followed by a structured block (i.e. void printReplacement (llvm::raw_ostream & Out) Prints a replacement omp pragma for the encapsulated pragma onto Out . void printAddition (llvm::raw_ostream & Out) bool isReplaceable (clang::OMPExecutableDirective * Directive) Determines whether a pragma is replacable. bool needsAdditionalPragma (clang::OMPExecutableDirective * Directive) Determines whether a additional pragma is needed. Private Functions Name bool isClausePrintable (clang::OMPClause * Clause) Determine whether a clause is printable. void rewriteParam (std::string * In) Rewrite clause parameters. void printClauses (llvm::raw_ostream & Out) Print OMP Clauses. Private Attributes Name clang::PrintingPolicy PP llvm::ArrayRef< clang::OMPClause * > Clauses clang::OpenMPDirectiveKind Kind unsigned int ClauseParamCounter Detailed Description 1 class OmpPragma ; A helper class to rewrite some \"pragma omp\" (mostly teams and similar combined constructs), which are not supported by sotoc. We currently only support one team to be run on the target because ncc does not support 'freestanding' teams. So we need to remove teams and distribute constructs from the generated target code. But teams constructs can also appear in combined constructs. These combined constructs cannot simply be removed, they must be replace by \"non-team\" equivalents to preserve correctness. This class provides helper functions that finds a suitable replacement for omp pragmas that contain teams constructs. It is used during code generation: The omp pragma of each target region that is declared as part of a combined construct and each pragma found during pretty printing is encapsulated by an object of this class which is then used to generate a replacement. Public Functions Documentation function OmpPragma 1 2 3 inline OmpPragma ( TargetCodeRegion * TCR ) function OmpPragma 1 2 3 4 inline OmpPragma ( clang :: OMPExecutableDirective * Directive , clang :: PrintingPolicy PP ) function needsStructuredBlock 1 bool needsStructuredBlock () Returns true if the omp pragma encapsulated, needs to be followed by a structured block (i.e. Return : true If a structured block is needed false If no structured block is needed Determines whether a structured block is needed for a pragma. {...}). function printReplacement 1 2 3 void printReplacement ( llvm :: raw_ostream & Out ) Prints a replacement omp pragma for the encapsulated pragma onto Out . Parameters : Out Out stream Print replacement pragmas. In some cases we have to modify the printed pragma. If we have a combined constructs with target, remove target because we are already running on the target device. If we have a combined construct with teams, remove teams because the runtime can decide to spawn only a single team. If we have a simd, we prepend #pragma _NEC ivdep to indicate no dependencies. function printAddition 1 2 3 void printAddition ( llvm :: raw_ostream & Out ) function isReplaceable 1 2 3 static bool isReplaceable ( clang :: OMPExecutableDirective * Directive ) Determines whether a pragma is replacable. Parameters : Directive Given Directive Return : true If the directive is replacable false If the directive is not replacable function needsAdditionalPragma 1 2 3 static bool needsAdditionalPragma ( clang :: OMPExecutableDirective * Directive ) Determines whether a additional pragma is needed. Parameters : Directive given directive Return : true Directive needs an additional pragma false Directive does not need an additional pragma Private Functions Documentation function isClausePrintable 1 2 3 bool isClausePrintable ( clang :: OMPClause * Clause ) Determine whether a clause is printable. Parameters : Clause Clause to check Return : true If the clause is printable false If the clause is not printable Checks for a clause the clause kind and determines which clauses are printable. function rewriteParam 1 2 3 void rewriteParam ( std :: string * In ) Rewrite clause parameters. Parameters : In Parameter as string (everything in brackets) Rewrites OMP clause parameters if they are variables to replace the variable name with the one we will use as the function argument. function printClauses 1 2 3 void printClauses ( llvm :: raw_ostream & Out ) Print OMP Clauses. Parameters : Out Out stream Private Attributes Documentation variable PP 1 clang :: PrintingPolicy PP ; variable Clauses 1 llvm :: ArrayRef < clang :: OMPClause * > Clauses ; variable Kind 1 clang :: OpenMPDirectiveKind Kind ; variable ClauseParamCounter 1 unsigned int ClauseParamCounter ;","title":"OmpPragma"},{"location":"internal/doxygen/Classes/classOmpPragma/#omppragma","text":"A helper class to rewrite some \"pragma omp\" (mostly teams and similar combined constructs), which are not supported by sotoc. More... #include <OmpPragma.h>","title":"OmpPragma"},{"location":"internal/doxygen/Classes/classOmpPragma/#public-functions","text":"Name OmpPragma ( TargetCodeRegion * TCR) OmpPragma (clang::OMPExecutableDirective * Directive, clang::PrintingPolicy PP) bool needsStructuredBlock () Returns true if the omp pragma encapsulated, needs to be followed by a structured block (i.e. void printReplacement (llvm::raw_ostream & Out) Prints a replacement omp pragma for the encapsulated pragma onto Out . void printAddition (llvm::raw_ostream & Out) bool isReplaceable (clang::OMPExecutableDirective * Directive) Determines whether a pragma is replacable. bool needsAdditionalPragma (clang::OMPExecutableDirective * Directive) Determines whether a additional pragma is needed.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classOmpPragma/#private-functions","text":"Name bool isClausePrintable (clang::OMPClause * Clause) Determine whether a clause is printable. void rewriteParam (std::string * In) Rewrite clause parameters. void printClauses (llvm::raw_ostream & Out) Print OMP Clauses.","title":"Private Functions"},{"location":"internal/doxygen/Classes/classOmpPragma/#private-attributes","text":"Name clang::PrintingPolicy PP llvm::ArrayRef< clang::OMPClause * > Clauses clang::OpenMPDirectiveKind Kind unsigned int ClauseParamCounter","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classOmpPragma/#detailed-description","text":"1 class OmpPragma ; A helper class to rewrite some \"pragma omp\" (mostly teams and similar combined constructs), which are not supported by sotoc. We currently only support one team to be run on the target because ncc does not support 'freestanding' teams. So we need to remove teams and distribute constructs from the generated target code. But teams constructs can also appear in combined constructs. These combined constructs cannot simply be removed, they must be replace by \"non-team\" equivalents to preserve correctness. This class provides helper functions that finds a suitable replacement for omp pragmas that contain teams constructs. It is used during code generation: The omp pragma of each target region that is declared as part of a combined construct and each pragma found during pretty printing is encapsulated by an object of this class which is then used to generate a replacement.","title":"Detailed Description"},{"location":"internal/doxygen/Classes/classOmpPragma/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classOmpPragma/#function-omppragma","text":"1 2 3 inline OmpPragma ( TargetCodeRegion * TCR )","title":"function OmpPragma"},{"location":"internal/doxygen/Classes/classOmpPragma/#function-omppragma_1","text":"1 2 3 4 inline OmpPragma ( clang :: OMPExecutableDirective * Directive , clang :: PrintingPolicy PP )","title":"function OmpPragma"},{"location":"internal/doxygen/Classes/classOmpPragma/#function-needsstructuredblock","text":"1 bool needsStructuredBlock () Returns true if the omp pragma encapsulated, needs to be followed by a structured block (i.e. Return : true If a structured block is needed false If no structured block is needed Determines whether a structured block is needed for a pragma. {...}).","title":"function needsStructuredBlock"},{"location":"internal/doxygen/Classes/classOmpPragma/#function-printreplacement","text":"1 2 3 void printReplacement ( llvm :: raw_ostream & Out ) Prints a replacement omp pragma for the encapsulated pragma onto Out . Parameters : Out Out stream Print replacement pragmas. In some cases we have to modify the printed pragma. If we have a combined constructs with target, remove target because we are already running on the target device. If we have a combined construct with teams, remove teams because the runtime can decide to spawn only a single team. If we have a simd, we prepend #pragma _NEC ivdep to indicate no dependencies.","title":"function printReplacement"},{"location":"internal/doxygen/Classes/classOmpPragma/#function-printaddition","text":"1 2 3 void printAddition ( llvm :: raw_ostream & Out )","title":"function printAddition"},{"location":"internal/doxygen/Classes/classOmpPragma/#function-isreplaceable","text":"1 2 3 static bool isReplaceable ( clang :: OMPExecutableDirective * Directive ) Determines whether a pragma is replacable. Parameters : Directive Given Directive Return : true If the directive is replacable false If the directive is not replacable","title":"function isReplaceable"},{"location":"internal/doxygen/Classes/classOmpPragma/#function-needsadditionalpragma","text":"1 2 3 static bool needsAdditionalPragma ( clang :: OMPExecutableDirective * Directive ) Determines whether a additional pragma is needed. Parameters : Directive given directive Return : true Directive needs an additional pragma false Directive does not need an additional pragma","title":"function needsAdditionalPragma"},{"location":"internal/doxygen/Classes/classOmpPragma/#private-functions-documentation","text":"","title":"Private Functions Documentation"},{"location":"internal/doxygen/Classes/classOmpPragma/#function-isclauseprintable","text":"1 2 3 bool isClausePrintable ( clang :: OMPClause * Clause ) Determine whether a clause is printable. Parameters : Clause Clause to check Return : true If the clause is printable false If the clause is not printable Checks for a clause the clause kind and determines which clauses are printable.","title":"function isClausePrintable"},{"location":"internal/doxygen/Classes/classOmpPragma/#function-rewriteparam","text":"1 2 3 void rewriteParam ( std :: string * In ) Rewrite clause parameters. Parameters : In Parameter as string (everything in brackets) Rewrites OMP clause parameters if they are variables to replace the variable name with the one we will use as the function argument.","title":"function rewriteParam"},{"location":"internal/doxygen/Classes/classOmpPragma/#function-printclauses","text":"1 2 3 void printClauses ( llvm :: raw_ostream & Out ) Print OMP Clauses. Parameters : Out Out stream","title":"function printClauses"},{"location":"internal/doxygen/Classes/classOmpPragma/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classOmpPragma/#variable-pp","text":"1 clang :: PrintingPolicy PP ;","title":"variable PP"},{"location":"internal/doxygen/Classes/classOmpPragma/#variable-clauses","text":"1 llvm :: ArrayRef < clang :: OMPClause * > Clauses ;","title":"variable Clauses"},{"location":"internal/doxygen/Classes/classOmpPragma/#variable-kind","text":"1 clang :: OpenMPDirectiveKind Kind ;","title":"variable Kind"},{"location":"internal/doxygen/Classes/classOmpPragma/#variable-clauseparamcounter","text":"1 unsigned int ClauseParamCounter ;","title":"variable ClauseParamCounter"},{"location":"internal/doxygen/Classes/classSourceTransformAction/","text":"SourceTransformAction Inherits from ASTFrontendAction Public Functions Name void EndSourceFileAction () override std::unique_ptr< clang::ASTConsumer > CreateASTConsumer (clang::CompilerInstance & CI, clang::StringRef ) Private Attributes Name clang::Rewriter TargetCodeRewriter TargetCode * Code Public Functions Documentation function EndSourceFileAction 1 inline void EndSourceFileAction () override function CreateASTConsumer 1 2 3 4 inline std :: unique_ptr < clang :: ASTConsumer > CreateASTConsumer ( clang :: CompilerInstance & CI , clang :: StringRef ) Private Attributes Documentation variable TargetCodeRewriter 1 clang :: Rewriter TargetCodeRewriter ; variable Code 1 TargetCode * Code ;","title":"SourceTransformAction"},{"location":"internal/doxygen/Classes/classSourceTransformAction/#sourcetransformaction","text":"Inherits from ASTFrontendAction","title":"SourceTransformAction"},{"location":"internal/doxygen/Classes/classSourceTransformAction/#public-functions","text":"Name void EndSourceFileAction () override std::unique_ptr< clang::ASTConsumer > CreateASTConsumer (clang::CompilerInstance & CI, clang::StringRef )","title":"Public Functions"},{"location":"internal/doxygen/Classes/classSourceTransformAction/#private-attributes","text":"Name clang::Rewriter TargetCodeRewriter TargetCode * Code","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classSourceTransformAction/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classSourceTransformAction/#function-endsourcefileaction","text":"1 inline void EndSourceFileAction () override","title":"function EndSourceFileAction"},{"location":"internal/doxygen/Classes/classSourceTransformAction/#function-createastconsumer","text":"1 2 3 4 inline std :: unique_ptr < clang :: ASTConsumer > CreateASTConsumer ( clang :: CompilerInstance & CI , clang :: StringRef )","title":"function CreateASTConsumer"},{"location":"internal/doxygen/Classes/classSourceTransformAction/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classSourceTransformAction/#variable-targetcoderewriter","text":"1 clang :: Rewriter TargetCodeRewriter ;","title":"variable TargetCodeRewriter"},{"location":"internal/doxygen/Classes/classSourceTransformAction/#variable-code","text":"1 TargetCode * Code ;","title":"variable Code"},{"location":"internal/doxygen/Classes/classTargetCode/","text":"TargetCode A collection of all code from the input file that needs to be copied to the target source file. #include <TargetCode.h> Public Functions Name TargetCode (clang::Rewriter & TargetCodeRewriter) bool addCodeFragment (std::shared_ptr< TargetCodeFragment > Frag, bool PushFront =false) Add a piece of code from the input file to this collection. bool addCodeFragmentFront (std::shared_ptr< TargetCodeFragment > Fag) See addCodeFragment . void generateCode (llvm::raw_ostream & Out) Generate target code from all fragments and system headers added to this collection. TargetCodeFragmentDeque::const_iterator getCodeFragmentsBegin () Get an iterate over all code fragments in this collection. TargetCodeFragmentDeque::const_iterator getCodeFragmentsEnd () See getCodeFragmentsBegin . void addHeader (const std::string & Header) Add a header file to be included by the target code. Private Functions Name void generateVariableDecl (const TargetRegionVariable & Var, llvm::raw_ostream & Out) Generate the variable declaration of a transferred variable. void generateFunctionPrologue ( TargetCodeRegion * TCR, llvm::raw_ostream & Out) Generates a function prologue for a target region. void generateFunctionEpilogue ( TargetCodeRegion * TCR, llvm::raw_ostream & Out) Generates a function epilogue for a target region. std::string generateFunctionName ( TargetCodeRegion * TCR) Generate a function name for a target region. void generateArgument (const TargetRegionVariable & Aarg, llvm::raw_ostream & Out) Generate function arguments. Private Attributes Name TargetCodeFragmentDeque CodeFragments Collection of all code locations that need to be copied. std::set< std::string > SystemHeaders Header files which will also be present on the target. clang::Rewriter & TargetCodeRewriter clang::SourceManager & SM Public Functions Documentation function TargetCode 1 2 3 inline TargetCode ( clang :: Rewriter & TargetCodeRewriter ) function addCodeFragment 1 2 3 4 bool addCodeFragment ( std :: shared_ptr < TargetCodeFragment > Frag , bool PushFront = false ) Add a piece of code from the input file to this collection. Parameters : Frag Target code fragment to add PushFront Whether to push it to the front or the back Adds a code fragment. This function uses the fragments source location to check wether it was already added and where in the list of code fragments to add it. Adds a TargetCodeFragment to Target Code function addCodeFragmentFront 1 2 3 bool addCodeFragmentFront ( std :: shared_ptr < TargetCodeFragment > Fag ) See addCodeFragment . function generateCode 1 2 3 void generateCode ( llvm :: raw_ostream & Out ) Generate target code from all fragments and system headers added to this collection. Parameters : Out Out stream Generate target code. Generates the actual target code function getCodeFragmentsBegin 1 inline TargetCodeFragmentDeque :: const_iterator getCodeFragmentsBegin () Get an iterate over all code fragments in this collection. function getCodeFragmentsEnd 1 inline TargetCodeFragmentDeque :: const_iterator getCodeFragmentsEnd () See getCodeFragmentsBegin . function addHeader 1 2 3 inline void addHeader ( const std :: string & Header ) Add a header file to be included by the target code. Private Functions Documentation function generateVariableDecl 1 2 3 4 void generateVariableDecl ( const TargetRegionVariable & Var , llvm :: raw_ostream & Out ) Generate the variable declaration of a transferred variable. Parameters : Var The variable for which to print the declaration Out The output stream to which to write the variable declaration Generate the variable declaration (including setting the variable to the proper value) of a transferred variable and print it to the specified output stream. function generateFunctionPrologue 1 2 3 4 void generateFunctionPrologue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ) Generates a function prologue for a target region. Parameters : TCR Code region Out Out stream Generate function prologue. This prologue consists of a function declaration and code to copy local variables into scope. Generates everything that comes before the actual target code, like the function head, local variables and helper functions. function generateFunctionEpilogue 1 2 3 4 void generateFunctionEpilogue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ) Generates a function epilogue for a target region. Parameters : TCR Target code Out Out stream Generate function epilogue. This prologue consists of a code to copy variables from the local scope back. Generates everything that comes after the actual target code, like '}' and scalar copies. function generateFunctionName 1 2 3 std :: string generateFunctionName ( TargetCodeRegion * TCR ) Generate a function name for a target region. Parameters : TCR Target code region Return : std::string Function name Generates function name. function generateArgument 1 2 3 4 void generateArgument ( const TargetRegionVariable & Aarg , llvm :: raw_ostream & Out ) Generate function arguments. Parameters : Arg Argument Out Out stream Generates the argument list for the target function. Private Attributes Documentation variable CodeFragments 1 TargetCodeFragmentDeque CodeFragments ; Collection of all code locations that need to be copied. variable SystemHeaders 1 std :: set < std :: string > SystemHeaders ; Header files which will also be present on the target. Instead of copying the code declarations in them, we can simply add #include directives for these headers to the target code. variable TargetCodeRewriter 1 clang :: Rewriter & TargetCodeRewriter ; variable SM 1 clang :: SourceManager & SM ;","title":"TargetCode"},{"location":"internal/doxygen/Classes/classTargetCode/#targetcode","text":"A collection of all code from the input file that needs to be copied to the target source file. #include <TargetCode.h>","title":"TargetCode"},{"location":"internal/doxygen/Classes/classTargetCode/#public-functions","text":"Name TargetCode (clang::Rewriter & TargetCodeRewriter) bool addCodeFragment (std::shared_ptr< TargetCodeFragment > Frag, bool PushFront =false) Add a piece of code from the input file to this collection. bool addCodeFragmentFront (std::shared_ptr< TargetCodeFragment > Fag) See addCodeFragment . void generateCode (llvm::raw_ostream & Out) Generate target code from all fragments and system headers added to this collection. TargetCodeFragmentDeque::const_iterator getCodeFragmentsBegin () Get an iterate over all code fragments in this collection. TargetCodeFragmentDeque::const_iterator getCodeFragmentsEnd () See getCodeFragmentsBegin . void addHeader (const std::string & Header) Add a header file to be included by the target code.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classTargetCode/#private-functions","text":"Name void generateVariableDecl (const TargetRegionVariable & Var, llvm::raw_ostream & Out) Generate the variable declaration of a transferred variable. void generateFunctionPrologue ( TargetCodeRegion * TCR, llvm::raw_ostream & Out) Generates a function prologue for a target region. void generateFunctionEpilogue ( TargetCodeRegion * TCR, llvm::raw_ostream & Out) Generates a function epilogue for a target region. std::string generateFunctionName ( TargetCodeRegion * TCR) Generate a function name for a target region. void generateArgument (const TargetRegionVariable & Aarg, llvm::raw_ostream & Out) Generate function arguments.","title":"Private Functions"},{"location":"internal/doxygen/Classes/classTargetCode/#private-attributes","text":"Name TargetCodeFragmentDeque CodeFragments Collection of all code locations that need to be copied. std::set< std::string > SystemHeaders Header files which will also be present on the target. clang::Rewriter & TargetCodeRewriter clang::SourceManager & SM","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classTargetCode/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetCode/#function-targetcode","text":"1 2 3 inline TargetCode ( clang :: Rewriter & TargetCodeRewriter )","title":"function TargetCode"},{"location":"internal/doxygen/Classes/classTargetCode/#function-addcodefragment","text":"1 2 3 4 bool addCodeFragment ( std :: shared_ptr < TargetCodeFragment > Frag , bool PushFront = false ) Add a piece of code from the input file to this collection. Parameters : Frag Target code fragment to add PushFront Whether to push it to the front or the back Adds a code fragment. This function uses the fragments source location to check wether it was already added and where in the list of code fragments to add it. Adds a TargetCodeFragment to Target Code","title":"function addCodeFragment"},{"location":"internal/doxygen/Classes/classTargetCode/#function-addcodefragmentfront","text":"1 2 3 bool addCodeFragmentFront ( std :: shared_ptr < TargetCodeFragment > Fag ) See addCodeFragment .","title":"function addCodeFragmentFront"},{"location":"internal/doxygen/Classes/classTargetCode/#function-generatecode","text":"1 2 3 void generateCode ( llvm :: raw_ostream & Out ) Generate target code from all fragments and system headers added to this collection. Parameters : Out Out stream Generate target code. Generates the actual target code","title":"function generateCode"},{"location":"internal/doxygen/Classes/classTargetCode/#function-getcodefragmentsbegin","text":"1 inline TargetCodeFragmentDeque :: const_iterator getCodeFragmentsBegin () Get an iterate over all code fragments in this collection.","title":"function getCodeFragmentsBegin"},{"location":"internal/doxygen/Classes/classTargetCode/#function-getcodefragmentsend","text":"1 inline TargetCodeFragmentDeque :: const_iterator getCodeFragmentsEnd () See getCodeFragmentsBegin .","title":"function getCodeFragmentsEnd"},{"location":"internal/doxygen/Classes/classTargetCode/#function-addheader","text":"1 2 3 inline void addHeader ( const std :: string & Header ) Add a header file to be included by the target code.","title":"function addHeader"},{"location":"internal/doxygen/Classes/classTargetCode/#private-functions-documentation","text":"","title":"Private Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetCode/#function-generatevariabledecl","text":"1 2 3 4 void generateVariableDecl ( const TargetRegionVariable & Var , llvm :: raw_ostream & Out ) Generate the variable declaration of a transferred variable. Parameters : Var The variable for which to print the declaration Out The output stream to which to write the variable declaration Generate the variable declaration (including setting the variable to the proper value) of a transferred variable and print it to the specified output stream.","title":"function generateVariableDecl"},{"location":"internal/doxygen/Classes/classTargetCode/#function-generatefunctionprologue","text":"1 2 3 4 void generateFunctionPrologue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ) Generates a function prologue for a target region. Parameters : TCR Code region Out Out stream Generate function prologue. This prologue consists of a function declaration and code to copy local variables into scope. Generates everything that comes before the actual target code, like the function head, local variables and helper functions.","title":"function generateFunctionPrologue"},{"location":"internal/doxygen/Classes/classTargetCode/#function-generatefunctionepilogue","text":"1 2 3 4 void generateFunctionEpilogue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ) Generates a function epilogue for a target region. Parameters : TCR Target code Out Out stream Generate function epilogue. This prologue consists of a code to copy variables from the local scope back. Generates everything that comes after the actual target code, like '}' and scalar copies.","title":"function generateFunctionEpilogue"},{"location":"internal/doxygen/Classes/classTargetCode/#function-generatefunctionname","text":"1 2 3 std :: string generateFunctionName ( TargetCodeRegion * TCR ) Generate a function name for a target region. Parameters : TCR Target code region Return : std::string Function name Generates function name.","title":"function generateFunctionName"},{"location":"internal/doxygen/Classes/classTargetCode/#function-generateargument","text":"1 2 3 4 void generateArgument ( const TargetRegionVariable & Aarg , llvm :: raw_ostream & Out ) Generate function arguments. Parameters : Arg Argument Out Out stream Generates the argument list for the target function.","title":"function generateArgument"},{"location":"internal/doxygen/Classes/classTargetCode/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetCode/#variable-codefragments","text":"1 TargetCodeFragmentDeque CodeFragments ; Collection of all code locations that need to be copied.","title":"variable CodeFragments"},{"location":"internal/doxygen/Classes/classTargetCode/#variable-systemheaders","text":"1 std :: set < std :: string > SystemHeaders ; Header files which will also be present on the target. Instead of copying the code declarations in them, we can simply add #include directives for these headers to the target code.","title":"variable SystemHeaders"},{"location":"internal/doxygen/Classes/classTargetCode/#variable-targetcoderewriter","text":"1 clang :: Rewriter & TargetCodeRewriter ;","title":"variable TargetCodeRewriter"},{"location":"internal/doxygen/Classes/classTargetCode/#variable-sm","text":"1 clang :: SourceManager & SM ;","title":"variable SM"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/","text":"TargetCodeDecl This class represents a declaration, i.e. More... #include <TargetCodeFragment.h> Inherits from TargetCodeFragment Public Functions Name bool classof (const TargetCodeFragment * TCF) TargetCodeDecl (clang::Decl * Node) virtual std::string PrintPretty () override Do pretty printing. virtual clang::SourceRange getRealRange () override Get source range. virtual clang::SourceRange getSpellingRange () override Get spelling range. Private Attributes Name clang::Decl * DeclNode The AST node for the declaration. Additional inherited members Public Types inherited from TargetCodeFragment Name enum TargetCodeFragmentKind { TCFK_TargetCodeFragment, TCFK_TargetCodeRegion, TCFK_TargetCodeDecl} Enum for LLVMs RTTI. Public Functions inherited from TargetCodeFragment Name TargetCodeFragmentKind getKind () const Accessor for LLVMs RTTI. TargetCodeFragment (clang::ASTContext & Context, TargetCodeFragmentKind Kind) virtual ~TargetCodeFragment () =0 Destroy the Target Code Fragment:: Target Code Fragment object. virtual clang::SourceRange getInnerRange () Gets the 'inner' source range. clang::OpenMPDirectiveKind getTargetCodeKind () Accessor to TargetCodeKind. const clang::LangOptions & GetLangOpts () Accessor to lang opts of the current context. clang::PrintingPolicy getPP () Public Attributes inherited from TargetCodeFragment Name bool NeedsSemicolon Does the source code generation need to add a semicolon to this fragment. clang::OpenMPDirectiveKind TargetCodeKind What kind of code are we copying. bool HasExtraBraces Protected Attributes inherited from TargetCodeFragment Name const TargetCodeFragmentKind Kind Variable for LLVMs RTTI. clang::ASTContext & Context clang::PrintingPolicy PP Detailed Description 1 class TargetCodeDecl ; This class represents a declaration, i.e. a function, global varialbe, or type declaration that need to be copied from the input source code to the generated source code. Public Functions Documentation function classof 1 2 3 static inline bool classof ( const TargetCodeFragment * TCF ) function TargetCodeDecl 1 2 3 inline TargetCodeDecl ( clang :: Decl * Node ) function PrintPretty 1 virtual std :: string PrintPretty () override Do pretty printing. Return : std::string Pretty output Reimplements : TargetCodeFragment::PrintPretty function getRealRange 1 virtual clang :: SourceRange getRealRange () override Get source range. Return : clang::SourceRange Reimplements : TargetCodeFragment::getRealRange function getSpellingRange 1 virtual clang :: SourceRange getSpellingRange () override Get spelling range. Return : clang::SourceRange Reimplements : TargetCodeFragment::getSpellingRange Private Attributes Documentation variable DeclNode 1 clang :: Decl * DeclNode ; The AST node for the declaration.","title":"TargetCodeDecl"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#targetcodedecl","text":"This class represents a declaration, i.e. More... #include <TargetCodeFragment.h> Inherits from TargetCodeFragment","title":"TargetCodeDecl"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#public-functions","text":"Name bool classof (const TargetCodeFragment * TCF) TargetCodeDecl (clang::Decl * Node) virtual std::string PrintPretty () override Do pretty printing. virtual clang::SourceRange getRealRange () override Get source range. virtual clang::SourceRange getSpellingRange () override Get spelling range.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#private-attributes","text":"Name clang::Decl * DeclNode The AST node for the declaration.","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#additional-inherited-members","text":"Public Types inherited from TargetCodeFragment Name enum TargetCodeFragmentKind { TCFK_TargetCodeFragment, TCFK_TargetCodeRegion, TCFK_TargetCodeDecl} Enum for LLVMs RTTI. Public Functions inherited from TargetCodeFragment Name TargetCodeFragmentKind getKind () const Accessor for LLVMs RTTI. TargetCodeFragment (clang::ASTContext & Context, TargetCodeFragmentKind Kind) virtual ~TargetCodeFragment () =0 Destroy the Target Code Fragment:: Target Code Fragment object. virtual clang::SourceRange getInnerRange () Gets the 'inner' source range. clang::OpenMPDirectiveKind getTargetCodeKind () Accessor to TargetCodeKind. const clang::LangOptions & GetLangOpts () Accessor to lang opts of the current context. clang::PrintingPolicy getPP () Public Attributes inherited from TargetCodeFragment Name bool NeedsSemicolon Does the source code generation need to add a semicolon to this fragment. clang::OpenMPDirectiveKind TargetCodeKind What kind of code are we copying. bool HasExtraBraces Protected Attributes inherited from TargetCodeFragment Name const TargetCodeFragmentKind Kind Variable for LLVMs RTTI. clang::ASTContext & Context clang::PrintingPolicy PP","title":"Additional inherited members"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#detailed-description","text":"1 class TargetCodeDecl ; This class represents a declaration, i.e. a function, global varialbe, or type declaration that need to be copied from the input source code to the generated source code.","title":"Detailed Description"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#function-classof","text":"1 2 3 static inline bool classof ( const TargetCodeFragment * TCF )","title":"function classof"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#function-targetcodedecl","text":"1 2 3 inline TargetCodeDecl ( clang :: Decl * Node )","title":"function TargetCodeDecl"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#function-printpretty","text":"1 virtual std :: string PrintPretty () override Do pretty printing. Return : std::string Pretty output Reimplements : TargetCodeFragment::PrintPretty","title":"function PrintPretty"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#function-getrealrange","text":"1 virtual clang :: SourceRange getRealRange () override Get source range. Return : clang::SourceRange Reimplements : TargetCodeFragment::getRealRange","title":"function getRealRange"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#function-getspellingrange","text":"1 virtual clang :: SourceRange getSpellingRange () override Get spelling range. Return : clang::SourceRange Reimplements : TargetCodeFragment::getSpellingRange","title":"function getSpellingRange"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetCodeDecl/#variable-declnode","text":"1 clang :: Decl * DeclNode ; The AST node for the declaration.","title":"variable DeclNode"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/","text":"TargetCodeFragment An abstract base class for all fragments of the original code (except header includes) that need to be copied to our generated source code. More... #include <TargetCodeFragment.h> Inherited by TargetCodeDecl , TargetCodeRegion Public Types Name enum TargetCodeFragmentKind { TCFK_TargetCodeFragment, TCFK_TargetCodeRegion, TCFK_TargetCodeDecl} Enum for LLVMs RTTI. Public Functions Name TargetCodeFragmentKind getKind () const Accessor for LLVMs RTTI. TargetCodeFragment (clang::ASTContext & Context, TargetCodeFragmentKind Kind) virtual ~TargetCodeFragment () =0 Destroy the Target Code Fragment:: Target Code Fragment object. virtual std::string PrintPretty () =0 Tries to use Clang's PrettyPrinter when possible (this is currently only for target regions). virtual clang::SourceRange getRealRange () =0 Get the source range of the fragment. virtual clang::SourceRange getInnerRange () Gets the 'inner' source range. virtual clang::SourceRange getSpellingRange () =0 Get the spelling source range. clang::OpenMPDirectiveKind getTargetCodeKind () Accessor to TargetCodeKind. const clang::LangOptions & GetLangOpts () Accessor to lang opts of the current context. clang::PrintingPolicy getPP () bool classof (const TargetCodeFragment * TCF) Public Attributes Name bool NeedsSemicolon Does the source code generation need to add a semicolon to this fragment. clang::OpenMPDirectiveKind TargetCodeKind What kind of code are we copying. bool HasExtraBraces Protected Attributes Name const TargetCodeFragmentKind Kind Variable for LLVMs RTTI. clang::ASTContext & Context clang::PrintingPolicy PP Detailed Description 1 class TargetCodeFragment ; An abstract base class for all fragments of the original code (except header includes) that need to be copied to our generated source code. This includes target regions as well as functions, global variables and types used by target regions (as far as we can detect that) as well as functions and variables that are flagged with the 'omp declare target' pragma. Public Types Documentation enum TargetCodeFragmentKind Enumerator Value Description TCFK_TargetCodeFragment TCFK_TargetCodeRegion TCFK_TargetCodeDecl Enum for LLVMs RTTI. Public Functions Documentation function getKind 1 inline TargetCodeFragmentKind getKind () const Accessor for LLVMs RTTI. function TargetCodeFragment 1 2 3 4 inline TargetCodeFragment ( clang :: ASTContext & Context , TargetCodeFragmentKind Kind ) function ~TargetCodeFragment 1 virtual ~ TargetCodeFragment () = 0 Destroy the Target Code Fragment:: Target Code Fragment object. function PrintPretty 1 virtual std :: string PrintPretty () = 0 Tries to use Clang's PrettyPrinter when possible (this is currently only for target regions). Reimplemented by : TargetCodeRegion::PrintPretty , TargetCodeDecl::PrintPretty function getRealRange 1 virtual clang :: SourceRange getRealRange () = 0 Get the source range of the fragment. Reimplemented by : TargetCodeRegion::getRealRange , TargetCodeDecl::getRealRange function getInnerRange 1 inline virtual clang :: SourceRange getInnerRange () Gets the 'inner' source range. Reimplemented by : TargetCodeRegion::getInnerRange This can differ for target regions from the source range. function getSpellingRange 1 virtual clang :: SourceRange getSpellingRange () = 0 Get the spelling source range. Reimplemented by : TargetCodeRegion::getSpellingRange , TargetCodeDecl::getSpellingRange That is the range without macro expansions. function getTargetCodeKind 1 inline clang :: OpenMPDirectiveKind getTargetCodeKind () Accessor to TargetCodeKind. function GetLangOpts 1 inline const clang :: LangOptions & GetLangOpts () Accessor to lang opts of the current context. function getPP 1 inline clang :: PrintingPolicy getPP () function classof 1 2 3 static inline bool classof ( const TargetCodeFragment * TCF ) Public Attributes Documentation variable NeedsSemicolon 1 bool NeedsSemicolon ; Does the source code generation need to add a semicolon to this fragment. variable TargetCodeKind 1 clang :: OpenMPDirectiveKind TargetCodeKind ; What kind of code are we copying. TODO: this can create problems with non annotated function? variable HasExtraBraces 1 bool HasExtraBraces ; Protected Attributes Documentation variable Kind 1 const TargetCodeFragmentKind Kind ; Variable for LLVMs RTTI. variable Context 1 clang :: ASTContext & Context ; variable PP 1 clang :: PrintingPolicy PP ;","title":"TargetCodeFragment"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#targetcodefragment","text":"An abstract base class for all fragments of the original code (except header includes) that need to be copied to our generated source code. More... #include <TargetCodeFragment.h> Inherited by TargetCodeDecl , TargetCodeRegion","title":"TargetCodeFragment"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#public-types","text":"Name enum TargetCodeFragmentKind { TCFK_TargetCodeFragment, TCFK_TargetCodeRegion, TCFK_TargetCodeDecl} Enum for LLVMs RTTI.","title":"Public Types"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#public-functions","text":"Name TargetCodeFragmentKind getKind () const Accessor for LLVMs RTTI. TargetCodeFragment (clang::ASTContext & Context, TargetCodeFragmentKind Kind) virtual ~TargetCodeFragment () =0 Destroy the Target Code Fragment:: Target Code Fragment object. virtual std::string PrintPretty () =0 Tries to use Clang's PrettyPrinter when possible (this is currently only for target regions). virtual clang::SourceRange getRealRange () =0 Get the source range of the fragment. virtual clang::SourceRange getInnerRange () Gets the 'inner' source range. virtual clang::SourceRange getSpellingRange () =0 Get the spelling source range. clang::OpenMPDirectiveKind getTargetCodeKind () Accessor to TargetCodeKind. const clang::LangOptions & GetLangOpts () Accessor to lang opts of the current context. clang::PrintingPolicy getPP () bool classof (const TargetCodeFragment * TCF)","title":"Public Functions"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#public-attributes","text":"Name bool NeedsSemicolon Does the source code generation need to add a semicolon to this fragment. clang::OpenMPDirectiveKind TargetCodeKind What kind of code are we copying. bool HasExtraBraces","title":"Public Attributes"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#protected-attributes","text":"Name const TargetCodeFragmentKind Kind Variable for LLVMs RTTI. clang::ASTContext & Context clang::PrintingPolicy PP","title":"Protected Attributes"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#detailed-description","text":"1 class TargetCodeFragment ; An abstract base class for all fragments of the original code (except header includes) that need to be copied to our generated source code. This includes target regions as well as functions, global variables and types used by target regions (as far as we can detect that) as well as functions and variables that are flagged with the 'omp declare target' pragma.","title":"Detailed Description"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#enum-targetcodefragmentkind","text":"Enumerator Value Description TCFK_TargetCodeFragment TCFK_TargetCodeRegion TCFK_TargetCodeDecl Enum for LLVMs RTTI.","title":"enum TargetCodeFragmentKind"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-getkind","text":"1 inline TargetCodeFragmentKind getKind () const Accessor for LLVMs RTTI.","title":"function getKind"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-targetcodefragment","text":"1 2 3 4 inline TargetCodeFragment ( clang :: ASTContext & Context , TargetCodeFragmentKind Kind )","title":"function TargetCodeFragment"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-targetcodefragment_1","text":"1 virtual ~ TargetCodeFragment () = 0 Destroy the Target Code Fragment:: Target Code Fragment object.","title":"function ~TargetCodeFragment"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-printpretty","text":"1 virtual std :: string PrintPretty () = 0 Tries to use Clang's PrettyPrinter when possible (this is currently only for target regions). Reimplemented by : TargetCodeRegion::PrintPretty , TargetCodeDecl::PrintPretty","title":"function PrintPretty"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-getrealrange","text":"1 virtual clang :: SourceRange getRealRange () = 0 Get the source range of the fragment. Reimplemented by : TargetCodeRegion::getRealRange , TargetCodeDecl::getRealRange","title":"function getRealRange"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-getinnerrange","text":"1 inline virtual clang :: SourceRange getInnerRange () Gets the 'inner' source range. Reimplemented by : TargetCodeRegion::getInnerRange This can differ for target regions from the source range.","title":"function getInnerRange"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-getspellingrange","text":"1 virtual clang :: SourceRange getSpellingRange () = 0 Get the spelling source range. Reimplemented by : TargetCodeRegion::getSpellingRange , TargetCodeDecl::getSpellingRange That is the range without macro expansions.","title":"function getSpellingRange"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-gettargetcodekind","text":"1 inline clang :: OpenMPDirectiveKind getTargetCodeKind () Accessor to TargetCodeKind.","title":"function getTargetCodeKind"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-getlangopts","text":"1 inline const clang :: LangOptions & GetLangOpts () Accessor to lang opts of the current context.","title":"function GetLangOpts"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-getpp","text":"1 inline clang :: PrintingPolicy getPP ()","title":"function getPP"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#function-classof","text":"1 2 3 static inline bool classof ( const TargetCodeFragment * TCF )","title":"function classof"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#variable-needssemicolon","text":"1 bool NeedsSemicolon ; Does the source code generation need to add a semicolon to this fragment.","title":"variable NeedsSemicolon"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#variable-targetcodekind","text":"1 clang :: OpenMPDirectiveKind TargetCodeKind ; What kind of code are we copying. TODO: this can create problems with non annotated function?","title":"variable TargetCodeKind"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#variable-hasextrabraces","text":"1 bool HasExtraBraces ;","title":"variable HasExtraBraces"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#variable-kind","text":"1 const TargetCodeFragmentKind Kind ; Variable for LLVMs RTTI.","title":"variable Kind"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#variable-context","text":"1 clang :: ASTContext & Context ;","title":"variable Context"},{"location":"internal/doxygen/Classes/classTargetCodeFragment/#variable-pp","text":"1 clang :: PrintingPolicy PP ;","title":"variable PP"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/","text":"TargetCodeRegion Represents one target region. #include <TargetCodeFragment.h> Inherits from TargetCodeFragment Public Types Name using std::vector< TargetRegionVariable >::const_iterator captured_vars_const_iterator using llvm::iterator_range< captured_vars_const_iterator > captured_vars_const_range using std::set< clang::VarDecl * >::const_iterator private_vars_const_iterator using llvm::iterator_range< private_vars_const_iterator > private_vars_const_range using std::vector< clang::VarDecl * >::const_iterator ompclauses_params_const_iterator using llvm::iterator_range< ompclauses_params_const_iterator > ompclauses_params_const_range Public Functions Name bool classof (const TargetCodeFragment * TCF) TargetCodeRegion (clang::CapturedStmt * CapturedStmtNode, clang::OMPExecutableDirective * TargetDirective, clang::FunctionDecl * ParentFunctionDecl, clang::ASTContext & Context) void addCapture (const clang::CapturedStmt::Capture * Capture) Add a captured variable of the target region. captured_vars_const_iterator getCapturedVarsBegin () captured_vars_const_iterator getCapturedVarsEnd () captured_vars_const_range capturedVars () void addOMPClause (clang::OMPClause * Clause) Adds a (top level) OpenMP clause for the target region. const std::vector< clang::OMPClause * > & getOMPClauses () const void setPrivateVars (const std::set< clang::VarDecl * > & VarSet) Sets the private variables of this target region. private_vars_const_range privateVars () Returns a range over the private variables of this region. ompclauses_params_const_range ompClausesParams () Returns a range over the parameters to the top level OpenMP clauses. void addOMPClauseParam (clang::VarDecl * Param) Adds a parameter of a top level OpenMP clause to the target regions function as a function parameter. bool hasCombineConstruct () virtual std::string PrintPretty () override Do pretty printing in order to resolve Macros. virtual clang::SourceRange getRealRange () override Get source range. virtual clang::SourceRange getInnerRange () override Get inner range. virtual clang::SourceRange getSpellingRange () override Get spelling range. clang::SourceLocation getStartLoc () Returns a source location at the start of a pragma in the captured statement. clang::SourceLocation getEndLoc () Get end location. const std::string getParentFuncName () Returns the name of the function in which the target region is declared. clang::SourceLocation getTargetDirectiveLocation () Returns the SourceLocation for the target directive (we need the source location of the first pragma of the target region to compose the name of the function generated for that region) Public Attributes Name std::map< clang::VarDecl *, clang::Expr * > CapturedLowerBounds Lower bounds of mapped array slices (if lower then 0). Private Attributes Name clang::CapturedStmt * CapturedStmtNode The AST node for the captured statement of the target region. clang::OMPExecutableDirective * TargetDirective AST node for the target directive. clang::FunctionDecl * ParentFunctionDecl Declaration of the function this region is declared in. std::vector< TargetRegionVariable > CapturedVars All variable captured by this target region. std::vector< clang::OMPClause * > OMPClauses All omp clauses relevant to the execution of the region. std::vector< clang::VarDecl * > OMPClausesParams The variables which are parameters for top level OpenMP clauses. std::set< clang::VarDecl * > PrivateVars All private variables in a Target Region i.e. Additional inherited members Public Types inherited from TargetCodeFragment Name enum TargetCodeFragmentKind { TCFK_TargetCodeFragment, TCFK_TargetCodeRegion, TCFK_TargetCodeDecl} Enum for LLVMs RTTI. Public Functions inherited from TargetCodeFragment Name TargetCodeFragmentKind getKind () const Accessor for LLVMs RTTI. TargetCodeFragment (clang::ASTContext & Context, TargetCodeFragmentKind Kind) virtual ~TargetCodeFragment () =0 Destroy the Target Code Fragment:: Target Code Fragment object. clang::OpenMPDirectiveKind getTargetCodeKind () Accessor to TargetCodeKind. const clang::LangOptions & GetLangOpts () Accessor to lang opts of the current context. clang::PrintingPolicy getPP () Public Attributes inherited from TargetCodeFragment Name bool NeedsSemicolon Does the source code generation need to add a semicolon to this fragment. clang::OpenMPDirectiveKind TargetCodeKind What kind of code are we copying. bool HasExtraBraces Protected Attributes inherited from TargetCodeFragment Name const TargetCodeFragmentKind Kind Variable for LLVMs RTTI. clang::ASTContext & Context clang::PrintingPolicy PP Public Types Documentation using captured_vars_const_iterator 1 using TargetCodeRegion :: captured_vars_const_iterator = std :: vector < TargetRegionVariable >:: const_iterator ; using captured_vars_const_range 1 using TargetCodeRegion :: captured_vars_const_range = llvm :: iterator_range < captured_vars_const_iterator > ; using private_vars_const_iterator 1 using TargetCodeRegion :: private_vars_const_iterator = std :: set < clang :: VarDecl *>:: const_iterator ; using private_vars_const_range 1 using TargetCodeRegion :: private_vars_const_range = llvm :: iterator_range < private_vars_const_iterator > ; using ompclauses_params_const_iterator 1 using TargetCodeRegion :: ompclauses_params_const_iterator = std :: vector < clang :: VarDecl *>:: const_iterator ; using ompclauses_params_const_range 1 using TargetCodeRegion :: ompclauses_params_const_range = llvm :: iterator_range < ompclauses_params_const_iterator > ; Public Functions Documentation function classof 1 2 3 static inline bool classof ( const TargetCodeFragment * TCF ) function TargetCodeRegion 1 2 3 4 5 6 inline TargetCodeRegion ( clang :: CapturedStmt * CapturedStmtNode , clang :: OMPExecutableDirective * TargetDirective , clang :: FunctionDecl * ParentFunctionDecl , clang :: ASTContext & Context ) function addCapture 1 2 3 void addCapture ( const clang :: CapturedStmt :: Capture * Capture ) Add a captured variable of the target region. Parameters : Capture Captures element Add capture. This will automatically create and save a TargetRegionVariable which holds all information to generate parameters for the generated target region function. This will automatically create and save a TargetRegionVariable which holds all information to generate parameters for the generated target region function. function getCapturedVarsBegin 1 inline captured_vars_const_iterator getCapturedVarsBegin () function getCapturedVarsEnd 1 inline captured_vars_const_iterator getCapturedVarsEnd () function capturedVars 1 inline captured_vars_const_range capturedVars () function addOMPClause 1 2 3 void addOMPClause ( clang :: OMPClause * Clause ) Adds a (top level) OpenMP clause for the target region. Parameters : Clause OMP Clause Add OMP clauses. These clauses are later used to determine which OpenMP #pragma needs to be generated at the top level of the target region function. Adds a (top level) OpenMP clause for the target region. These clauses are later used to determine which OpenMP #pragma needs to be generated at the top level of the target region function. function getOMPClauses 1 inline const std :: vector < clang :: OMPClause * > & getOMPClauses () const function setPrivateVars 1 2 3 inline void setPrivateVars ( const std :: set < clang :: VarDecl * > & VarSet ) Sets the private variables of this target region. function privateVars 1 inline private_vars_const_range privateVars () Returns a range over the private variables of this region. function ompClausesParams 1 inline ompclauses_params_const_range ompClausesParams () Returns a range over the parameters to the top level OpenMP clauses. function addOMPClauseParam 1 2 3 void addOMPClauseParam ( clang :: VarDecl * Param ) Adds a parameter of a top level OpenMP clause to the target regions function as a function parameter. Parameters : Param Parameter Add OMP clause parameters. Adds OMP clause paramenters to a TargetCodeRegion function hasCombineConstruct 1 inline bool hasCombineConstruct () function PrintPretty 1 virtual std :: string PrintPretty () override Do pretty printing in order to resolve Macros. Return : std::string Pretty output Reimplements : TargetCodeFragment::PrintPretty function getRealRange 1 virtual clang :: SourceRange getRealRange () override Get source range. Return : clang::SourceRange Reimplements : TargetCodeFragment::getRealRange function getInnerRange 1 virtual clang :: SourceRange getInnerRange () override Get inner range. Return : clang::SourceRange Reimplements : TargetCodeFragment::getInnerRange function getSpellingRange 1 virtual clang :: SourceRange getSpellingRange () override Get spelling range. Return : clang::SourceRange Reimplements : TargetCodeFragment::getSpellingRange function getStartLoc 1 clang :: SourceLocation getStartLoc () Returns a source location at the start of a pragma in the captured statement. Return : clang::SourceLocation Start location function getEndLoc 1 clang :: SourceLocation getEndLoc () Get end location. Return : clang::SourceLocation End location function getParentFuncName 1 const std :: string getParentFuncName () Returns the name of the function in which the target region is declared. Return : const std::string function getTargetDirectiveLocation 1 clang :: SourceLocation getTargetDirectiveLocation () Returns the SourceLocation for the target directive (we need the source location of the first pragma of the target region to compose the name of the function generated for that region) Return : clang::SourceLocation Location Get target directive location. Returns the SourceLocation for the target directive (we need the source location of the first pragma of the target region to compose the name of the function generated for that region) Public Attributes Documentation variable CapturedLowerBounds 1 std :: map < clang :: VarDecl * , clang :: Expr * > CapturedLowerBounds ; Lower bounds of mapped array slices (if lower then 0). If the captured variable is an array, of which only a slice is mapped (by a map() clause), the incoming pointer argument will need to be shifted to the right if the lower bound of that slice is not 0. If this is the case, the lower bound is saved into this map. Private Attributes Documentation variable CapturedStmtNode 1 clang :: CapturedStmt * CapturedStmtNode ; The AST node for the captured statement of the target region. variable TargetDirective 1 clang :: OMPExecutableDirective * TargetDirective ; AST node for the target directive. variable ParentFunctionDecl 1 clang :: FunctionDecl * ParentFunctionDecl ; Declaration of the function this region is declared in. Necessary to compose the function name of this region in the generated code. variable CapturedVars 1 std :: vector < TargetRegionVariable > CapturedVars ; All variable captured by this target region. We will need to generated pointers to them as arguments to the generated functions and copy the variables into scope. variable OMPClauses 1 std :: vector < clang :: OMPClause * > OMPClauses ; All omp clauses relevant to the execution of the region. variable OMPClausesParams 1 std :: vector < clang :: VarDecl * > OMPClausesParams ; The variables which are parameters for top level OpenMP clauses. These are not captured but still needs passed as (first private) arguments to the target region. variable PrivateVars 1 std :: set < clang :: VarDecl * > PrivateVars ; All private variables in a Target Region i.e. all variables that are not passed as arguments into the region. For these, we need to generate declarations inside the target region.","title":"TargetCodeRegion"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#targetcoderegion","text":"Represents one target region. #include <TargetCodeFragment.h> Inherits from TargetCodeFragment","title":"TargetCodeRegion"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#public-types","text":"Name using std::vector< TargetRegionVariable >::const_iterator captured_vars_const_iterator using llvm::iterator_range< captured_vars_const_iterator > captured_vars_const_range using std::set< clang::VarDecl * >::const_iterator private_vars_const_iterator using llvm::iterator_range< private_vars_const_iterator > private_vars_const_range using std::vector< clang::VarDecl * >::const_iterator ompclauses_params_const_iterator using llvm::iterator_range< ompclauses_params_const_iterator > ompclauses_params_const_range","title":"Public Types"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#public-functions","text":"Name bool classof (const TargetCodeFragment * TCF) TargetCodeRegion (clang::CapturedStmt * CapturedStmtNode, clang::OMPExecutableDirective * TargetDirective, clang::FunctionDecl * ParentFunctionDecl, clang::ASTContext & Context) void addCapture (const clang::CapturedStmt::Capture * Capture) Add a captured variable of the target region. captured_vars_const_iterator getCapturedVarsBegin () captured_vars_const_iterator getCapturedVarsEnd () captured_vars_const_range capturedVars () void addOMPClause (clang::OMPClause * Clause) Adds a (top level) OpenMP clause for the target region. const std::vector< clang::OMPClause * > & getOMPClauses () const void setPrivateVars (const std::set< clang::VarDecl * > & VarSet) Sets the private variables of this target region. private_vars_const_range privateVars () Returns a range over the private variables of this region. ompclauses_params_const_range ompClausesParams () Returns a range over the parameters to the top level OpenMP clauses. void addOMPClauseParam (clang::VarDecl * Param) Adds a parameter of a top level OpenMP clause to the target regions function as a function parameter. bool hasCombineConstruct () virtual std::string PrintPretty () override Do pretty printing in order to resolve Macros. virtual clang::SourceRange getRealRange () override Get source range. virtual clang::SourceRange getInnerRange () override Get inner range. virtual clang::SourceRange getSpellingRange () override Get spelling range. clang::SourceLocation getStartLoc () Returns a source location at the start of a pragma in the captured statement. clang::SourceLocation getEndLoc () Get end location. const std::string getParentFuncName () Returns the name of the function in which the target region is declared. clang::SourceLocation getTargetDirectiveLocation () Returns the SourceLocation for the target directive (we need the source location of the first pragma of the target region to compose the name of the function generated for that region)","title":"Public Functions"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#public-attributes","text":"Name std::map< clang::VarDecl *, clang::Expr * > CapturedLowerBounds Lower bounds of mapped array slices (if lower then 0).","title":"Public Attributes"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#private-attributes","text":"Name clang::CapturedStmt * CapturedStmtNode The AST node for the captured statement of the target region. clang::OMPExecutableDirective * TargetDirective AST node for the target directive. clang::FunctionDecl * ParentFunctionDecl Declaration of the function this region is declared in. std::vector< TargetRegionVariable > CapturedVars All variable captured by this target region. std::vector< clang::OMPClause * > OMPClauses All omp clauses relevant to the execution of the region. std::vector< clang::VarDecl * > OMPClausesParams The variables which are parameters for top level OpenMP clauses. std::set< clang::VarDecl * > PrivateVars All private variables in a Target Region i.e.","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#additional-inherited-members","text":"Public Types inherited from TargetCodeFragment Name enum TargetCodeFragmentKind { TCFK_TargetCodeFragment, TCFK_TargetCodeRegion, TCFK_TargetCodeDecl} Enum for LLVMs RTTI. Public Functions inherited from TargetCodeFragment Name TargetCodeFragmentKind getKind () const Accessor for LLVMs RTTI. TargetCodeFragment (clang::ASTContext & Context, TargetCodeFragmentKind Kind) virtual ~TargetCodeFragment () =0 Destroy the Target Code Fragment:: Target Code Fragment object. clang::OpenMPDirectiveKind getTargetCodeKind () Accessor to TargetCodeKind. const clang::LangOptions & GetLangOpts () Accessor to lang opts of the current context. clang::PrintingPolicy getPP () Public Attributes inherited from TargetCodeFragment Name bool NeedsSemicolon Does the source code generation need to add a semicolon to this fragment. clang::OpenMPDirectiveKind TargetCodeKind What kind of code are we copying. bool HasExtraBraces Protected Attributes inherited from TargetCodeFragment Name const TargetCodeFragmentKind Kind Variable for LLVMs RTTI. clang::ASTContext & Context clang::PrintingPolicy PP","title":"Additional inherited members"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#using-captured_vars_const_iterator","text":"1 using TargetCodeRegion :: captured_vars_const_iterator = std :: vector < TargetRegionVariable >:: const_iterator ;","title":"using captured_vars_const_iterator"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#using-captured_vars_const_range","text":"1 using TargetCodeRegion :: captured_vars_const_range = llvm :: iterator_range < captured_vars_const_iterator > ;","title":"using captured_vars_const_range"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#using-private_vars_const_iterator","text":"1 using TargetCodeRegion :: private_vars_const_iterator = std :: set < clang :: VarDecl *>:: const_iterator ;","title":"using private_vars_const_iterator"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#using-private_vars_const_range","text":"1 using TargetCodeRegion :: private_vars_const_range = llvm :: iterator_range < private_vars_const_iterator > ;","title":"using private_vars_const_range"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#using-ompclauses_params_const_iterator","text":"1 using TargetCodeRegion :: ompclauses_params_const_iterator = std :: vector < clang :: VarDecl *>:: const_iterator ;","title":"using ompclauses_params_const_iterator"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#using-ompclauses_params_const_range","text":"1 using TargetCodeRegion :: ompclauses_params_const_range = llvm :: iterator_range < ompclauses_params_const_iterator > ;","title":"using ompclauses_params_const_range"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-classof","text":"1 2 3 static inline bool classof ( const TargetCodeFragment * TCF )","title":"function classof"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-targetcoderegion","text":"1 2 3 4 5 6 inline TargetCodeRegion ( clang :: CapturedStmt * CapturedStmtNode , clang :: OMPExecutableDirective * TargetDirective , clang :: FunctionDecl * ParentFunctionDecl , clang :: ASTContext & Context )","title":"function TargetCodeRegion"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-addcapture","text":"1 2 3 void addCapture ( const clang :: CapturedStmt :: Capture * Capture ) Add a captured variable of the target region. Parameters : Capture Captures element Add capture. This will automatically create and save a TargetRegionVariable which holds all information to generate parameters for the generated target region function. This will automatically create and save a TargetRegionVariable which holds all information to generate parameters for the generated target region function.","title":"function addCapture"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-getcapturedvarsbegin","text":"1 inline captured_vars_const_iterator getCapturedVarsBegin ()","title":"function getCapturedVarsBegin"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-getcapturedvarsend","text":"1 inline captured_vars_const_iterator getCapturedVarsEnd ()","title":"function getCapturedVarsEnd"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-capturedvars","text":"1 inline captured_vars_const_range capturedVars ()","title":"function capturedVars"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-addompclause","text":"1 2 3 void addOMPClause ( clang :: OMPClause * Clause ) Adds a (top level) OpenMP clause for the target region. Parameters : Clause OMP Clause Add OMP clauses. These clauses are later used to determine which OpenMP #pragma needs to be generated at the top level of the target region function. Adds a (top level) OpenMP clause for the target region. These clauses are later used to determine which OpenMP #pragma needs to be generated at the top level of the target region function.","title":"function addOMPClause"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-getompclauses","text":"1 inline const std :: vector < clang :: OMPClause * > & getOMPClauses () const","title":"function getOMPClauses"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-setprivatevars","text":"1 2 3 inline void setPrivateVars ( const std :: set < clang :: VarDecl * > & VarSet ) Sets the private variables of this target region.","title":"function setPrivateVars"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-privatevars","text":"1 inline private_vars_const_range privateVars () Returns a range over the private variables of this region.","title":"function privateVars"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-ompclausesparams","text":"1 inline ompclauses_params_const_range ompClausesParams () Returns a range over the parameters to the top level OpenMP clauses.","title":"function ompClausesParams"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-addompclauseparam","text":"1 2 3 void addOMPClauseParam ( clang :: VarDecl * Param ) Adds a parameter of a top level OpenMP clause to the target regions function as a function parameter. Parameters : Param Parameter Add OMP clause parameters. Adds OMP clause paramenters to a TargetCodeRegion","title":"function addOMPClauseParam"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-hascombineconstruct","text":"1 inline bool hasCombineConstruct ()","title":"function hasCombineConstruct"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-printpretty","text":"1 virtual std :: string PrintPretty () override Do pretty printing in order to resolve Macros. Return : std::string Pretty output Reimplements : TargetCodeFragment::PrintPretty","title":"function PrintPretty"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-getrealrange","text":"1 virtual clang :: SourceRange getRealRange () override Get source range. Return : clang::SourceRange Reimplements : TargetCodeFragment::getRealRange","title":"function getRealRange"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-getinnerrange","text":"1 virtual clang :: SourceRange getInnerRange () override Get inner range. Return : clang::SourceRange Reimplements : TargetCodeFragment::getInnerRange","title":"function getInnerRange"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-getspellingrange","text":"1 virtual clang :: SourceRange getSpellingRange () override Get spelling range. Return : clang::SourceRange Reimplements : TargetCodeFragment::getSpellingRange","title":"function getSpellingRange"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-getstartloc","text":"1 clang :: SourceLocation getStartLoc () Returns a source location at the start of a pragma in the captured statement. Return : clang::SourceLocation Start location","title":"function getStartLoc"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-getendloc","text":"1 clang :: SourceLocation getEndLoc () Get end location. Return : clang::SourceLocation End location","title":"function getEndLoc"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-getparentfuncname","text":"1 const std :: string getParentFuncName () Returns the name of the function in which the target region is declared. Return : const std::string","title":"function getParentFuncName"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#function-gettargetdirectivelocation","text":"1 clang :: SourceLocation getTargetDirectiveLocation () Returns the SourceLocation for the target directive (we need the source location of the first pragma of the target region to compose the name of the function generated for that region) Return : clang::SourceLocation Location Get target directive location. Returns the SourceLocation for the target directive (we need the source location of the first pragma of the target region to compose the name of the function generated for that region)","title":"function getTargetDirectiveLocation"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#variable-capturedlowerbounds","text":"1 std :: map < clang :: VarDecl * , clang :: Expr * > CapturedLowerBounds ; Lower bounds of mapped array slices (if lower then 0). If the captured variable is an array, of which only a slice is mapped (by a map() clause), the incoming pointer argument will need to be shifted to the right if the lower bound of that slice is not 0. If this is the case, the lower bound is saved into this map.","title":"variable CapturedLowerBounds"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#variable-capturedstmtnode","text":"1 clang :: CapturedStmt * CapturedStmtNode ; The AST node for the captured statement of the target region.","title":"variable CapturedStmtNode"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#variable-targetdirective","text":"1 clang :: OMPExecutableDirective * TargetDirective ; AST node for the target directive.","title":"variable TargetDirective"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#variable-parentfunctiondecl","text":"1 clang :: FunctionDecl * ParentFunctionDecl ; Declaration of the function this region is declared in. Necessary to compose the function name of this region in the generated code.","title":"variable ParentFunctionDecl"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#variable-capturedvars","text":"1 std :: vector < TargetRegionVariable > CapturedVars ; All variable captured by this target region. We will need to generated pointers to them as arguments to the generated functions and copy the variables into scope.","title":"variable CapturedVars"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#variable-ompclauses","text":"1 std :: vector < clang :: OMPClause * > OMPClauses ; All omp clauses relevant to the execution of the region.","title":"variable OMPClauses"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#variable-ompclausesparams","text":"1 std :: vector < clang :: VarDecl * > OMPClausesParams ; The variables which are parameters for top level OpenMP clauses. These are not captured but still needs passed as (first private) arguments to the target region.","title":"variable OMPClausesParams"},{"location":"internal/doxygen/Classes/classTargetCodeRegion/#variable-privatevars","text":"1 std :: set < clang :: VarDecl * > PrivateVars ; All private variables in a Target Region i.e. all variables that are not passed as arguments into the region. For these, we need to generate declarations inside the target region.","title":"variable PrivateVars"},{"location":"internal/doxygen/Classes/classTargetRegionPrinterHelper/","text":"TargetRegionPrinterHelper Print Helper Class. Inherits from PrinterHelper Public Functions Name TargetRegionPrinterHelper (clang::PrintingPolicy PP) Construct a new Target Region Printer Helper object. bool handledStmt (clang::Stmt * E, llvm::raw_ostream & OS) Handle Statement. Private Attributes Name clang::PrintingPolicy PP Public Functions Documentation function TargetRegionPrinterHelper 1 2 3 inline TargetRegionPrinterHelper ( clang :: PrintingPolicy PP ) Construct a new Target Region Printer Helper object. Parameters : PP function handledStmt 1 2 3 4 inline bool handledStmt ( clang :: Stmt * E , llvm :: raw_ostream & OS ) Handle Statement. Parameters : E Statement OS Out stream Private Attributes Documentation variable PP 1 clang :: PrintingPolicy PP ;","title":"TargetRegionPrinterHelper"},{"location":"internal/doxygen/Classes/classTargetRegionPrinterHelper/#targetregionprinterhelper","text":"Print Helper Class. Inherits from PrinterHelper","title":"TargetRegionPrinterHelper"},{"location":"internal/doxygen/Classes/classTargetRegionPrinterHelper/#public-functions","text":"Name TargetRegionPrinterHelper (clang::PrintingPolicy PP) Construct a new Target Region Printer Helper object. bool handledStmt (clang::Stmt * E, llvm::raw_ostream & OS) Handle Statement.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classTargetRegionPrinterHelper/#private-attributes","text":"Name clang::PrintingPolicy PP","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classTargetRegionPrinterHelper/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionPrinterHelper/#function-targetregionprinterhelper","text":"1 2 3 inline TargetRegionPrinterHelper ( clang :: PrintingPolicy PP ) Construct a new Target Region Printer Helper object. Parameters : PP","title":"function TargetRegionPrinterHelper"},{"location":"internal/doxygen/Classes/classTargetRegionPrinterHelper/#function-handledstmt","text":"1 2 3 4 inline bool handledStmt ( clang :: Stmt * E , llvm :: raw_ostream & OS ) Handle Statement. Parameters : E Statement OS Out stream","title":"function handledStmt"},{"location":"internal/doxygen/Classes/classTargetRegionPrinterHelper/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionPrinterHelper/#variable-pp","text":"1 clang :: PrintingPolicy PP ;","title":"variable PP"},{"location":"internal/doxygen/Classes/classTargetRegionTransformer/","text":"TargetRegionTransformer Inherits from ASTConsumer Public Functions Name TargetRegionTransformer ( TargetCode & Code, clang::Rewriter & TargetCodeRewriter) void HandleTranslationUnit (clang::ASTContext & Context) Private Attributes Name TargetCode & Code clang::Rewriter & TargetCodeRewriter Public Functions Documentation function TargetRegionTransformer 1 2 3 4 inline TargetRegionTransformer ( TargetCode & Code , clang :: Rewriter & TargetCodeRewriter ) function HandleTranslationUnit 1 2 3 inline void HandleTranslationUnit ( clang :: ASTContext & Context ) Private Attributes Documentation variable Code 1 TargetCode & Code ; variable TargetCodeRewriter 1 clang :: Rewriter & TargetCodeRewriter ;","title":"TargetRegionTransformer"},{"location":"internal/doxygen/Classes/classTargetRegionTransformer/#targetregiontransformer","text":"Inherits from ASTConsumer","title":"TargetRegionTransformer"},{"location":"internal/doxygen/Classes/classTargetRegionTransformer/#public-functions","text":"Name TargetRegionTransformer ( TargetCode & Code, clang::Rewriter & TargetCodeRewriter) void HandleTranslationUnit (clang::ASTContext & Context)","title":"Public Functions"},{"location":"internal/doxygen/Classes/classTargetRegionTransformer/#private-attributes","text":"Name TargetCode & Code clang::Rewriter & TargetCodeRewriter","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classTargetRegionTransformer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionTransformer/#function-targetregiontransformer","text":"1 2 3 4 inline TargetRegionTransformer ( TargetCode & Code , clang :: Rewriter & TargetCodeRewriter )","title":"function TargetRegionTransformer"},{"location":"internal/doxygen/Classes/classTargetRegionTransformer/#function-handletranslationunit","text":"1 2 3 inline void HandleTranslationUnit ( clang :: ASTContext & Context )","title":"function HandleTranslationUnit"},{"location":"internal/doxygen/Classes/classTargetRegionTransformer/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionTransformer/#variable-code","text":"1 TargetCode & Code ;","title":"variable Code"},{"location":"internal/doxygen/Classes/classTargetRegionTransformer/#variable-targetcoderewriter","text":"1 clang :: Rewriter & TargetCodeRewriter ;","title":"variable TargetCodeRewriter"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/","text":"TargetRegionVariable Represents a variable captured by a target region. More... #include <TargetRegionVariable.h> Public Classes Name class shape_const_kind_iterator Iterator which acts as a filter over std::vector ::const_iterator (the base_iter) which only passes on TargetRegionVariableShape of the kind specified in Kind . Public Types Name using std::vector< TargetRegionVariableShape >::const_iterator shape_const_iterator Iterator of all shapes of this variable. using llvm::iterator_range< shape_const_iterator > shape_const_range Range over all shapes of this variable. using llvm::iterator_range< shape_const_kind_iterator > shape_const_kind_range Range over all shapes of a certain kind of this variable. Public Functions Name llvm::StringRef name () const The name of the variable. llvm::StringRef baseTypeName () const The name of the base type (stripped of all qualifiers). clang::VarDecl * getDecl () const The Decl node of the variable. bool containsArray () const Whether this variable's type contains an array or not. bool containsPointer () const Whether this variable's type contains a pointer or not. bool passedByPointer () const Returns true if this variable is passed by pointer. llvm::Optional< clang::Expr * > arrayLowerBound () const The lower bound of an array slice in the first dimension. bool operator== (const TargetRegionVariable & Other) const shape_const_range shapes () const Gives a range over the shape of all dimensions. shape_const_kind_range variableArrayShapes () const Gives a range over those shape dimensions which are variable arrays. TargetRegionVariable (const clang::CapturedStmt::Capture * Capture, const std::map< clang::VarDecl *, clang::Expr * > & MappingLowerBounds) Construct a new Target Region Variable:: Target Region Variable object. Private Functions Name void determineShapes (clang::QualType T) Determine variable shape. Private Attributes Name const clang::CapturedStmt::Capture * Capture clang::VarDecl * Decl std::string VarName std::string BaseTypeName This is the base type name, i.e. std::vector< TargetRegionVariableShape > Shapes unsigned int NumVariableArrayDims const std::map< clang::VarDecl *, clang::Expr * > & OmpMappingLowerBound Detailed Description 1 class TargetRegionVariable ; Represents a variable captured by a target region. This class is an abstraction that provides information on how the variable is passed to the target region, whether it is a slice or array and how it's dimensionality is declared Public Types Documentation using shape_const_iterator 1 using TargetRegionVariable :: shape_const_iterator = std :: vector < TargetRegionVariableShape >:: const_iterator ; Iterator of all shapes of this variable. using shape_const_range 1 using TargetRegionVariable :: shape_const_range = llvm :: iterator_range < shape_const_iterator > ; Range over all shapes of this variable. using shape_const_kind_range 1 using TargetRegionVariable :: shape_const_kind_range = llvm :: iterator_range < shape_const_kind_iterator > ; Range over all shapes of a certain kind of this variable. Public Functions Documentation function name 1 inline llvm :: StringRef name () const The name of the variable. function baseTypeName 1 inline llvm :: StringRef baseTypeName () const The name of the base type (stripped of all qualifiers). function getDecl 1 inline clang :: VarDecl * getDecl () const The Decl node of the variable. function containsArray 1 bool containsArray () const Whether this variable's type contains an array or not. Return : true if an array is contained, false otherwise Check if the shape of a TargetRegionVariable contains an array. function containsPointer 1 bool containsPointer () const Whether this variable's type contains a pointer or not. Return : true if a pointer is contained, false otherwise Check if the shape of a TargetRegionVariable contains an pointer. function passedByPointer 1 bool passedByPointer () const Returns true if this variable is passed by pointer. Return : true If a variable is passed by pointer false If a variable is not passed by pointer Determines whether a variable is passed by pointer. This is the case for shared and first-private variables scalars and for arrays. Note that pointer types are generally passed by value and we do not generate an additional * for it. function arrayLowerBound 1 llvm :: Optional < clang :: Expr * > arrayLowerBound () const The lower bound of an array slice in the first dimension. Return : llvm::Optional Lower bound Finds the lower bound of an array. All other dimension can be ignored because libomptarget only transfers continuous data. In case of a scalar (or an array which is mapped completly in the first dimension) this returns 0. function operator== 1 2 3 inline bool operator == ( const TargetRegionVariable & Other ) const function shapes 1 inline shape_const_range shapes () const Gives a range over the shape of all dimensions. function variableArrayShapes 1 inline shape_const_kind_range variableArrayShapes () const Gives a range over those shape dimensions which are variable arrays. This is called while generating the functions argument for variable array sizes. function TargetRegionVariable 1 2 3 4 TargetRegionVariable ( const clang :: CapturedStmt :: Capture * Capture , const std :: map < clang :: VarDecl * , clang :: Expr * > & MappingLowerBounds ) Construct a new Target Region Variable:: Target Region Variable object. Parameters : Capture MappingLowerBounds Private Functions Documentation function determineShapes 1 2 3 void determineShapes ( clang :: QualType T ) Determine variable shape. Parameters : T Type Determines the shape of a varable by resolving its type. Private Attributes Documentation variable Capture 1 const clang :: CapturedStmt :: Capture * Capture ; variable Decl 1 clang :: VarDecl * Decl ; variable VarName 1 std :: string VarName ; variable BaseTypeName 1 std :: string BaseTypeName ; This is the base type name, i.e. the name of the type without pointer or array qualifiers. variable Shapes 1 std :: vector < TargetRegionVariableShape > Shapes ; variable NumVariableArrayDims 1 unsigned int NumVariableArrayDims ; variable OmpMappingLowerBound 1 const std :: map < clang :: VarDecl * , clang :: Expr * > & OmpMappingLowerBound ;","title":"TargetRegionVariable"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#targetregionvariable","text":"Represents a variable captured by a target region. More... #include <TargetRegionVariable.h>","title":"TargetRegionVariable"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#public-classes","text":"Name class shape_const_kind_iterator Iterator which acts as a filter over std::vector ::const_iterator (the base_iter) which only passes on TargetRegionVariableShape of the kind specified in Kind .","title":"Public Classes"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#public-types","text":"Name using std::vector< TargetRegionVariableShape >::const_iterator shape_const_iterator Iterator of all shapes of this variable. using llvm::iterator_range< shape_const_iterator > shape_const_range Range over all shapes of this variable. using llvm::iterator_range< shape_const_kind_iterator > shape_const_kind_range Range over all shapes of a certain kind of this variable.","title":"Public Types"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#public-functions","text":"Name llvm::StringRef name () const The name of the variable. llvm::StringRef baseTypeName () const The name of the base type (stripped of all qualifiers). clang::VarDecl * getDecl () const The Decl node of the variable. bool containsArray () const Whether this variable's type contains an array or not. bool containsPointer () const Whether this variable's type contains a pointer or not. bool passedByPointer () const Returns true if this variable is passed by pointer. llvm::Optional< clang::Expr * > arrayLowerBound () const The lower bound of an array slice in the first dimension. bool operator== (const TargetRegionVariable & Other) const shape_const_range shapes () const Gives a range over the shape of all dimensions. shape_const_kind_range variableArrayShapes () const Gives a range over those shape dimensions which are variable arrays. TargetRegionVariable (const clang::CapturedStmt::Capture * Capture, const std::map< clang::VarDecl *, clang::Expr * > & MappingLowerBounds) Construct a new Target Region Variable:: Target Region Variable object.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#private-functions","text":"Name void determineShapes (clang::QualType T) Determine variable shape.","title":"Private Functions"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#private-attributes","text":"Name const clang::CapturedStmt::Capture * Capture clang::VarDecl * Decl std::string VarName std::string BaseTypeName This is the base type name, i.e. std::vector< TargetRegionVariableShape > Shapes unsigned int NumVariableArrayDims const std::map< clang::VarDecl *, clang::Expr * > & OmpMappingLowerBound","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#detailed-description","text":"1 class TargetRegionVariable ; Represents a variable captured by a target region. This class is an abstraction that provides information on how the variable is passed to the target region, whether it is a slice or array and how it's dimensionality is declared","title":"Detailed Description"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#using-shape_const_iterator","text":"1 using TargetRegionVariable :: shape_const_iterator = std :: vector < TargetRegionVariableShape >:: const_iterator ; Iterator of all shapes of this variable.","title":"using shape_const_iterator"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#using-shape_const_range","text":"1 using TargetRegionVariable :: shape_const_range = llvm :: iterator_range < shape_const_iterator > ; Range over all shapes of this variable.","title":"using shape_const_range"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#using-shape_const_kind_range","text":"1 using TargetRegionVariable :: shape_const_kind_range = llvm :: iterator_range < shape_const_kind_iterator > ; Range over all shapes of a certain kind of this variable.","title":"using shape_const_kind_range"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-name","text":"1 inline llvm :: StringRef name () const The name of the variable.","title":"function name"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-basetypename","text":"1 inline llvm :: StringRef baseTypeName () const The name of the base type (stripped of all qualifiers).","title":"function baseTypeName"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-getdecl","text":"1 inline clang :: VarDecl * getDecl () const The Decl node of the variable.","title":"function getDecl"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-containsarray","text":"1 bool containsArray () const Whether this variable's type contains an array or not. Return : true if an array is contained, false otherwise Check if the shape of a TargetRegionVariable contains an array.","title":"function containsArray"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-containspointer","text":"1 bool containsPointer () const Whether this variable's type contains a pointer or not. Return : true if a pointer is contained, false otherwise Check if the shape of a TargetRegionVariable contains an pointer.","title":"function containsPointer"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-passedbypointer","text":"1 bool passedByPointer () const Returns true if this variable is passed by pointer. Return : true If a variable is passed by pointer false If a variable is not passed by pointer Determines whether a variable is passed by pointer. This is the case for shared and first-private variables scalars and for arrays. Note that pointer types are generally passed by value and we do not generate an additional * for it.","title":"function passedByPointer"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-arraylowerbound","text":"1 llvm :: Optional < clang :: Expr * > arrayLowerBound () const The lower bound of an array slice in the first dimension. Return : llvm::Optional Lower bound Finds the lower bound of an array. All other dimension can be ignored because libomptarget only transfers continuous data. In case of a scalar (or an array which is mapped completly in the first dimension) this returns 0.","title":"function arrayLowerBound"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-operator","text":"1 2 3 inline bool operator == ( const TargetRegionVariable & Other ) const","title":"function operator=="},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-shapes","text":"1 inline shape_const_range shapes () const Gives a range over the shape of all dimensions.","title":"function shapes"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-variablearrayshapes","text":"1 inline shape_const_kind_range variableArrayShapes () const Gives a range over those shape dimensions which are variable arrays. This is called while generating the functions argument for variable array sizes.","title":"function variableArrayShapes"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-targetregionvariable","text":"1 2 3 4 TargetRegionVariable ( const clang :: CapturedStmt :: Capture * Capture , const std :: map < clang :: VarDecl * , clang :: Expr * > & MappingLowerBounds ) Construct a new Target Region Variable:: Target Region Variable object. Parameters : Capture MappingLowerBounds","title":"function TargetRegionVariable"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#private-functions-documentation","text":"","title":"Private Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#function-determineshapes","text":"1 2 3 void determineShapes ( clang :: QualType T ) Determine variable shape. Parameters : T Type Determines the shape of a varable by resolving its type.","title":"function determineShapes"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#variable-capture","text":"1 const clang :: CapturedStmt :: Capture * Capture ;","title":"variable Capture"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#variable-decl","text":"1 clang :: VarDecl * Decl ;","title":"variable Decl"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#variable-varname","text":"1 std :: string VarName ;","title":"variable VarName"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#variable-basetypename","text":"1 std :: string BaseTypeName ; This is the base type name, i.e. the name of the type without pointer or array qualifiers.","title":"variable BaseTypeName"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#variable-shapes","text":"1 std :: vector < TargetRegionVariableShape > Shapes ;","title":"variable Shapes"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#variable-numvariablearraydims","text":"1 unsigned int NumVariableArrayDims ;","title":"variable NumVariableArrayDims"},{"location":"internal/doxygen/Classes/classTargetRegionVariable/#variable-ompmappinglowerbound","text":"1 const std :: map < clang :: VarDecl * , clang :: Expr * > & OmpMappingLowerBound ;","title":"variable OmpMappingLowerBound"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/","text":"TargetRegionVariableShape Describes the shape, i.e. More... #include <TargetRegionVariable.h> Public Types Name enum ShapeKind Public Functions Name ShapeKind getKind () const bool isVariableArray () const bool isConstantArray () const bool isArray () const bool isPointer () const unsigned int getVariableDimensionIndex () const If the shape is a variable array, return the array dimension index, (used for generating __sotoc_vla_dimX_ parameters in which the host signals the array's size). llvm::StringRef getConstantDimensionExpr () const If the shape is a constant array, it returns the rendered expression for the constant size. TargetRegionVariableShape () Construct a pointer shape by default. TargetRegionVariableShape (const clang::ParenType * Paren) Construct a parentheses shape. TargetRegionVariableShape (const clang::VariableArrayType * Array, unsigned int DimIndex) Construct a shape for a variable array dimension. TargetRegionVariableShape (const clang::ConstantArrayType * Array) Construct a shape for a constant array dimension. Private Attributes Name unsigned int VariableDimensionIndex std::string ConstantDimensionExpr ShapeKind Kind Detailed Description 1 class TargetRegionVariableShape ; Describes the shape, i.e. a variable dimension of constant or variable size, or a pointer. We collect this information for every parameter of a target region function because the pretty printer does not support the output format for variable and types (e.g. it prints 'int ( )[SIZE] a' instead of 'int ( ) a[SIZE]'), so we print this manually in TargetCode.cpp . For this we need every pointer indirection and array dimension which each is saved as shapes for that variable. Public Types Documentation enum ShapeKind Enumerator Value Description Pointer Paren ConstantArray VariableArray Public Functions Documentation function getKind 1 inline ShapeKind getKind () const function isVariableArray 1 inline bool isVariableArray () const function isConstantArray 1 inline bool isConstantArray () const function isArray 1 inline bool isArray () const function isPointer 1 inline bool isPointer () const function getVariableDimensionIndex 1 inline unsigned int getVariableDimensionIndex () const If the shape is a variable array, return the array dimension index, (used for generating __sotoc_vla_dimX_ parameters in which the host signals the array's size). function getConstantDimensionExpr 1 inline llvm :: StringRef getConstantDimensionExpr () const If the shape is a constant array, it returns the rendered expression for the constant size. function TargetRegionVariableShape 1 inline TargetRegionVariableShape () Construct a pointer shape by default. function TargetRegionVariableShape 1 2 3 inline TargetRegionVariableShape ( const clang :: ParenType * Paren ) Construct a parentheses shape. function TargetRegionVariableShape 1 2 3 4 inline TargetRegionVariableShape ( const clang :: VariableArrayType * Array , unsigned int DimIndex ) Construct a shape for a variable array dimension. function TargetRegionVariableShape 1 2 3 inline TargetRegionVariableShape ( const clang :: ConstantArrayType * Array ) Construct a shape for a constant array dimension. Private Attributes Documentation variable VariableDimensionIndex 1 unsigned int VariableDimensionIndex ; variable ConstantDimensionExpr 1 std :: string ConstantDimensionExpr ; variable Kind 1 ShapeKind Kind ;","title":"TargetRegionVariableShape"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#targetregionvariableshape","text":"Describes the shape, i.e. More... #include <TargetRegionVariable.h>","title":"TargetRegionVariableShape"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#public-types","text":"Name enum ShapeKind","title":"Public Types"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#public-functions","text":"Name ShapeKind getKind () const bool isVariableArray () const bool isConstantArray () const bool isArray () const bool isPointer () const unsigned int getVariableDimensionIndex () const If the shape is a variable array, return the array dimension index, (used for generating __sotoc_vla_dimX_ parameters in which the host signals the array's size). llvm::StringRef getConstantDimensionExpr () const If the shape is a constant array, it returns the rendered expression for the constant size. TargetRegionVariableShape () Construct a pointer shape by default. TargetRegionVariableShape (const clang::ParenType * Paren) Construct a parentheses shape. TargetRegionVariableShape (const clang::VariableArrayType * Array, unsigned int DimIndex) Construct a shape for a variable array dimension. TargetRegionVariableShape (const clang::ConstantArrayType * Array) Construct a shape for a constant array dimension.","title":"Public Functions"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#private-attributes","text":"Name unsigned int VariableDimensionIndex std::string ConstantDimensionExpr ShapeKind Kind","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#detailed-description","text":"1 class TargetRegionVariableShape ; Describes the shape, i.e. a variable dimension of constant or variable size, or a pointer. We collect this information for every parameter of a target region function because the pretty printer does not support the output format for variable and types (e.g. it prints 'int ( )[SIZE] a' instead of 'int ( ) a[SIZE]'), so we print this manually in TargetCode.cpp . For this we need every pointer indirection and array dimension which each is saved as shapes for that variable.","title":"Detailed Description"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#enum-shapekind","text":"Enumerator Value Description Pointer Paren ConstantArray VariableArray","title":"enum ShapeKind"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-getkind","text":"1 inline ShapeKind getKind () const","title":"function getKind"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-isvariablearray","text":"1 inline bool isVariableArray () const","title":"function isVariableArray"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-isconstantarray","text":"1 inline bool isConstantArray () const","title":"function isConstantArray"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-isarray","text":"1 inline bool isArray () const","title":"function isArray"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-ispointer","text":"1 inline bool isPointer () const","title":"function isPointer"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-getvariabledimensionindex","text":"1 inline unsigned int getVariableDimensionIndex () const If the shape is a variable array, return the array dimension index, (used for generating __sotoc_vla_dimX_ parameters in which the host signals the array's size).","title":"function getVariableDimensionIndex"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-getconstantdimensionexpr","text":"1 inline llvm :: StringRef getConstantDimensionExpr () const If the shape is a constant array, it returns the rendered expression for the constant size.","title":"function getConstantDimensionExpr"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-targetregionvariableshape","text":"1 inline TargetRegionVariableShape () Construct a pointer shape by default.","title":"function TargetRegionVariableShape"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-targetregionvariableshape_1","text":"1 2 3 inline TargetRegionVariableShape ( const clang :: ParenType * Paren ) Construct a parentheses shape.","title":"function TargetRegionVariableShape"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-targetregionvariableshape_2","text":"1 2 3 4 inline TargetRegionVariableShape ( const clang :: VariableArrayType * Array , unsigned int DimIndex ) Construct a shape for a variable array dimension.","title":"function TargetRegionVariableShape"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#function-targetregionvariableshape_3","text":"1 2 3 inline TargetRegionVariableShape ( const clang :: ConstantArrayType * Array ) Construct a shape for a constant array dimension.","title":"function TargetRegionVariableShape"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#variable-variabledimensionindex","text":"1 unsigned int VariableDimensionIndex ;","title":"variable VariableDimensionIndex"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#variable-constantdimensionexpr","text":"1 std :: string ConstantDimensionExpr ;","title":"variable ConstantDimensionExpr"},{"location":"internal/doxygen/Classes/classTargetRegionVariableShape/#variable-kind","text":"1 ShapeKind Kind ;","title":"variable Kind"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/","text":"TargetRegionVariable::shape_const_kind_iterator Iterator which acts as a filter over std::vector ::const_iterator (the base_iter) which only passes on TargetRegionVariableShape of the kind specified in Kind . #include <TargetRegionVariable.h> Public Types Name using std::vector< TargetRegionVariableShape >::const_iterator base_iter using TargetRegionVariableShape value_type using const TargetRegionVariableShape & reference using const TargetRegionVariableShape * pointer using std::forward_iterator_tag iterator_category using std::ptrdiff_t difference_type using TargetRegionVariableShape::ShapeKind ShapeKind Public Functions Name shape_const_kind_iterator () shape_const_kind_iterator ( ShapeKind Kind, base_iter I) Explicitly constructs an iterator from the base_iter- Both the start and end of the iterator will be set to the same paramter I . shape_const_kind_iterator ( ShapeKind Kind, base_iter I, base_iter End) Explicitly constructs an iterator from cbegin() and cend() of base_iter. shape_const_kind_iterator & operator++ () shape_const_kind_iterator operator++ (int ) reference operator* () const pointer operator-> () Private Attributes Name base_iter It base_iter End TargetRegionVariableShape::ShapeKind Kind Friends Name bool operator== ( shape_const_kind_iterator X, shape_const_kind_iterator Y) bool operator!= ( shape_const_kind_iterator X, shape_const_kind_iterator Y) Public Types Documentation using base_iter 1 using TargetRegionVariable :: shape_const_kind_iterator :: base_iter = std :: vector < TargetRegionVariableShape >:: const_iterator ; using value_type 1 using TargetRegionVariable :: shape_const_kind_iterator :: value_type = TargetRegionVariableShape ; using reference 1 using TargetRegionVariable :: shape_const_kind_iterator :: reference = const TargetRegionVariableShape & ; using pointer 1 using TargetRegionVariable :: shape_const_kind_iterator :: pointer = const TargetRegionVariableShape * ; using iterator_category 1 using TargetRegionVariable :: shape_const_kind_iterator :: iterator_category = std :: forward_iterator_tag ; using difference_type 1 using TargetRegionVariable :: shape_const_kind_iterator :: difference_type = std :: ptrdiff_t ; using ShapeKind 1 using TargetRegionVariable :: shape_const_kind_iterator :: ShapeKind = TargetRegionVariableShape :: ShapeKind ; Public Functions Documentation function shape_const_kind_iterator 1 shape_const_kind_iterator () function shape_const_kind_iterator 1 2 3 4 inline explicit shape_const_kind_iterator ( ShapeKind Kind , base_iter I ) Explicitly constructs an iterator from the base_iter- Both the start and end of the iterator will be set to the same paramter I . Use this to construct an end() iterator from std::vector<>::cend(). function shape_const_kind_iterator 1 2 3 4 5 inline explicit shape_const_kind_iterator ( ShapeKind Kind , base_iter I , base_iter End ) Explicitly constructs an iterator from cbegin() and cend() of base_iter. Use this to construct a begin() from std::vector<>::cbegin() and std::vector<>::cend(). The iterator needs to operate on the base_iter at construction to ensure that a non-empty vector which does not contain elements of the right Kind is handled correctly. function operator++ 1 inline shape_const_kind_iterator & operator ++ () function operator++ 1 2 3 inline shape_const_kind_iterator operator ++ ( int ) function operator* 1 inline reference operator * () const function operator-> 1 inline pointer operator -> () Private Attributes Documentation variable It 1 base_iter It ; variable End 1 base_iter End ; variable Kind 1 TargetRegionVariableShape :: ShapeKind Kind ; Friends friend operator== 1 2 3 4 5 friend bool operator == ( shape_const_kind_iterator X , shape_const_kind_iterator Y ); friend operator!= 1 2 3 4 5 friend bool operator != ( shape_const_kind_iterator X , shape_const_kind_iterator Y );","title":"TargetRegionVariable::shape_const_kind_iterator"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#targetregionvariableshape_const_kind_iterator","text":"Iterator which acts as a filter over std::vector ::const_iterator (the base_iter) which only passes on TargetRegionVariableShape of the kind specified in Kind . #include <TargetRegionVariable.h>","title":"TargetRegionVariable::shape_const_kind_iterator"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#public-types","text":"Name using std::vector< TargetRegionVariableShape >::const_iterator base_iter using TargetRegionVariableShape value_type using const TargetRegionVariableShape & reference using const TargetRegionVariableShape * pointer using std::forward_iterator_tag iterator_category using std::ptrdiff_t difference_type using TargetRegionVariableShape::ShapeKind ShapeKind","title":"Public Types"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#public-functions","text":"Name shape_const_kind_iterator () shape_const_kind_iterator ( ShapeKind Kind, base_iter I) Explicitly constructs an iterator from the base_iter- Both the start and end of the iterator will be set to the same paramter I . shape_const_kind_iterator ( ShapeKind Kind, base_iter I, base_iter End) Explicitly constructs an iterator from cbegin() and cend() of base_iter. shape_const_kind_iterator & operator++ () shape_const_kind_iterator operator++ (int ) reference operator* () const pointer operator-> ()","title":"Public Functions"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#private-attributes","text":"Name base_iter It base_iter End TargetRegionVariableShape::ShapeKind Kind","title":"Private Attributes"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#friends","text":"Name bool operator== ( shape_const_kind_iterator X, shape_const_kind_iterator Y) bool operator!= ( shape_const_kind_iterator X, shape_const_kind_iterator Y)","title":"Friends"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#using-base_iter","text":"1 using TargetRegionVariable :: shape_const_kind_iterator :: base_iter = std :: vector < TargetRegionVariableShape >:: const_iterator ;","title":"using base_iter"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#using-value_type","text":"1 using TargetRegionVariable :: shape_const_kind_iterator :: value_type = TargetRegionVariableShape ;","title":"using value_type"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#using-reference","text":"1 using TargetRegionVariable :: shape_const_kind_iterator :: reference = const TargetRegionVariableShape & ;","title":"using reference"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#using-pointer","text":"1 using TargetRegionVariable :: shape_const_kind_iterator :: pointer = const TargetRegionVariableShape * ;","title":"using pointer"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#using-iterator_category","text":"1 using TargetRegionVariable :: shape_const_kind_iterator :: iterator_category = std :: forward_iterator_tag ;","title":"using iterator_category"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#using-difference_type","text":"1 using TargetRegionVariable :: shape_const_kind_iterator :: difference_type = std :: ptrdiff_t ;","title":"using difference_type"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#using-shapekind","text":"1 using TargetRegionVariable :: shape_const_kind_iterator :: ShapeKind = TargetRegionVariableShape :: ShapeKind ;","title":"using ShapeKind"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#function-shape_const_kind_iterator","text":"1 shape_const_kind_iterator ()","title":"function shape_const_kind_iterator"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#function-shape_const_kind_iterator_1","text":"1 2 3 4 inline explicit shape_const_kind_iterator ( ShapeKind Kind , base_iter I ) Explicitly constructs an iterator from the base_iter- Both the start and end of the iterator will be set to the same paramter I . Use this to construct an end() iterator from std::vector<>::cend().","title":"function shape_const_kind_iterator"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#function-shape_const_kind_iterator_2","text":"1 2 3 4 5 inline explicit shape_const_kind_iterator ( ShapeKind Kind , base_iter I , base_iter End ) Explicitly constructs an iterator from cbegin() and cend() of base_iter. Use this to construct a begin() from std::vector<>::cbegin() and std::vector<>::cend(). The iterator needs to operate on the base_iter at construction to ensure that a non-empty vector which does not contain elements of the right Kind is handled correctly.","title":"function shape_const_kind_iterator"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#function-operator","text":"1 inline shape_const_kind_iterator & operator ++ ()","title":"function operator++"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#function-operator_1","text":"1 2 3 inline shape_const_kind_iterator operator ++ ( int )","title":"function operator++"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#function-operator_2","text":"1 inline reference operator * () const","title":"function operator*"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#function-operator-","text":"1 inline pointer operator -> ()","title":"function operator-&gt;"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#private-attributes-documentation","text":"","title":"Private Attributes Documentation"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#variable-it","text":"1 base_iter It ;","title":"variable It"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#variable-end","text":"1 base_iter End ;","title":"variable End"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#variable-kind","text":"1 TargetRegionVariableShape :: ShapeKind Kind ;","title":"variable Kind"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#friends_1","text":"","title":"Friends"},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#friend-operator","text":"1 2 3 4 5 friend bool operator == ( shape_const_kind_iterator X , shape_const_kind_iterator Y );","title":"friend operator=="},{"location":"internal/doxygen/Classes/classTargetRegionVariable_1_1shape__const__kind__iterator/#friend-operator_1","text":"1 2 3 4 5 friend bool operator != ( shape_const_kind_iterator X , shape_const_kind_iterator Y );","title":"friend operator!="},{"location":"internal/doxygen/Classes/classTypeDeclResolver/","text":"TypeDeclResolver Implements DeclResolver for types (typedefs, structs enums) used in target regions. #include <DeclResolver.h> Inherits from DeclResolver Private Functions Name virtual void runOwnVisitor (clang::Decl * D, std::function< void(clang::Decl *Dep)> Fn) override With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. Additional inherited members Public Functions inherited from DeclResolver Name virtual ~DeclResolver () =0 void addDecl (clang::Decl * D) Records a Decl and automatically adds all Decls that this Decl depends on. void orderAndAddFragments ( TargetCode & TC) Creates a TargetCodeFragment for each recorded Decl and adds them to the TargetCode object in the correct order. Protected Functions inherited from DeclResolver Name virtual void findDependDecls (clang::Decl * D, std::unordered_set< clang::Decl * > & UnresolvedDecls) This function uses a visitor to find references to other declarations in the declaration being added. Private Functions inherited from DeclResolver Name void topoSort (std::stack< clang::Decl * > & q) This functions does a topological sorting on the dependency graph of all Decls recorded into this object by calling addDecl . void topoSortUtil (std::stack< clang::Decl * > & q, std::map< clang::Decl *, bool > & visited, clang::Decl * D) Helper function for topoSort , to do an recursive DFS. Private Attributes inherited from DeclResolver Name DeclMap AllDecls Records all declarations added to the resolver. std::set< clang::Decl * > NonDependentDecls All declarations which do not depend on other declarations. std::set< std::string > RequiredSystemHeaders When a declaration is inside a system header, that header is recorded here instead of the declaratoin. Private Functions Documentation function runOwnVisitor 1 2 3 4 virtual void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) override With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. Reimplements : DeclResolver::runOwnVisitor","title":"TypeDeclResolver"},{"location":"internal/doxygen/Classes/classTypeDeclResolver/#typedeclresolver","text":"Implements DeclResolver for types (typedefs, structs enums) used in target regions. #include <DeclResolver.h> Inherits from DeclResolver","title":"TypeDeclResolver"},{"location":"internal/doxygen/Classes/classTypeDeclResolver/#private-functions","text":"Name virtual void runOwnVisitor (clang::Decl * D, std::function< void(clang::Decl *Dep)> Fn) override With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver.","title":"Private Functions"},{"location":"internal/doxygen/Classes/classTypeDeclResolver/#additional-inherited-members","text":"Public Functions inherited from DeclResolver Name virtual ~DeclResolver () =0 void addDecl (clang::Decl * D) Records a Decl and automatically adds all Decls that this Decl depends on. void orderAndAddFragments ( TargetCode & TC) Creates a TargetCodeFragment for each recorded Decl and adds them to the TargetCode object in the correct order. Protected Functions inherited from DeclResolver Name virtual void findDependDecls (clang::Decl * D, std::unordered_set< clang::Decl * > & UnresolvedDecls) This function uses a visitor to find references to other declarations in the declaration being added. Private Functions inherited from DeclResolver Name void topoSort (std::stack< clang::Decl * > & q) This functions does a topological sorting on the dependency graph of all Decls recorded into this object by calling addDecl . void topoSortUtil (std::stack< clang::Decl * > & q, std::map< clang::Decl *, bool > & visited, clang::Decl * D) Helper function for topoSort , to do an recursive DFS. Private Attributes inherited from DeclResolver Name DeclMap AllDecls Records all declarations added to the resolver. std::set< clang::Decl * > NonDependentDecls All declarations which do not depend on other declarations. std::set< std::string > RequiredSystemHeaders When a declaration is inside a system header, that header is recorded here instead of the declaratoin.","title":"Additional inherited members"},{"location":"internal/doxygen/Classes/classTypeDeclResolver/#private-functions-documentation","text":"","title":"Private Functions Documentation"},{"location":"internal/doxygen/Classes/classTypeDeclResolver/#function-runownvisitor","text":"1 2 3 4 virtual void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) override With this function, the resolver runs a visitor on the declaration added to find and add all declarations that the added declaration depends on and adds them to the resolver. Reimplements : DeclResolver::runOwnVisitor","title":"function runOwnVisitor"},{"location":"internal/doxygen/Classes/index_classes/","text":"Classes class CollectOMPClauseParamsVarsVisitor OMP clause visitor. class CollectOMPClauseParamsVisitor OMP clause parameter visitor. struct DeclInfo Records information to resolve a single declaration, including if its declared in a system header and other declaration that this declaration depends on. class DeclResolver Records, orders and finds the dependencies of Decls (TypeDecls or FunctionDecls) class DiscoverFunctionsInDeclVisitor Traverses (parts of) the AST to find DeclRefExpr that refer to functions that need to be present for that part of the AST to compile correctly. class DiscoverTypesInDeclVisitor Traverses (parts of) the AST to find DeclRefExpr that refer to types that need to be present for that part of the AST to compile correctly. class FindArraySectionVisitor class FindDeclRefExprVisitor class FindLoopStmtVisitor class FindPrivateVariablesVisitor class FindTargetCodeVisitor Traverses the AST to find target and process target regions and function and variables that are annotated by an 'omp declare target' target pragma. class FunctionDeclResolver Implements DeclResolver for functions used in target regions. class OmpPragma A helper class to rewrite some \"pragma omp\" (mostly teams and similar combined constructs), which are not supported by sotoc. class SourceTransformAction class TargetCode A collection of all code from the input file that needs to be copied to the target source file. class TargetCodeDecl This class represents a declaration, i.e. class TargetCodeFragment An abstract base class for all fragments of the original code (except header includes) that need to be copied to our generated source code. class TargetCodeRegion Represents one target region. class TargetRegionPrinterHelper Print Helper Class. class TargetRegionTransformer class TargetRegionVariable Represents a variable captured by a target region. class shape_const_kind_iterator Iterator which acts as a filter over std::vector ::const_iterator (the base_iter) which only passes on TargetRegionVariableShape of the kind specified in Kind . class TargetRegionVariableShape Describes the shape, i.e. class TypeDeclResolver Implements DeclResolver for types (typedefs, structs enums) used in target regions. namespace clang namespace clang::tooling namespace llvm","title":"Classes"},{"location":"internal/doxygen/Classes/index_classes/#classes","text":"class CollectOMPClauseParamsVarsVisitor OMP clause visitor. class CollectOMPClauseParamsVisitor OMP clause parameter visitor. struct DeclInfo Records information to resolve a single declaration, including if its declared in a system header and other declaration that this declaration depends on. class DeclResolver Records, orders and finds the dependencies of Decls (TypeDecls or FunctionDecls) class DiscoverFunctionsInDeclVisitor Traverses (parts of) the AST to find DeclRefExpr that refer to functions that need to be present for that part of the AST to compile correctly. class DiscoverTypesInDeclVisitor Traverses (parts of) the AST to find DeclRefExpr that refer to types that need to be present for that part of the AST to compile correctly. class FindArraySectionVisitor class FindDeclRefExprVisitor class FindLoopStmtVisitor class FindPrivateVariablesVisitor class FindTargetCodeVisitor Traverses the AST to find target and process target regions and function and variables that are annotated by an 'omp declare target' target pragma. class FunctionDeclResolver Implements DeclResolver for functions used in target regions. class OmpPragma A helper class to rewrite some \"pragma omp\" (mostly teams and similar combined constructs), which are not supported by sotoc. class SourceTransformAction class TargetCode A collection of all code from the input file that needs to be copied to the target source file. class TargetCodeDecl This class represents a declaration, i.e. class TargetCodeFragment An abstract base class for all fragments of the original code (except header includes) that need to be copied to our generated source code. class TargetCodeRegion Represents one target region. class TargetRegionPrinterHelper Print Helper Class. class TargetRegionTransformer class TargetRegionVariable Represents a variable captured by a target region. class shape_const_kind_iterator Iterator which acts as a filter over std::vector ::const_iterator (the base_iter) which only passes on TargetRegionVariableShape of the kind specified in Kind . class TargetRegionVariableShape Describes the shape, i.e. class TypeDeclResolver Implements DeclResolver for types (typedefs, structs enums) used in target regions. namespace clang namespace clang::tooling namespace llvm","title":"Classes"},{"location":"internal/doxygen/Classes/structDeclInfo/","text":"DeclInfo Records information to resolve a single declaration, including if its declared in a system header and other declaration that this declaration depends on. #include <DeclResolver.h> Public Functions Name DeclInfo (clang::Decl * D, bool isFromSysHeader) Public Attributes Name const clang::Decl * Decl The declarations AST node itself. std::set< clang::Decl * > DeclDependencies All other declaration on which this declaration depends. bool IsFromSystemHeader Public Functions Documentation function DeclInfo 1 2 3 4 inline DeclInfo ( clang :: Decl * D , bool isFromSysHeader ) Public Attributes Documentation variable Decl 1 const clang :: Decl * Decl ; The declarations AST node itself. variable DeclDependencies 1 std :: set < clang :: Decl * > DeclDependencies ; All other declaration on which this declaration depends. variable IsFromSystemHeader 1 bool IsFromSystemHeader ;","title":"DeclInfo"},{"location":"internal/doxygen/Classes/structDeclInfo/#declinfo","text":"Records information to resolve a single declaration, including if its declared in a system header and other declaration that this declaration depends on. #include <DeclResolver.h>","title":"DeclInfo"},{"location":"internal/doxygen/Classes/structDeclInfo/#public-functions","text":"Name DeclInfo (clang::Decl * D, bool isFromSysHeader)","title":"Public Functions"},{"location":"internal/doxygen/Classes/structDeclInfo/#public-attributes","text":"Name const clang::Decl * Decl The declarations AST node itself. std::set< clang::Decl * > DeclDependencies All other declaration on which this declaration depends. bool IsFromSystemHeader","title":"Public Attributes"},{"location":"internal/doxygen/Classes/structDeclInfo/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"internal/doxygen/Classes/structDeclInfo/#function-declinfo","text":"1 2 3 4 inline DeclInfo ( clang :: Decl * D , bool isFromSysHeader )","title":"function DeclInfo"},{"location":"internal/doxygen/Classes/structDeclInfo/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"internal/doxygen/Classes/structDeclInfo/#variable-decl","text":"1 const clang :: Decl * Decl ; The declarations AST node itself.","title":"variable Decl"},{"location":"internal/doxygen/Classes/structDeclInfo/#variable-decldependencies","text":"1 std :: set < clang :: Decl * > DeclDependencies ; All other declaration on which this declaration depends.","title":"variable DeclDependencies"},{"location":"internal/doxygen/Classes/structDeclInfo/#variable-isfromsystemheader","text":"1 bool IsFromSystemHeader ;","title":"variable IsFromSystemHeader"},{"location":"internal/doxygen/Examples/index_examples/","text":"Examples","title":"Examples"},{"location":"internal/doxygen/Examples/index_examples/#examples","text":"","title":"Examples"},{"location":"internal/doxygen/Files/Debug_8h/","text":"src/Debug.h This file defines a debug macro for sotoc. Defines Name DEBUGP (...) DEBUGPDECL (...) Macros Documentation define DEBUGP 1 2 3 4 #define DEBUGP( ... ) {} define DEBUGPDECL 1 2 3 4 #define DEBUGPDECL( ... ) {} Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //===-- sotoc/src/main.cpp ------------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #pragma once #include \"llvm/Support/FormatVariadic.h\" #include \"llvm/Support/raw_ostream.h\" #ifdef SOTOC_DEBUG extern int SotocDebugLevel ; #define DEBUGP(...) \\ do { \\ if (SotocDebugLevel > 0) { \\ llvm::errs() << \"Sotoc: \" << __VA_ARGS__; \\ llvm::errs() << \"\\n\"; \\ } \\ } while (false) #define DEBUGPDECL(decl, ...) \\ do { \\ if (SotocDebugLevel > 0) { \\ llvm::errs() << \"Sotoc: \" << llvm::formatv(__VA_ARGS__); \\ decl->print(llvm::errs()); \\ llvm::errs() << \"\\n\"; \\ } \\ } while (false) #else // OMPTARGET_DEBUG #define DEBUGP(...) \\ {} #define DEBUGPDECL(...) \\ {} #endif // OMPTARGET_DEBUG","title":"src/Debug.h"},{"location":"internal/doxygen/Files/Debug_8h/#srcdebugh","text":"This file defines a debug macro for sotoc.","title":"src/Debug.h"},{"location":"internal/doxygen/Files/Debug_8h/#defines","text":"Name DEBUGP (...) DEBUGPDECL (...)","title":"Defines"},{"location":"internal/doxygen/Files/Debug_8h/#macros-documentation","text":"","title":"Macros Documentation"},{"location":"internal/doxygen/Files/Debug_8h/#define-debugp","text":"1 2 3 4 #define DEBUGP( ... ) {}","title":"define DEBUGP"},{"location":"internal/doxygen/Files/Debug_8h/#define-debugpdecl","text":"1 2 3 4 #define DEBUGPDECL( ... ) {}","title":"define DEBUGPDECL"},{"location":"internal/doxygen/Files/Debug_8h/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //===-- sotoc/src/main.cpp ------------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #pragma once #include \"llvm/Support/FormatVariadic.h\" #include \"llvm/Support/raw_ostream.h\" #ifdef SOTOC_DEBUG extern int SotocDebugLevel ; #define DEBUGP(...) \\ do { \\ if (SotocDebugLevel > 0) { \\ llvm::errs() << \"Sotoc: \" << __VA_ARGS__; \\ llvm::errs() << \"\\n\"; \\ } \\ } while (false) #define DEBUGPDECL(decl, ...) \\ do { \\ if (SotocDebugLevel > 0) { \\ llvm::errs() << \"Sotoc: \" << llvm::formatv(__VA_ARGS__); \\ decl->print(llvm::errs()); \\ llvm::errs() << \"\\n\"; \\ } \\ } while (false) #else // OMPTARGET_DEBUG #define DEBUGP(...) \\ {} #define DEBUGPDECL(...) \\ {} #endif // OMPTARGET_DEBUG","title":"Source code"},{"location":"internal/doxygen/Files/DeclResolver_8cpp/","text":"src/DeclResolver.cpp This file implements the class DeclResolver . Functions Name bool isHeaderOpenMPHeader (llvm::StringRef header_path) bool isDeclInOpenMPHeader (clang::Decl * D) llvm::Optional< std::string > getSystemHeaderForDecl (clang::Decl * D) Functions Documentation function isHeaderOpenMPHeader 1 2 3 static bool isHeaderOpenMPHeader ( llvm :: StringRef header_path ) function isDeclInOpenMPHeader 1 2 3 static bool isDeclInOpenMPHeader ( clang :: Decl * D ) function getSystemHeaderForDecl 1 2 3 static llvm :: Optional < std :: string > getSystemHeaderForDecl ( clang :: Decl * D ) Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 //===-- sotoc/src/TargetDeclResolver.cpp ----------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include <memory> #include \"clang/AST/Decl.h\" #include \"Debug.h\" #include \"DeclResolver.h\" #include \"TargetCode.h\" #include \"TargetCodeFragment.h\" #include \"Visitors.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Basic/FileManager.h\" static bool isHeaderOpenMPHeader ( llvm :: StringRef header_path ) { if ( header_path . substr ( header_path . find_last_of ( \"/ \\\\ \" ) + 1 ) == \"omp.h\" ) { return true ; } return false ; } static bool isDeclInOpenMPHeader ( clang :: Decl * D ) { // if a Decl is exposed by omp.h, that means omp.h is somewhere on the include // stack, we want to include omp.h and not copy any decl. This is an issue // because omp.h may not be a system header clang :: SourceManager & SM = D -> getASTContext (). getSourceManager (); auto IncludedFile = SM . getFileID ( D -> getBeginLoc ()); auto SLocEntry = SM . getSLocEntry ( IncludedFile ); if ( SLocEntry . isExpansion ()) { IncludedFile = SM . getFileID ( SLocEntry . getExpansion (). getSpellingLoc ()); } auto IncludingFile = SM . getDecomposedIncludedLoc ( IncludedFile ); DEBUGPDECL ( D , \"Check if is in OpenMP header: \" ); while ( IncludedFile != SM . getMainFileID ()) { if ( isHeaderOpenMPHeader ( SM . getFileEntryForID ( IncludedFile ) -> getName ())) { return true ; } IncludedFile = IncludingFile . first ; IncludingFile = SM . getDecomposedIncludedLoc ( IncludedFile ); } return false ; } static llvm :: Optional < std :: string > getSystemHeaderForDecl ( clang :: Decl * D ) { clang :: SourceManager & SM = D -> getASTContext (). getSourceManager (); DEBUGPDECL ( D , \"Get system header for Decl: \" ); if ( ! SM . isInSystemHeader ( D -> getBeginLoc ())) { return llvm :: Optional < std :: string > (); } // we dont want to include the original system header in which D was // declared, but the system header which exposes D to the user's file // (the last system header in the include stack) auto IncludedFile = SM . getFileID ( D -> getBeginLoc ()); // Fix for problems with math.h // If our declaration is really a macro expansion, we need to find the actual // spelling location first. auto SLocEntry = SM . getSLocEntry ( IncludedFile ); if ( SLocEntry . isExpansion ()) { IncludedFile = SM . getFileID ( SLocEntry . getExpansion (). getSpellingLoc ()); } auto IncludingFile = SM . getDecomposedIncludedLoc ( IncludedFile ); while ( SM . isInSystemHeader ( SM . getLocForStartOfFile ( IncludingFile . first )) && ! isHeaderOpenMPHeader ( SM . getFileEntryForID ( IncludingFile . first ) -> getName ())) { IncludedFile = IncludingFile . first ; IncludingFile = SM . getDecomposedIncludedLoc ( IncludedFile ); } return llvm :: Optional < std :: string > ( std :: string ( SM . getFilename ( SM . getLocForStartOfFile ( IncludedFile )))); } DeclResolver ::~ DeclResolver () {} void DeclResolver :: addDecl ( clang :: Decl * D ) { if ( D -> isImplicit () || AllDecls . count ( D ) != 0 ) { // we have already resolved this Decl return ; } DEBUGPDECL ( D , \"Add declaration to resolver: \" ); std :: unordered_set < clang :: Decl *> UnresolvedDecls ; UnresolvedDecls . insert ( D ); while ( ! UnresolvedDecls . empty ()) { auto ResolveDeclIter = UnresolvedDecls . begin (); clang :: Decl * ResolveDecl = * ResolveDeclIter ; auto Header = getSystemHeaderForDecl ( ResolveDecl ); if ( Header . hasValue ()) { // The Decl is inside a system header, so it does not depend on // any other declaration. So we add the Decl and then we are // finished AllDecls . emplace ( std :: make_pair ( ResolveDecl , DeclInfo ( ResolveDecl , true ))); RequiredSystemHeaders . insert ( Header . getValue ()); NonDependentDecls . insert ( ResolveDecl ); } else if ( isDeclInOpenMPHeader ( D )) { // TODO: this is basically a workaround for omp.h decls to not get copied AllDecls . emplace ( std :: make_pair ( ResolveDecl , DeclInfo ( ResolveDecl , true ))); RequiredSystemHeaders . insert ( \"include/omp.h\" ); NonDependentDecls . insert ( ResolveDecl ); } else { // Add our decl if we haven't already if ( ! AllDecls . count ( ResolveDecl )) { AllDecls . emplace ( std :: make_pair ( ResolveDecl , DeclInfo ( ResolveDecl , false ))); } // This Decl may have other Decls that is depends on. // Add Decl if we haven't already findDependDecls ( ResolveDecl , UnresolvedDecls ); } UnresolvedDecls . erase ( ResolveDeclIter ); } } void DeclResolver :: findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl *> & UnresolvedDecls ) { // Construct a visitor which searches through the Decl D for references to // other decls, because we need to add those too or our target code may not // compile. runOwnVisitor ( D , [ & D , & UnresolvedDecls , this ]( clang :: Decl * Dep ) { if ( ! this -> AllDecls . count ( Dep )) { DEBUGPDECL ( Dep , \"Found referred decl: \" ); UnresolvedDecls . insert ( Dep ); } // Fix for enums. TODO: find a better way to avoid duplicates if ( D != Dep ) { this -> AllDecls . at ( D ). DeclDependencies . insert ( Dep ); } }); } void DeclResolver :: topoSortUtil ( std :: stack < clang :: Decl *> & q , std :: map < clang :: Decl * , bool > & visited , clang :: Decl * D ) { visited [ D ] = true ; for ( auto DepDecl : AllDecls . at ( D ). DeclDependencies ) { if ( ! visited [ DepDecl ]) { topoSortUtil ( q , visited , DepDecl ); } } q . push ( D ); } void DeclResolver :: topoSort ( std :: stack < clang :: Decl *> & q ) { // Previously we used Kuhn's algorithm to make the topo sort. However, // since we now also need to do the same thing for functions, and not just // for types anymore, and functions can be forward-declared, we may need // to deal with cycles in our dependency graph. // the default constructor value for bool is 'false' (TIL), so we can // safely use operator[] on `visited` std :: map < clang :: Decl * , bool > visited ; for ( auto & DeclEntry : AllDecls ) { if ( ! visited [ DeclEntry . first ]) { topoSortUtil ( q , visited , DeclEntry . first ); } } } void DeclResolver :: orderAndAddFragments ( TargetCode & TC ) { for ( auto & Header : RequiredSystemHeaders ) { TC . addHeader ( Header ); } std :: stack < clang :: Decl *> orderStack ; topoSort ( orderStack ); while ( ! orderStack . empty ()) { if ( ! AllDecls . at ( orderStack . top ()). IsFromSystemHeader ) { auto codeDecl = std :: make_shared < TargetCodeDecl > ( orderStack . top ()); DEBUGPDECL ( orderStack . top (), \"Generating Fragment for Decl: \" ); // TODO: this wont hurt but is not always necessary codeDecl -> NeedsSemicolon = true ; bool added = TC . addCodeFragmentFront ( codeDecl ); DEBUGP ( \"Decl was a duplicate: \" << ! added ); } orderStack . pop (); } } void TypeDeclResolver :: runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) { DiscoverTypesInDeclVisitor Visitor ( Fn ); Visitor . TraverseDecl ( D ); } void FunctionDeclResolver :: runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) { DEBUGPDECL ( D , \"Searching for referred decls in function \" ); DiscoverFunctionsInDeclVisitor Visitor ( Fn ); Visitor . TraverseDecl ( D ); } void FunctionDeclResolver :: findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl *> & UnresolvedDecls ) { this -> DeclResolver :: findDependDecls ( D , UnresolvedDecls ); DiscoverTypesInDeclVisitor TypesVisitor ( Types ); TypesVisitor . TraverseDecl ( D ); }","title":"src/DeclResolver.cpp"},{"location":"internal/doxygen/Files/DeclResolver_8cpp/#srcdeclresolvercpp","text":"This file implements the class DeclResolver .","title":"src/DeclResolver.cpp"},{"location":"internal/doxygen/Files/DeclResolver_8cpp/#functions","text":"Name bool isHeaderOpenMPHeader (llvm::StringRef header_path) bool isDeclInOpenMPHeader (clang::Decl * D) llvm::Optional< std::string > getSystemHeaderForDecl (clang::Decl * D)","title":"Functions"},{"location":"internal/doxygen/Files/DeclResolver_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"internal/doxygen/Files/DeclResolver_8cpp/#function-isheaderopenmpheader","text":"1 2 3 static bool isHeaderOpenMPHeader ( llvm :: StringRef header_path )","title":"function isHeaderOpenMPHeader"},{"location":"internal/doxygen/Files/DeclResolver_8cpp/#function-isdeclinopenmpheader","text":"1 2 3 static bool isDeclInOpenMPHeader ( clang :: Decl * D )","title":"function isDeclInOpenMPHeader"},{"location":"internal/doxygen/Files/DeclResolver_8cpp/#function-getsystemheaderfordecl","text":"1 2 3 static llvm :: Optional < std :: string > getSystemHeaderForDecl ( clang :: Decl * D )","title":"function getSystemHeaderForDecl"},{"location":"internal/doxygen/Files/DeclResolver_8cpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 //===-- sotoc/src/TargetDeclResolver.cpp ----------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include <memory> #include \"clang/AST/Decl.h\" #include \"Debug.h\" #include \"DeclResolver.h\" #include \"TargetCode.h\" #include \"TargetCodeFragment.h\" #include \"Visitors.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Basic/FileManager.h\" static bool isHeaderOpenMPHeader ( llvm :: StringRef header_path ) { if ( header_path . substr ( header_path . find_last_of ( \"/ \\\\ \" ) + 1 ) == \"omp.h\" ) { return true ; } return false ; } static bool isDeclInOpenMPHeader ( clang :: Decl * D ) { // if a Decl is exposed by omp.h, that means omp.h is somewhere on the include // stack, we want to include omp.h and not copy any decl. This is an issue // because omp.h may not be a system header clang :: SourceManager & SM = D -> getASTContext (). getSourceManager (); auto IncludedFile = SM . getFileID ( D -> getBeginLoc ()); auto SLocEntry = SM . getSLocEntry ( IncludedFile ); if ( SLocEntry . isExpansion ()) { IncludedFile = SM . getFileID ( SLocEntry . getExpansion (). getSpellingLoc ()); } auto IncludingFile = SM . getDecomposedIncludedLoc ( IncludedFile ); DEBUGPDECL ( D , \"Check if is in OpenMP header: \" ); while ( IncludedFile != SM . getMainFileID ()) { if ( isHeaderOpenMPHeader ( SM . getFileEntryForID ( IncludedFile ) -> getName ())) { return true ; } IncludedFile = IncludingFile . first ; IncludingFile = SM . getDecomposedIncludedLoc ( IncludedFile ); } return false ; } static llvm :: Optional < std :: string > getSystemHeaderForDecl ( clang :: Decl * D ) { clang :: SourceManager & SM = D -> getASTContext (). getSourceManager (); DEBUGPDECL ( D , \"Get system header for Decl: \" ); if ( ! SM . isInSystemHeader ( D -> getBeginLoc ())) { return llvm :: Optional < std :: string > (); } // we dont want to include the original system header in which D was // declared, but the system header which exposes D to the user's file // (the last system header in the include stack) auto IncludedFile = SM . getFileID ( D -> getBeginLoc ()); // Fix for problems with math.h // If our declaration is really a macro expansion, we need to find the actual // spelling location first. auto SLocEntry = SM . getSLocEntry ( IncludedFile ); if ( SLocEntry . isExpansion ()) { IncludedFile = SM . getFileID ( SLocEntry . getExpansion (). getSpellingLoc ()); } auto IncludingFile = SM . getDecomposedIncludedLoc ( IncludedFile ); while ( SM . isInSystemHeader ( SM . getLocForStartOfFile ( IncludingFile . first )) && ! isHeaderOpenMPHeader ( SM . getFileEntryForID ( IncludingFile . first ) -> getName ())) { IncludedFile = IncludingFile . first ; IncludingFile = SM . getDecomposedIncludedLoc ( IncludedFile ); } return llvm :: Optional < std :: string > ( std :: string ( SM . getFilename ( SM . getLocForStartOfFile ( IncludedFile )))); } DeclResolver ::~ DeclResolver () {} void DeclResolver :: addDecl ( clang :: Decl * D ) { if ( D -> isImplicit () || AllDecls . count ( D ) != 0 ) { // we have already resolved this Decl return ; } DEBUGPDECL ( D , \"Add declaration to resolver: \" ); std :: unordered_set < clang :: Decl *> UnresolvedDecls ; UnresolvedDecls . insert ( D ); while ( ! UnresolvedDecls . empty ()) { auto ResolveDeclIter = UnresolvedDecls . begin (); clang :: Decl * ResolveDecl = * ResolveDeclIter ; auto Header = getSystemHeaderForDecl ( ResolveDecl ); if ( Header . hasValue ()) { // The Decl is inside a system header, so it does not depend on // any other declaration. So we add the Decl and then we are // finished AllDecls . emplace ( std :: make_pair ( ResolveDecl , DeclInfo ( ResolveDecl , true ))); RequiredSystemHeaders . insert ( Header . getValue ()); NonDependentDecls . insert ( ResolveDecl ); } else if ( isDeclInOpenMPHeader ( D )) { // TODO: this is basically a workaround for omp.h decls to not get copied AllDecls . emplace ( std :: make_pair ( ResolveDecl , DeclInfo ( ResolveDecl , true ))); RequiredSystemHeaders . insert ( \"include/omp.h\" ); NonDependentDecls . insert ( ResolveDecl ); } else { // Add our decl if we haven't already if ( ! AllDecls . count ( ResolveDecl )) { AllDecls . emplace ( std :: make_pair ( ResolveDecl , DeclInfo ( ResolveDecl , false ))); } // This Decl may have other Decls that is depends on. // Add Decl if we haven't already findDependDecls ( ResolveDecl , UnresolvedDecls ); } UnresolvedDecls . erase ( ResolveDeclIter ); } } void DeclResolver :: findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl *> & UnresolvedDecls ) { // Construct a visitor which searches through the Decl D for references to // other decls, because we need to add those too or our target code may not // compile. runOwnVisitor ( D , [ & D , & UnresolvedDecls , this ]( clang :: Decl * Dep ) { if ( ! this -> AllDecls . count ( Dep )) { DEBUGPDECL ( Dep , \"Found referred decl: \" ); UnresolvedDecls . insert ( Dep ); } // Fix for enums. TODO: find a better way to avoid duplicates if ( D != Dep ) { this -> AllDecls . at ( D ). DeclDependencies . insert ( Dep ); } }); } void DeclResolver :: topoSortUtil ( std :: stack < clang :: Decl *> & q , std :: map < clang :: Decl * , bool > & visited , clang :: Decl * D ) { visited [ D ] = true ; for ( auto DepDecl : AllDecls . at ( D ). DeclDependencies ) { if ( ! visited [ DepDecl ]) { topoSortUtil ( q , visited , DepDecl ); } } q . push ( D ); } void DeclResolver :: topoSort ( std :: stack < clang :: Decl *> & q ) { // Previously we used Kuhn's algorithm to make the topo sort. However, // since we now also need to do the same thing for functions, and not just // for types anymore, and functions can be forward-declared, we may need // to deal with cycles in our dependency graph. // the default constructor value for bool is 'false' (TIL), so we can // safely use operator[] on `visited` std :: map < clang :: Decl * , bool > visited ; for ( auto & DeclEntry : AllDecls ) { if ( ! visited [ DeclEntry . first ]) { topoSortUtil ( q , visited , DeclEntry . first ); } } } void DeclResolver :: orderAndAddFragments ( TargetCode & TC ) { for ( auto & Header : RequiredSystemHeaders ) { TC . addHeader ( Header ); } std :: stack < clang :: Decl *> orderStack ; topoSort ( orderStack ); while ( ! orderStack . empty ()) { if ( ! AllDecls . at ( orderStack . top ()). IsFromSystemHeader ) { auto codeDecl = std :: make_shared < TargetCodeDecl > ( orderStack . top ()); DEBUGPDECL ( orderStack . top (), \"Generating Fragment for Decl: \" ); // TODO: this wont hurt but is not always necessary codeDecl -> NeedsSemicolon = true ; bool added = TC . addCodeFragmentFront ( codeDecl ); DEBUGP ( \"Decl was a duplicate: \" << ! added ); } orderStack . pop (); } } void TypeDeclResolver :: runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) { DiscoverTypesInDeclVisitor Visitor ( Fn ); Visitor . TraverseDecl ( D ); } void FunctionDeclResolver :: runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) { DEBUGPDECL ( D , \"Searching for referred decls in function \" ); DiscoverFunctionsInDeclVisitor Visitor ( Fn ); Visitor . TraverseDecl ( D ); } void FunctionDeclResolver :: findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl *> & UnresolvedDecls ) { this -> DeclResolver :: findDependDecls ( D , UnresolvedDecls ); DiscoverTypesInDeclVisitor TypesVisitor ( Types ); TypesVisitor . TraverseDecl ( D ); }","title":"Source code"},{"location":"internal/doxygen/Files/DeclResolver_8h/","text":"src/DeclResolver.h This file implements the class DeclResolver which is used to record and order types and functions in the input code that are required by the target regions. Namespaces Name clang Classes Name struct DeclInfo Records information to resolve a single declaration, including if its declared in a system header and other declaration that this declaration depends on. class DeclResolver Records, orders and finds the dependencies of Decls (TypeDecls or FunctionDecls) class TypeDeclResolver Implements DeclResolver for types (typedefs, structs enums) used in target regions. class FunctionDeclResolver Implements DeclResolver for functions used in target regions. Types Name using std::map< clang::Decl *, DeclInfo > DeclMap Functions Name llvm::Optional< std::string > getSystemHeaderForDecl (const clang::Decl * D) Types Documentation using DeclMap 1 using DeclMap = std :: map < clang :: Decl * , DeclInfo > ; Functions Documentation function getSystemHeaderForDecl 1 2 3 llvm :: Optional < std :: string > getSystemHeaderForDecl ( const clang :: Decl * D ) Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 //===-- sotoc/src/DeclResolver.h -----------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #pragma once #include <map> #include <set> #include <stack> #include <unordered_set> llvm :: Optional < std :: string > getSystemHeaderForDecl ( const clang :: Decl * D ); namespace clang { class Decl ; } class TargetCode ; struct DeclInfo { const clang :: Decl * Decl ; std :: set < clang :: Decl *> DeclDependencies ; // std::set<clang::Decl *> ForwardDecls; // for the moment we solve this // differently bool IsFromSystemHeader ; DeclInfo ( clang :: Decl * D , bool isFromSysHeader ) : Decl ( D ), IsFromSystemHeader ( isFromSysHeader ){}; }; using DeclMap = std :: map < clang :: Decl * , DeclInfo > ; class DeclResolver { DeclMap AllDecls ; std :: set < clang :: Decl *> NonDependentDecls ; std :: set < std :: string > RequiredSystemHeaders ; public : virtual ~ DeclResolver () = 0 ; void addDecl ( clang :: Decl * D ); void orderAndAddFragments ( TargetCode & TC ); protected : virtual void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) = 0 ; virtual void findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl *> & UnresolvedDecls ); private : void topoSort ( std :: stack < clang :: Decl *> & q ); void topoSortUtil ( std :: stack < clang :: Decl *> & q , std :: map < clang :: Decl * , bool > & visited , clang :: Decl * D ); }; class TypeDeclResolver : public DeclResolver { private : void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) override ; }; class FunctionDeclResolver : public DeclResolver { TypeDeclResolver & Types ; public : FunctionDeclResolver ( TypeDeclResolver & Types ) : Types ( Types ){}; private : void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) override ; void findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl *> & UnresolvedDecls ) override ; };","title":"src/DeclResolver.h"},{"location":"internal/doxygen/Files/DeclResolver_8h/#srcdeclresolverh","text":"This file implements the class DeclResolver which is used to record and order types and functions in the input code that are required by the target regions.","title":"src/DeclResolver.h"},{"location":"internal/doxygen/Files/DeclResolver_8h/#namespaces","text":"Name clang","title":"Namespaces"},{"location":"internal/doxygen/Files/DeclResolver_8h/#classes","text":"Name struct DeclInfo Records information to resolve a single declaration, including if its declared in a system header and other declaration that this declaration depends on. class DeclResolver Records, orders and finds the dependencies of Decls (TypeDecls or FunctionDecls) class TypeDeclResolver Implements DeclResolver for types (typedefs, structs enums) used in target regions. class FunctionDeclResolver Implements DeclResolver for functions used in target regions.","title":"Classes"},{"location":"internal/doxygen/Files/DeclResolver_8h/#types","text":"Name using std::map< clang::Decl *, DeclInfo > DeclMap","title":"Types"},{"location":"internal/doxygen/Files/DeclResolver_8h/#functions","text":"Name llvm::Optional< std::string > getSystemHeaderForDecl (const clang::Decl * D)","title":"Functions"},{"location":"internal/doxygen/Files/DeclResolver_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"internal/doxygen/Files/DeclResolver_8h/#using-declmap","text":"1 using DeclMap = std :: map < clang :: Decl * , DeclInfo > ;","title":"using DeclMap"},{"location":"internal/doxygen/Files/DeclResolver_8h/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"internal/doxygen/Files/DeclResolver_8h/#function-getsystemheaderfordecl","text":"1 2 3 llvm :: Optional < std :: string > getSystemHeaderForDecl ( const clang :: Decl * D )","title":"function getSystemHeaderForDecl"},{"location":"internal/doxygen/Files/DeclResolver_8h/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 //===-- sotoc/src/DeclResolver.h -----------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #pragma once #include <map> #include <set> #include <stack> #include <unordered_set> llvm :: Optional < std :: string > getSystemHeaderForDecl ( const clang :: Decl * D ); namespace clang { class Decl ; } class TargetCode ; struct DeclInfo { const clang :: Decl * Decl ; std :: set < clang :: Decl *> DeclDependencies ; // std::set<clang::Decl *> ForwardDecls; // for the moment we solve this // differently bool IsFromSystemHeader ; DeclInfo ( clang :: Decl * D , bool isFromSysHeader ) : Decl ( D ), IsFromSystemHeader ( isFromSysHeader ){}; }; using DeclMap = std :: map < clang :: Decl * , DeclInfo > ; class DeclResolver { DeclMap AllDecls ; std :: set < clang :: Decl *> NonDependentDecls ; std :: set < std :: string > RequiredSystemHeaders ; public : virtual ~ DeclResolver () = 0 ; void addDecl ( clang :: Decl * D ); void orderAndAddFragments ( TargetCode & TC ); protected : virtual void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) = 0 ; virtual void findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl *> & UnresolvedDecls ); private : void topoSort ( std :: stack < clang :: Decl *> & q ); void topoSortUtil ( std :: stack < clang :: Decl *> & q , std :: map < clang :: Decl * , bool > & visited , clang :: Decl * D ); }; class TypeDeclResolver : public DeclResolver { private : void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) override ; }; class FunctionDeclResolver : public DeclResolver { TypeDeclResolver & Types ; public : FunctionDeclResolver ( TypeDeclResolver & Types ) : Types ( Types ){}; private : void runOwnVisitor ( clang :: Decl * D , std :: function < void ( clang :: Decl * Dep ) > Fn ) override ; void findDependDecls ( clang :: Decl * D , std :: unordered_set < clang :: Decl *> & UnresolvedDecls ) override ; };","title":"Source code"},{"location":"internal/doxygen/Files/OmpPragma_8cpp/","text":"src/OmpPragma.cpp This file implements the class OmpPragma , which is used to generate repla- cement pragmas for teams and team combined constructs. Attributes Name int ClauseParamCounter Attributes Documentation variable ClauseParamCounter 1 int ClauseParamCounter = -1 ; Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 //===-- sotoc/src/TargetCode ------------------------ ---------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \"clang/AST/PrettyPrinter.h\" #include <ctype.h> #include \"OmpPragma.h\" int ClauseParamCounter = -1 ; void OmpPragma::printReplacement ( llvm :: raw_ostream & Out ) { switch ( Kind ) { case clang :: OpenMPDirectiveKind :: OMPD_target_parallel : { Out << \" #pragma omp parallel \" ; break ; } case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_parallel_for : case clang :: OpenMPDirectiveKind :: OMPD_target_parallel_for : { Out << \" #pragma omp parallel for \" ; break ; } case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_parallel_for_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_parallel_for_simd : { Out << \" #pragma _NEC ivdep \\n #pragma omp parallel for simd \" ; break ; } case clang :: OpenMPDirectiveKind :: OMPD_distribute_simd : case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_simd : { Out << \" #pragma _NEC ivdep \\n #pragma omp simd \" ; break ; } case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_parallel_for : { Out << \" #pragma omp parallel for \" ; break ; } case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_parallel_for_simd : { Out << \" #pragma _NEC ivdep \\n #pragma omp parallel for simd \" ; break ; } default : return ; } printClauses ( Out ); } //TODO: Do we need this? void OmpPragma::printAddition ( llvm :: raw_ostream & Out ) { Out << \" #pragma _NEC ivdep \" ; } bool OmpPragma::isReplaceable ( clang :: OMPExecutableDirective * Directive ) { if ( llvm :: isa < clang :: OMPTeamsDirective > ( Directive ) || llvm :: isa < clang :: OMPTeamsDistributeDirective > ( Directive ) || llvm :: isa < clang :: OMPTeamsDistributeSimdDirective > ( Directive ) || llvm :: isa < clang :: OMPTeamsDistributeParallelForDirective > ( Directive ) || llvm :: isa < clang :: OMPTeamsDistributeParallelForSimdDirective > ( Directive ) || llvm :: isa < clang :: OMPDistributeDirective > ( Directive )) { return true ; } return false ; } bool OmpPragma::needsAdditionalPragma ( clang :: OMPExecutableDirective * Directive ) { if ( llvm :: isa < clang :: OMPForSimdDirective > ( Directive ) || llvm :: isa < clang :: OMPParallelForSimdDirective > ( Directive ) || llvm :: isa < clang :: OMPSimdDirective > ( Directive ) || llvm :: isa < clang :: OMPTaskLoopSimdDirective > ( Directive )) { return true ; } return false ; } bool OmpPragma::isClausePrintable ( clang :: OMPClause * Clause ) { switch ( Kind ) { case clang :: OpenMPDirectiveKind :: OMPD_target : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_if: // case clang::OpenMPClauseKind::OMPC_device: // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_private : // case clang::OpenMPClauseKind::OMPC_nowait: // case clang::OpenMPClauseKind::OMPC_depend: // case clang::OpenMPClauseKind::OMPC_defaultmap: case clang :: OpenMPClauseKind :: OMPC_firstprivate : // case clang::OpenMPClauseKind::OMPC_is_device_ptr: // case clang::OpenMPClauseKind::OMPC_reduction: return true ; default : return false ; } } /*case clang::OpenMPDirectiveKind::OMPD_target_teams: { switch (Clause->getClauseKind()) { // case clang::OpenMPClauseKind::OMPC_map: case clang::OpenMPClauseKind::OMPC_default: case clang::OpenMPClauseKind::OMPC_private: case clang::OpenMPClauseKind::OMPC_firstprivate: case clang::OpenMPClauseKind::OMPC_shared: case clang::OpenMPClauseKind::OMPC_reduction: case clang::OpenMPClauseKind::OMPC_num_teams: case clang::OpenMPClauseKind::OMPC_thread_limit: return true; default: return false; } }*/ case clang :: OpenMPDirectiveKind :: OMPD_target_parallel : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_num_threads : case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_proc_bind : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_shared : // case clang::OpenMPClauseKind::OMPC_reduction: return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } case clang :: OpenMPDirectiveKind :: OMPD_target_parallel_for : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_num_threads : case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_proc_bind : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_schedule : case clang :: OpenMPClauseKind :: OMPC_ordered : case clang :: OpenMPClauseKind :: OMPC_linear : return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } case clang :: OpenMPDirectiveKind :: OMPD_target_parallel_for_simd : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_num_threads : case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_proc_bind : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_schedule : case clang :: OpenMPClauseKind :: OMPC_safelen : case clang :: OpenMPClauseKind :: OMPC_simdlen : case clang :: OpenMPClauseKind :: OMPC_linear : case clang :: OpenMPClauseKind :: OMPC_aligned : case clang :: OpenMPClauseKind :: OMPC_ordered : return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } case clang :: OpenMPDirectiveKind :: OMPD_target_simd : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_linear : case clang :: OpenMPClauseKind :: OMPC_aligned : case clang :: OpenMPClauseKind :: OMPC_safelen : case clang :: OpenMPClauseKind :: OMPC_simdlen : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_reduction : return true ; default : return false ; } } case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_thread_limit : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_dist_schedule : return true ; default : return false ; } } case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_parallel_for : case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_parallel_for : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_dist_schedule : case clang :: OpenMPClauseKind :: OMPC_num_threads : case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_proc_bind : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_schedule : case clang :: OpenMPClauseKind :: OMPC_thread_limit : return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_parallel_for_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_parallel_for_simd : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_dist_schedule : case clang :: OpenMPClauseKind :: OMPC_num_threads : case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_proc_bind : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_schedule : case clang :: OpenMPClauseKind :: OMPC_linear : case clang :: OpenMPClauseKind :: OMPC_aligned : case clang :: OpenMPClauseKind :: OMPC_safelen : case clang :: OpenMPClauseKind :: OMPC_simdlen : case clang :: OpenMPClauseKind :: OMPC_thread_limit : return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_simd : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_thread_limit : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_dist_schedule : case clang :: OpenMPClauseKind :: OMPC_linear : case clang :: OpenMPClauseKind :: OMPC_aligned : case clang :: OpenMPClauseKind :: OMPC_safelen : case clang :: OpenMPClauseKind :: OMPC_simdlen : return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } default : break ; } return false ; } void OmpPragma::printClauses ( llvm :: raw_ostream & Out ) { std :: string InString ; llvm :: raw_string_ostream In ( InString ); clang :: OMPClausePrinter Printer ( In , PP ); bool numThreads = 0 ; std :: string numThreadsParam ; bool threadLimit = 0 ; std :: string threadLimitParam ; for ( auto C : Clauses ) { // Only print clauses that are both printable (for us) and are actually in // the users code (is explicit) if ( isClausePrintable ( C ) && ! C -> isImplicit ()) { Printer . Visit ( C ); In . str (); size_t inp = InString . find ( \"(\" ) + 1 ; size_t paramlength = InString . length () - inp - 1 ; std :: string param = InString . substr ( inp , paramlength ); InString . erase ( inp , paramlength ); if ( C -> getClauseKind () == clang :: OpenMPClauseKind :: OMPC_num_threads ) { rewriteParam ( & param ); numThreadsParam = param ; numThreads = true ; } else if ( C -> getClauseKind () == clang :: OpenMPClauseKind :: OMPC_thread_limit ) { rewriteParam ( & param ); threadLimitParam = param ; threadLimit = true ; } else { Out << InString . insert ( inp , param ) << \" \" ; } InString . clear (); } } if ( numThreads && threadLimit ) { Out << \"num_threads((\" << numThreadsParam << \" < \" << threadLimitParam << \") ? \" << numThreadsParam << \" : \" << threadLimitParam << \") \" ; } else if ( numThreads && ! threadLimit ) { Out << \"num_threads(\" << numThreadsParam << \") \" ; } else if ( ! numThreads && threadLimit ) { Out << \"num_threads(\" << threadLimitParam << \") \" ; } } void OmpPragma::rewriteParam ( std :: string * In ) { bool isNumerical = true ; for ( auto i : * In ) { if ( ! isdigit ( i )) { isNumerical = false ; } } if ( ! isNumerical ) { * In = \"__sotoc_clause_param_\" + std :: to_string ( ClauseParamCounter ); ClauseParamCounter ++ ; } } bool OmpPragma::needsStructuredBlock () { switch ( Kind ) { case clang :: OpenMPDirectiveKind :: OMPD_target_parallel : case clang :: OpenMPDirectiveKind :: OMPD_target_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_simd : return true ; default : return false ; } }","title":"src/OmpPragma.cpp"},{"location":"internal/doxygen/Files/OmpPragma_8cpp/#srcomppragmacpp","text":"This file implements the class OmpPragma , which is used to generate repla- cement pragmas for teams and team combined constructs.","title":"src/OmpPragma.cpp"},{"location":"internal/doxygen/Files/OmpPragma_8cpp/#attributes","text":"Name int ClauseParamCounter","title":"Attributes"},{"location":"internal/doxygen/Files/OmpPragma_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"internal/doxygen/Files/OmpPragma_8cpp/#variable-clauseparamcounter","text":"1 int ClauseParamCounter = -1 ;","title":"variable ClauseParamCounter"},{"location":"internal/doxygen/Files/OmpPragma_8cpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 //===-- sotoc/src/TargetCode ------------------------ ---------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \"clang/AST/PrettyPrinter.h\" #include <ctype.h> #include \"OmpPragma.h\" int ClauseParamCounter = -1 ; void OmpPragma::printReplacement ( llvm :: raw_ostream & Out ) { switch ( Kind ) { case clang :: OpenMPDirectiveKind :: OMPD_target_parallel : { Out << \" #pragma omp parallel \" ; break ; } case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_parallel_for : case clang :: OpenMPDirectiveKind :: OMPD_target_parallel_for : { Out << \" #pragma omp parallel for \" ; break ; } case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_parallel_for_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_parallel_for_simd : { Out << \" #pragma _NEC ivdep \\n #pragma omp parallel for simd \" ; break ; } case clang :: OpenMPDirectiveKind :: OMPD_distribute_simd : case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_simd : { Out << \" #pragma _NEC ivdep \\n #pragma omp simd \" ; break ; } case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_parallel_for : { Out << \" #pragma omp parallel for \" ; break ; } case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_parallel_for_simd : { Out << \" #pragma _NEC ivdep \\n #pragma omp parallel for simd \" ; break ; } default : return ; } printClauses ( Out ); } //TODO: Do we need this? void OmpPragma::printAddition ( llvm :: raw_ostream & Out ) { Out << \" #pragma _NEC ivdep \" ; } bool OmpPragma::isReplaceable ( clang :: OMPExecutableDirective * Directive ) { if ( llvm :: isa < clang :: OMPTeamsDirective > ( Directive ) || llvm :: isa < clang :: OMPTeamsDistributeDirective > ( Directive ) || llvm :: isa < clang :: OMPTeamsDistributeSimdDirective > ( Directive ) || llvm :: isa < clang :: OMPTeamsDistributeParallelForDirective > ( Directive ) || llvm :: isa < clang :: OMPTeamsDistributeParallelForSimdDirective > ( Directive ) || llvm :: isa < clang :: OMPDistributeDirective > ( Directive )) { return true ; } return false ; } bool OmpPragma::needsAdditionalPragma ( clang :: OMPExecutableDirective * Directive ) { if ( llvm :: isa < clang :: OMPForSimdDirective > ( Directive ) || llvm :: isa < clang :: OMPParallelForSimdDirective > ( Directive ) || llvm :: isa < clang :: OMPSimdDirective > ( Directive ) || llvm :: isa < clang :: OMPTaskLoopSimdDirective > ( Directive )) { return true ; } return false ; } bool OmpPragma::isClausePrintable ( clang :: OMPClause * Clause ) { switch ( Kind ) { case clang :: OpenMPDirectiveKind :: OMPD_target : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_if: // case clang::OpenMPClauseKind::OMPC_device: // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_private : // case clang::OpenMPClauseKind::OMPC_nowait: // case clang::OpenMPClauseKind::OMPC_depend: // case clang::OpenMPClauseKind::OMPC_defaultmap: case clang :: OpenMPClauseKind :: OMPC_firstprivate : // case clang::OpenMPClauseKind::OMPC_is_device_ptr: // case clang::OpenMPClauseKind::OMPC_reduction: return true ; default : return false ; } } /*case clang::OpenMPDirectiveKind::OMPD_target_teams: { switch (Clause->getClauseKind()) { // case clang::OpenMPClauseKind::OMPC_map: case clang::OpenMPClauseKind::OMPC_default: case clang::OpenMPClauseKind::OMPC_private: case clang::OpenMPClauseKind::OMPC_firstprivate: case clang::OpenMPClauseKind::OMPC_shared: case clang::OpenMPClauseKind::OMPC_reduction: case clang::OpenMPClauseKind::OMPC_num_teams: case clang::OpenMPClauseKind::OMPC_thread_limit: return true; default: return false; } }*/ case clang :: OpenMPDirectiveKind :: OMPD_target_parallel : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_num_threads : case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_proc_bind : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_shared : // case clang::OpenMPClauseKind::OMPC_reduction: return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } case clang :: OpenMPDirectiveKind :: OMPD_target_parallel_for : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_num_threads : case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_proc_bind : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_schedule : case clang :: OpenMPClauseKind :: OMPC_ordered : case clang :: OpenMPClauseKind :: OMPC_linear : return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } case clang :: OpenMPDirectiveKind :: OMPD_target_parallel_for_simd : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_num_threads : case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_proc_bind : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_schedule : case clang :: OpenMPClauseKind :: OMPC_safelen : case clang :: OpenMPClauseKind :: OMPC_simdlen : case clang :: OpenMPClauseKind :: OMPC_linear : case clang :: OpenMPClauseKind :: OMPC_aligned : case clang :: OpenMPClauseKind :: OMPC_ordered : return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } case clang :: OpenMPDirectiveKind :: OMPD_target_simd : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_linear : case clang :: OpenMPClauseKind :: OMPC_aligned : case clang :: OpenMPClauseKind :: OMPC_safelen : case clang :: OpenMPClauseKind :: OMPC_simdlen : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_reduction : return true ; default : return false ; } } case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_thread_limit : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_dist_schedule : return true ; default : return false ; } } case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_parallel_for : case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_parallel_for : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_dist_schedule : case clang :: OpenMPClauseKind :: OMPC_num_threads : case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_proc_bind : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_schedule : case clang :: OpenMPClauseKind :: OMPC_thread_limit : return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_parallel_for_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_parallel_for_simd : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_dist_schedule : case clang :: OpenMPClauseKind :: OMPC_num_threads : case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_proc_bind : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_schedule : case clang :: OpenMPClauseKind :: OMPC_linear : case clang :: OpenMPClauseKind :: OMPC_aligned : case clang :: OpenMPClauseKind :: OMPC_safelen : case clang :: OpenMPClauseKind :: OMPC_simdlen : case clang :: OpenMPClauseKind :: OMPC_thread_limit : return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } case clang :: OpenMPDirectiveKind :: OMPD_teams_distribute_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_simd : { switch ( Clause -> getClauseKind ()) { // case clang::OpenMPClauseKind::OMPC_map: case clang :: OpenMPClauseKind :: OMPC_default : case clang :: OpenMPClauseKind :: OMPC_private : case clang :: OpenMPClauseKind :: OMPC_firstprivate : case clang :: OpenMPClauseKind :: OMPC_shared : case clang :: OpenMPClauseKind :: OMPC_reduction : case clang :: OpenMPClauseKind :: OMPC_thread_limit : case clang :: OpenMPClauseKind :: OMPC_lastprivate : case clang :: OpenMPClauseKind :: OMPC_collapse : case clang :: OpenMPClauseKind :: OMPC_dist_schedule : case clang :: OpenMPClauseKind :: OMPC_linear : case clang :: OpenMPClauseKind :: OMPC_aligned : case clang :: OpenMPClauseKind :: OMPC_safelen : case clang :: OpenMPClauseKind :: OMPC_simdlen : return true ; default : return false ; case clang :: OpenMPClauseKind :: OMPC_if : clang :: OMPIfClause * IC = llvm :: dyn_cast_or_null < clang :: OMPIfClause > ( Clause ); if (( IC -> getNameModifier ()) == clang :: OpenMPDirectiveKind :: OMPD_target ) { return false ; } else { return true ; } } } default : break ; } return false ; } void OmpPragma::printClauses ( llvm :: raw_ostream & Out ) { std :: string InString ; llvm :: raw_string_ostream In ( InString ); clang :: OMPClausePrinter Printer ( In , PP ); bool numThreads = 0 ; std :: string numThreadsParam ; bool threadLimit = 0 ; std :: string threadLimitParam ; for ( auto C : Clauses ) { // Only print clauses that are both printable (for us) and are actually in // the users code (is explicit) if ( isClausePrintable ( C ) && ! C -> isImplicit ()) { Printer . Visit ( C ); In . str (); size_t inp = InString . find ( \"(\" ) + 1 ; size_t paramlength = InString . length () - inp - 1 ; std :: string param = InString . substr ( inp , paramlength ); InString . erase ( inp , paramlength ); if ( C -> getClauseKind () == clang :: OpenMPClauseKind :: OMPC_num_threads ) { rewriteParam ( & param ); numThreadsParam = param ; numThreads = true ; } else if ( C -> getClauseKind () == clang :: OpenMPClauseKind :: OMPC_thread_limit ) { rewriteParam ( & param ); threadLimitParam = param ; threadLimit = true ; } else { Out << InString . insert ( inp , param ) << \" \" ; } InString . clear (); } } if ( numThreads && threadLimit ) { Out << \"num_threads((\" << numThreadsParam << \" < \" << threadLimitParam << \") ? \" << numThreadsParam << \" : \" << threadLimitParam << \") \" ; } else if ( numThreads && ! threadLimit ) { Out << \"num_threads(\" << numThreadsParam << \") \" ; } else if ( ! numThreads && threadLimit ) { Out << \"num_threads(\" << threadLimitParam << \") \" ; } } void OmpPragma::rewriteParam ( std :: string * In ) { bool isNumerical = true ; for ( auto i : * In ) { if ( ! isdigit ( i )) { isNumerical = false ; } } if ( ! isNumerical ) { * In = \"__sotoc_clause_param_\" + std :: to_string ( ClauseParamCounter ); ClauseParamCounter ++ ; } } bool OmpPragma::needsStructuredBlock () { switch ( Kind ) { case clang :: OpenMPDirectiveKind :: OMPD_target_parallel : case clang :: OpenMPDirectiveKind :: OMPD_target_simd : case clang :: OpenMPDirectiveKind :: OMPD_target_teams_distribute_simd : return true ; default : return false ; } }","title":"Source code"},{"location":"internal/doxygen/Files/OmpPragma_8h/","text":"src/OmpPragma.h Classes Name class OmpPragma A helper class to rewrite some \"pragma omp\" (mostly teams and similar combined constructs), which are not supported by sotoc. Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //===-- sotoc/src/OmpPragma.h ---------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// #pragma once #include \"clang/AST/OpenMPClause.h\" #include \"clang/AST/StmtOpenMP.h\" #include \"llvm/ADT/APInt.h\" #include \"llvm/Support/raw_ostream.h\" #include \"TargetCodeFragment.h\" #include <vector> class OmpPragma { clang :: PrintingPolicy PP ; llvm :: ArrayRef < clang :: OMPClause *> Clauses ; clang :: OpenMPDirectiveKind Kind ; unsigned int ClauseParamCounter ; public : OmpPragma ( TargetCodeRegion * TCR ) : PP ( TCR -> getPP ()), Clauses ( TCR -> getOMPClauses ()), Kind ( TCR -> getTargetCodeKind ()), ClauseParamCounter ( 0 ) {}; OmpPragma ( clang :: OMPExecutableDirective * Directive , clang :: PrintingPolicy PP ) : PP ( PP ), Clauses ( Directive -> clauses ()), Kind ( Directive -> getDirectiveKind ()), ClauseParamCounter ( 0 ) {}; bool needsStructuredBlock (); void printReplacement ( llvm :: raw_ostream & Out ); void printAddition ( llvm :: raw_ostream & Out ); static bool isReplaceable ( clang :: OMPExecutableDirective * Directive ); static bool needsAdditionalPragma ( clang :: OMPExecutableDirective * Directive ); private : bool isClausePrintable ( clang :: OMPClause * Clause ); void rewriteParam ( std :: string * In ); void printClauses ( llvm :: raw_ostream & Out ); };","title":"src/OmpPragma.h"},{"location":"internal/doxygen/Files/OmpPragma_8h/#srcomppragmah","text":"","title":"src/OmpPragma.h"},{"location":"internal/doxygen/Files/OmpPragma_8h/#classes","text":"Name class OmpPragma A helper class to rewrite some \"pragma omp\" (mostly teams and similar combined constructs), which are not supported by sotoc.","title":"Classes"},{"location":"internal/doxygen/Files/OmpPragma_8h/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //===-- sotoc/src/OmpPragma.h ---------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// #pragma once #include \"clang/AST/OpenMPClause.h\" #include \"clang/AST/StmtOpenMP.h\" #include \"llvm/ADT/APInt.h\" #include \"llvm/Support/raw_ostream.h\" #include \"TargetCodeFragment.h\" #include <vector> class OmpPragma { clang :: PrintingPolicy PP ; llvm :: ArrayRef < clang :: OMPClause *> Clauses ; clang :: OpenMPDirectiveKind Kind ; unsigned int ClauseParamCounter ; public : OmpPragma ( TargetCodeRegion * TCR ) : PP ( TCR -> getPP ()), Clauses ( TCR -> getOMPClauses ()), Kind ( TCR -> getTargetCodeKind ()), ClauseParamCounter ( 0 ) {}; OmpPragma ( clang :: OMPExecutableDirective * Directive , clang :: PrintingPolicy PP ) : PP ( PP ), Clauses ( Directive -> clauses ()), Kind ( Directive -> getDirectiveKind ()), ClauseParamCounter ( 0 ) {}; bool needsStructuredBlock (); void printReplacement ( llvm :: raw_ostream & Out ); void printAddition ( llvm :: raw_ostream & Out ); static bool isReplaceable ( clang :: OMPExecutableDirective * Directive ); static bool needsAdditionalPragma ( clang :: OMPExecutableDirective * Directive ); private : bool isClausePrintable ( clang :: OMPClause * Clause ); void rewriteParam ( std :: string * In ); void printClauses ( llvm :: raw_ostream & Out ); };","title":"Source code"},{"location":"internal/doxygen/Files/TargetCodeFragment_8cpp/","text":"src/TargetCodeFragment.cpp This file implements the classes TargetCodeDecl and TargetCodeRegion . Classes Name class TargetRegionPrinterHelper Print Helper Class. Functions Name bool hasRegionCompoundStmt (const clang::Stmt * S) Determine whether a region has a compound statement. bool hasRegionOMPStmt (const clang::Stmt * S) Determine whether a region has a OMP statement. clang::SourceLocation getOMPStmtSourceLocEnd (const clang::Stmt * S) Get the end a OMP stmt source. clang::SourceLocation findPreviousToken (clang::SourceLocation Loc, clang::SourceManager & SM, const clang::LangOptions & LO) Find previous token. Functions Documentation function hasRegionCompoundStmt 1 2 3 static bool hasRegionCompoundStmt ( const clang :: Stmt * S ) Determine whether a region has a compound statement. Parameters : S Statement (region) Return : true If the region has a compound statement false If the region does not have a compound statement function hasRegionOMPStmt 1 2 3 static bool hasRegionOMPStmt ( const clang :: Stmt * S ) Determine whether a region has a OMP statement. Parameters : S Statement (region) Return : true If the region has a OMP statement false If the region does not have a OMP statement function getOMPStmtSourceLocEnd 1 2 3 static clang :: SourceLocation getOMPStmtSourceLocEnd ( const clang :: Stmt * S ) Get the end a OMP stmt source. Parameters : S Statement Return : clang::SourceLocation Location of the end function findPreviousToken 1 2 3 4 5 static clang :: SourceLocation findPreviousToken ( clang :: SourceLocation Loc , clang :: SourceManager & SM , const clang :: LangOptions & LO ) Find previous token. Parameters : Loc Source Location SM Source Manager LO Language options Return : clang::SourceLocation Previous token Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 //===-- sotoc/src/TargetCodeFragment.cpp ---------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include <sstream> #include \"clang/AST/Decl.h\" #include \"clang/AST/DeclOpenMP.h\" #include \"clang/AST/PrettyPrinter.h\" #include \"clang/AST/Stmt.h\" #include \"clang/AST/StmtOpenMP.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Basic/LangOptions.h\" #include \"clang/Basic/SourceLocation.h\" #include \"clang/Basic/TokenKinds.h\" #include \"clang/Lex/Lexer.h\" #include \"clang/Lex/Token.h\" #include \"Debug.h\" #include \"OmpPragma.h\" #include \"TargetCodeFragment.h\" void TargetCodeRegion::addCapture ( const clang :: CapturedStmt :: Capture * Capture ) { CapturedVars . push_back ( TargetRegionVariable ( Capture , CapturedLowerBounds )); } void TargetCodeRegion::addOMPClauseParam ( clang :: VarDecl * Param ) { for ( auto & CV : capturedVars ()) { if ( CV . getDecl () == Param ) { return ; } } if ( std :: find ( OMPClausesParams . begin (), OMPClausesParams . end (), Param ) != OMPClausesParams . end ()) { return ; } DEBUGP ( \"Adding variable \" << Param -> getName () << \"as OpenMP clause parameter\" ); OMPClausesParams . push_back ( Param ); } void TargetCodeRegion::addOMPClause ( clang :: OMPClause * Clause ) { OMPClauses . push_back ( Clause ); } static bool hasRegionCompoundStmt ( const clang :: Stmt * S ) { if ( const auto * SS = llvm :: dyn_cast < clang :: CapturedStmt > ( S )) { if ( llvm :: isa < clang :: CompoundStmt > ( SS -> getCapturedStmt ())) { return true ; } else if ( llvm :: isa < clang :: CapturedStmt > ( SS -> getCapturedStmt ())) { return hasRegionCompoundStmt ( SS -> getCapturedStmt ()); } } return false ; } static bool hasRegionOMPStmt ( const clang :: Stmt * S ) { if ( const auto * SS = llvm :: dyn_cast < clang :: CapturedStmt > ( S )) { if ( llvm :: isa < clang :: OMPExecutableDirective > ( SS -> getCapturedStmt ())) { return true ; } else if ( llvm :: isa < clang :: CapturedStmt > ( SS -> getCapturedStmt ())) { return hasRegionOMPStmt ( SS -> getCapturedStmt ()); } } return false ; } static clang :: SourceLocation getOMPStmtSourceLocEnd ( const clang :: Stmt * S ) { while ( auto * CS = llvm :: dyn_cast < clang :: CapturedStmt > ( S )) { S = CS -> getCapturedStmt (); } while ( auto * OmpExecS = llvm :: dyn_cast < clang :: OMPExecutableDirective > ( S )) { S = OmpExecS -> getInnermostCapturedStmt (); if ( auto * CS = llvm :: dyn_cast < clang :: CapturedStmt > ( S )) { S = CS -> getCapturedStmt (); } } return S -> getEndLoc (); } // TODO: Implement recursive for an arbitrary depth? static clang :: SourceLocation findPreviousToken ( clang :: SourceLocation Loc , clang :: SourceManager & SM , const clang :: LangOptions & LO ) { clang :: Token token ; Loc = clang :: Lexer :: GetBeginningOfToken ( Loc , SM , LO ); // Search until we find a valid token before Loc // TODO: Error handling if no token can be found do { Loc = clang :: Lexer :: GetBeginningOfToken ( Loc . getLocWithOffset ( -1 ), SM , LO ); } while (( clang :: Lexer :: getRawToken ( Loc , token , SM , LO ))); return token . getLocation (); } TargetCodeFragment ::~ TargetCodeFragment () {} clang :: SourceLocation TargetCodeRegion :: getStartLoc () { clang :: SourceManager & SM = Context . getSourceManager (); const clang :: LangOptions & LO = Context . getLangOpts (); auto TokenBegin = clang :: Lexer :: GetBeginningOfToken ( CapturedStmtNode -> getBeginLoc (), SM , LO ); if ( hasRegionCompoundStmt ( CapturedStmtNode )) { #if 0 // This piece of code could be used to check if we start with a new scope. // However, the pretty printer destroys this again somehow... // Since the extra scope does not really hurt, i will leave it as it is for now. clang::Token token; if(!(clang::Lexer::getRawToken(TokenBegin, token, SM, LO))) { if (token.is(clang::tok::l_brace)) { auto possibleNextToken = clang::Lexer::findNextToken( TokenBegin, SM, LO); if (possibleNextToken.hasValue()) { return possibleNextToken.getValue().getLocation(); } else { llvm::outs()<< \"OUCH\\n\"; } return TokenBegin.getLocWithOffset(1); } } else llvm::outs() << \"NOTOK\\n\"; #endif return TokenBegin ; } else if ( hasRegionOMPStmt ( CapturedStmtNode )) { // We have to go backwards 2 tokens in case of an OMP statement // (the '#' and the 'pragma'). return findPreviousToken ( findPreviousToken ( TokenBegin , SM , LO ), SM , LO ); } else { return CapturedStmtNode -> getBeginLoc (); } } clang :: SourceLocation TargetCodeRegion :: getEndLoc () { clang :: SourceManager & SM = Context . getSourceManager (); const clang :: LangOptions & LO = Context . getLangOpts (); auto N = CapturedStmtNode ; if ( hasRegionCompoundStmt ( N )) { return clang :: Lexer :: GetBeginningOfToken ( N -> getEndLoc (), SM , LO ) . getLocWithOffset ( -1 ); // TODO: If I set this to \"1\" it works too. I // think it was here to remove addition scope // which i get with \"printPretty\". Does this // need some fixing? } else if ( hasRegionOMPStmt ( N )) { return getOMPStmtSourceLocEnd ( N ); } else { return N -> getEndLoc (); } } const std :: string TargetCodeRegion :: getParentFuncName () { return ParentFunctionDecl -> getNameInfo (). getAsString (); } clang :: SourceLocation TargetCodeRegion :: getTargetDirectiveLocation () { return TargetDirective -> getBeginLoc (); } clang :: SourceRange TargetCodeRegion :: getRealRange () { return CapturedStmtNode -> getSourceRange (); } clang :: SourceRange TargetCodeRegion :: getSpellingRange () { auto & SM = CapturedStmtNode -> getCapturedDecl () -> getASTContext (). getSourceManager (); auto InnerRange = getInnerRange (); return clang :: SourceRange ( SM . getSpellingLoc ( InnerRange . getBegin ()), SM . getSpellingLoc ( InnerRange . getEnd ())); } clang :: SourceRange TargetCodeRegion :: getInnerRange () { auto InnerLocStart = getStartLoc (); auto InnerLocEnd = getEndLoc (); return clang :: SourceRange ( InnerLocStart , InnerLocEnd ); } class TargetRegionPrinterHelper : public clang :: PrinterHelper { clang :: PrintingPolicy PP ; public : TargetRegionPrinterHelper ( clang :: PrintingPolicy PP ) : PP ( PP ){}; bool handledStmt ( clang :: Stmt * E , llvm :: raw_ostream & OS ) { if ( auto * Directive = llvm :: dyn_cast < clang :: OMPExecutableDirective > ( E )) { if ( OmpPragma :: isReplaceable ( Directive )) { OmpPragma ( Directive , PP ). printReplacement ( OS ); OS << \" \\n \" ; Directive -> child_begin () -> printPretty ( OS , this , PP ); return true ; } if ( OmpPragma :: needsAdditionalPragma ( Directive )) { OmpPragma ( Directive , PP ). printAddition ( OS ); OS << \" \\n \" ; return false ; } } return false ; } }; std :: string TargetCodeRegion::PrintPretty () { // TODO: Is there a better approach (e.g., token or preprocessor based?) // One issue here: Addition braces (i.e., scope) in some cases. std :: string PrettyStr = \"\" ; llvm :: raw_string_ostream PrettyOS ( PrettyStr ); TargetRegionPrinterHelper Helper ( PP ); if ( CapturedStmtNode != NULL ) CapturedStmtNode -> printPretty ( PrettyOS , & Helper , PP ); return PrettyOS . str (); } clang :: SourceRange TargetCodeDecl::getRealRange () { return DeclNode -> getSourceRange (); } clang :: SourceRange TargetCodeDecl::getSpellingRange () { auto & SM = DeclNode -> getASTContext (). getSourceManager (); auto InnerRange = getInnerRange (); return clang :: SourceRange ( SM . getSpellingLoc ( InnerRange . getBegin ()), SM . getSpellingLoc ( InnerRange . getEnd ())); } std :: string TargetCodeDecl::PrintPretty () { std :: string PrettyStr = \"\" ; llvm :: raw_string_ostream PrettyOS ( PrettyStr ); // This hack solves our problem with structs and enums being autoexpanded# // sometimes (See comment in Issue #20. clang :: PrintingPolicy LocalPP ( PP ); if ( llvm :: isa < clang :: TypedefDecl > ( DeclNode )) { LocalPP . IncludeTagDefinition = 1 ; } TargetRegionPrinterHelper Helper ( PP ); // This hack removes the 'static' keyword from globalVarDecls, because we // cannot find variables from the host if they are static. bool HasStaticKeyword = false ; if ( auto * VarDeclNode = llvm :: dyn_cast < clang :: VarDecl > ( DeclNode )) { if ( VarDeclNode -> getStorageClass () == clang :: SC_Static ) { HasStaticKeyword = true ; VarDeclNode -> setStorageClass ( clang :: SC_None ); } } DeclNode -> print ( PrettyOS , LocalPP , 0 , false , & Helper ); // Add static storage class back so (hopefully) this doesnt break anyting // (but it totally will). if ( auto * VarDeclNode = llvm :: dyn_cast < clang :: VarDecl > ( DeclNode )) { if ( HasStaticKeyword ) { VarDeclNode -> setStorageClass ( clang :: SC_Static ); } } // This hack removes '#pragma omp declare target' from the output std :: string outString = PrettyOS . str (); const char * declareTargetPragma = \"#pragma omp declare target\" ; if ( outString . compare ( 0 , strlen ( declareTargetPragma ), declareTargetPragma ) == 0 ) { outString = outString . substr ( strlen ( declareTargetPragma )); } return outString ; }","title":"src/TargetCodeFragment.cpp"},{"location":"internal/doxygen/Files/TargetCodeFragment_8cpp/#srctargetcodefragmentcpp","text":"This file implements the classes TargetCodeDecl and TargetCodeRegion .","title":"src/TargetCodeFragment.cpp"},{"location":"internal/doxygen/Files/TargetCodeFragment_8cpp/#classes","text":"Name class TargetRegionPrinterHelper Print Helper Class.","title":"Classes"},{"location":"internal/doxygen/Files/TargetCodeFragment_8cpp/#functions","text":"Name bool hasRegionCompoundStmt (const clang::Stmt * S) Determine whether a region has a compound statement. bool hasRegionOMPStmt (const clang::Stmt * S) Determine whether a region has a OMP statement. clang::SourceLocation getOMPStmtSourceLocEnd (const clang::Stmt * S) Get the end a OMP stmt source. clang::SourceLocation findPreviousToken (clang::SourceLocation Loc, clang::SourceManager & SM, const clang::LangOptions & LO) Find previous token.","title":"Functions"},{"location":"internal/doxygen/Files/TargetCodeFragment_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"internal/doxygen/Files/TargetCodeFragment_8cpp/#function-hasregioncompoundstmt","text":"1 2 3 static bool hasRegionCompoundStmt ( const clang :: Stmt * S ) Determine whether a region has a compound statement. Parameters : S Statement (region) Return : true If the region has a compound statement false If the region does not have a compound statement","title":"function hasRegionCompoundStmt"},{"location":"internal/doxygen/Files/TargetCodeFragment_8cpp/#function-hasregionompstmt","text":"1 2 3 static bool hasRegionOMPStmt ( const clang :: Stmt * S ) Determine whether a region has a OMP statement. Parameters : S Statement (region) Return : true If the region has a OMP statement false If the region does not have a OMP statement","title":"function hasRegionOMPStmt"},{"location":"internal/doxygen/Files/TargetCodeFragment_8cpp/#function-getompstmtsourcelocend","text":"1 2 3 static clang :: SourceLocation getOMPStmtSourceLocEnd ( const clang :: Stmt * S ) Get the end a OMP stmt source. Parameters : S Statement Return : clang::SourceLocation Location of the end","title":"function getOMPStmtSourceLocEnd"},{"location":"internal/doxygen/Files/TargetCodeFragment_8cpp/#function-findprevioustoken","text":"1 2 3 4 5 static clang :: SourceLocation findPreviousToken ( clang :: SourceLocation Loc , clang :: SourceManager & SM , const clang :: LangOptions & LO ) Find previous token. Parameters : Loc Source Location SM Source Manager LO Language options Return : clang::SourceLocation Previous token","title":"function findPreviousToken"},{"location":"internal/doxygen/Files/TargetCodeFragment_8cpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 //===-- sotoc/src/TargetCodeFragment.cpp ---------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include <sstream> #include \"clang/AST/Decl.h\" #include \"clang/AST/DeclOpenMP.h\" #include \"clang/AST/PrettyPrinter.h\" #include \"clang/AST/Stmt.h\" #include \"clang/AST/StmtOpenMP.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Basic/LangOptions.h\" #include \"clang/Basic/SourceLocation.h\" #include \"clang/Basic/TokenKinds.h\" #include \"clang/Lex/Lexer.h\" #include \"clang/Lex/Token.h\" #include \"Debug.h\" #include \"OmpPragma.h\" #include \"TargetCodeFragment.h\" void TargetCodeRegion::addCapture ( const clang :: CapturedStmt :: Capture * Capture ) { CapturedVars . push_back ( TargetRegionVariable ( Capture , CapturedLowerBounds )); } void TargetCodeRegion::addOMPClauseParam ( clang :: VarDecl * Param ) { for ( auto & CV : capturedVars ()) { if ( CV . getDecl () == Param ) { return ; } } if ( std :: find ( OMPClausesParams . begin (), OMPClausesParams . end (), Param ) != OMPClausesParams . end ()) { return ; } DEBUGP ( \"Adding variable \" << Param -> getName () << \"as OpenMP clause parameter\" ); OMPClausesParams . push_back ( Param ); } void TargetCodeRegion::addOMPClause ( clang :: OMPClause * Clause ) { OMPClauses . push_back ( Clause ); } static bool hasRegionCompoundStmt ( const clang :: Stmt * S ) { if ( const auto * SS = llvm :: dyn_cast < clang :: CapturedStmt > ( S )) { if ( llvm :: isa < clang :: CompoundStmt > ( SS -> getCapturedStmt ())) { return true ; } else if ( llvm :: isa < clang :: CapturedStmt > ( SS -> getCapturedStmt ())) { return hasRegionCompoundStmt ( SS -> getCapturedStmt ()); } } return false ; } static bool hasRegionOMPStmt ( const clang :: Stmt * S ) { if ( const auto * SS = llvm :: dyn_cast < clang :: CapturedStmt > ( S )) { if ( llvm :: isa < clang :: OMPExecutableDirective > ( SS -> getCapturedStmt ())) { return true ; } else if ( llvm :: isa < clang :: CapturedStmt > ( SS -> getCapturedStmt ())) { return hasRegionOMPStmt ( SS -> getCapturedStmt ()); } } return false ; } static clang :: SourceLocation getOMPStmtSourceLocEnd ( const clang :: Stmt * S ) { while ( auto * CS = llvm :: dyn_cast < clang :: CapturedStmt > ( S )) { S = CS -> getCapturedStmt (); } while ( auto * OmpExecS = llvm :: dyn_cast < clang :: OMPExecutableDirective > ( S )) { S = OmpExecS -> getInnermostCapturedStmt (); if ( auto * CS = llvm :: dyn_cast < clang :: CapturedStmt > ( S )) { S = CS -> getCapturedStmt (); } } return S -> getEndLoc (); } // TODO: Implement recursive for an arbitrary depth? static clang :: SourceLocation findPreviousToken ( clang :: SourceLocation Loc , clang :: SourceManager & SM , const clang :: LangOptions & LO ) { clang :: Token token ; Loc = clang :: Lexer :: GetBeginningOfToken ( Loc , SM , LO ); // Search until we find a valid token before Loc // TODO: Error handling if no token can be found do { Loc = clang :: Lexer :: GetBeginningOfToken ( Loc . getLocWithOffset ( -1 ), SM , LO ); } while (( clang :: Lexer :: getRawToken ( Loc , token , SM , LO ))); return token . getLocation (); } TargetCodeFragment ::~ TargetCodeFragment () {} clang :: SourceLocation TargetCodeRegion :: getStartLoc () { clang :: SourceManager & SM = Context . getSourceManager (); const clang :: LangOptions & LO = Context . getLangOpts (); auto TokenBegin = clang :: Lexer :: GetBeginningOfToken ( CapturedStmtNode -> getBeginLoc (), SM , LO ); if ( hasRegionCompoundStmt ( CapturedStmtNode )) { #if 0 // This piece of code could be used to check if we start with a new scope. // However, the pretty printer destroys this again somehow... // Since the extra scope does not really hurt, i will leave it as it is for now. clang::Token token; if(!(clang::Lexer::getRawToken(TokenBegin, token, SM, LO))) { if (token.is(clang::tok::l_brace)) { auto possibleNextToken = clang::Lexer::findNextToken( TokenBegin, SM, LO); if (possibleNextToken.hasValue()) { return possibleNextToken.getValue().getLocation(); } else { llvm::outs()<< \"OUCH\\n\"; } return TokenBegin.getLocWithOffset(1); } } else llvm::outs() << \"NOTOK\\n\"; #endif return TokenBegin ; } else if ( hasRegionOMPStmt ( CapturedStmtNode )) { // We have to go backwards 2 tokens in case of an OMP statement // (the '#' and the 'pragma'). return findPreviousToken ( findPreviousToken ( TokenBegin , SM , LO ), SM , LO ); } else { return CapturedStmtNode -> getBeginLoc (); } } clang :: SourceLocation TargetCodeRegion :: getEndLoc () { clang :: SourceManager & SM = Context . getSourceManager (); const clang :: LangOptions & LO = Context . getLangOpts (); auto N = CapturedStmtNode ; if ( hasRegionCompoundStmt ( N )) { return clang :: Lexer :: GetBeginningOfToken ( N -> getEndLoc (), SM , LO ) . getLocWithOffset ( -1 ); // TODO: If I set this to \"1\" it works too. I // think it was here to remove addition scope // which i get with \"printPretty\". Does this // need some fixing? } else if ( hasRegionOMPStmt ( N )) { return getOMPStmtSourceLocEnd ( N ); } else { return N -> getEndLoc (); } } const std :: string TargetCodeRegion :: getParentFuncName () { return ParentFunctionDecl -> getNameInfo (). getAsString (); } clang :: SourceLocation TargetCodeRegion :: getTargetDirectiveLocation () { return TargetDirective -> getBeginLoc (); } clang :: SourceRange TargetCodeRegion :: getRealRange () { return CapturedStmtNode -> getSourceRange (); } clang :: SourceRange TargetCodeRegion :: getSpellingRange () { auto & SM = CapturedStmtNode -> getCapturedDecl () -> getASTContext (). getSourceManager (); auto InnerRange = getInnerRange (); return clang :: SourceRange ( SM . getSpellingLoc ( InnerRange . getBegin ()), SM . getSpellingLoc ( InnerRange . getEnd ())); } clang :: SourceRange TargetCodeRegion :: getInnerRange () { auto InnerLocStart = getStartLoc (); auto InnerLocEnd = getEndLoc (); return clang :: SourceRange ( InnerLocStart , InnerLocEnd ); } class TargetRegionPrinterHelper : public clang :: PrinterHelper { clang :: PrintingPolicy PP ; public : TargetRegionPrinterHelper ( clang :: PrintingPolicy PP ) : PP ( PP ){}; bool handledStmt ( clang :: Stmt * E , llvm :: raw_ostream & OS ) { if ( auto * Directive = llvm :: dyn_cast < clang :: OMPExecutableDirective > ( E )) { if ( OmpPragma :: isReplaceable ( Directive )) { OmpPragma ( Directive , PP ). printReplacement ( OS ); OS << \" \\n \" ; Directive -> child_begin () -> printPretty ( OS , this , PP ); return true ; } if ( OmpPragma :: needsAdditionalPragma ( Directive )) { OmpPragma ( Directive , PP ). printAddition ( OS ); OS << \" \\n \" ; return false ; } } return false ; } }; std :: string TargetCodeRegion::PrintPretty () { // TODO: Is there a better approach (e.g., token or preprocessor based?) // One issue here: Addition braces (i.e., scope) in some cases. std :: string PrettyStr = \"\" ; llvm :: raw_string_ostream PrettyOS ( PrettyStr ); TargetRegionPrinterHelper Helper ( PP ); if ( CapturedStmtNode != NULL ) CapturedStmtNode -> printPretty ( PrettyOS , & Helper , PP ); return PrettyOS . str (); } clang :: SourceRange TargetCodeDecl::getRealRange () { return DeclNode -> getSourceRange (); } clang :: SourceRange TargetCodeDecl::getSpellingRange () { auto & SM = DeclNode -> getASTContext (). getSourceManager (); auto InnerRange = getInnerRange (); return clang :: SourceRange ( SM . getSpellingLoc ( InnerRange . getBegin ()), SM . getSpellingLoc ( InnerRange . getEnd ())); } std :: string TargetCodeDecl::PrintPretty () { std :: string PrettyStr = \"\" ; llvm :: raw_string_ostream PrettyOS ( PrettyStr ); // This hack solves our problem with structs and enums being autoexpanded# // sometimes (See comment in Issue #20. clang :: PrintingPolicy LocalPP ( PP ); if ( llvm :: isa < clang :: TypedefDecl > ( DeclNode )) { LocalPP . IncludeTagDefinition = 1 ; } TargetRegionPrinterHelper Helper ( PP ); // This hack removes the 'static' keyword from globalVarDecls, because we // cannot find variables from the host if they are static. bool HasStaticKeyword = false ; if ( auto * VarDeclNode = llvm :: dyn_cast < clang :: VarDecl > ( DeclNode )) { if ( VarDeclNode -> getStorageClass () == clang :: SC_Static ) { HasStaticKeyword = true ; VarDeclNode -> setStorageClass ( clang :: SC_None ); } } DeclNode -> print ( PrettyOS , LocalPP , 0 , false , & Helper ); // Add static storage class back so (hopefully) this doesnt break anyting // (but it totally will). if ( auto * VarDeclNode = llvm :: dyn_cast < clang :: VarDecl > ( DeclNode )) { if ( HasStaticKeyword ) { VarDeclNode -> setStorageClass ( clang :: SC_Static ); } } // This hack removes '#pragma omp declare target' from the output std :: string outString = PrettyOS . str (); const char * declareTargetPragma = \"#pragma omp declare target\" ; if ( outString . compare ( 0 , strlen ( declareTargetPragma ), declareTargetPragma ) == 0 ) { outString = outString . substr ( strlen ( declareTargetPragma )); } return outString ; }","title":"Source code"},{"location":"internal/doxygen/Files/TargetCodeFragment_8h/","text":"src/TargetCodeFragment.h Namespaces Name clang Classes Name class TargetCodeFragment An abstract base class for all fragments of the original code (except header includes) that need to be copied to our generated source code. class TargetCodeRegion Represents one target region. class TargetCodeDecl This class represents a declaration, i.e. Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 //===-- sotoc/src/TargetCodeFragment.h ------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// #pragma once #include <string> #include <vector> #include \"clang/AST/ASTContext.h\" #include \"clang/AST/OpenMPClause.h\" #include \"clang/AST/PrettyPrinter.h\" #include \"clang/AST/StmtOpenMP.h\" #include \"clang/Basic/OpenMPKinds.h\" #include \"TargetRegionVariable.h\" // forward declaration of clang types namespace clang { class SourceLocation ; class SourceRange ; class Decl ; class VarDecl ; class CapturedStmt ; } // namespace clang class TargetCodeFragment { public : enum TargetCodeFragmentKind { TCFK_TargetCodeFragment , TCFK_TargetCodeRegion , TCFK_TargetCodeDecl , }; protected : const TargetCodeFragmentKind Kind ; public : TargetCodeFragmentKind getKind () const { return Kind ; }; static bool classof ( const TargetCodeFragment * TCF ) { return TCF -> getKind () == TCFK_TargetCodeFragment ; } bool NeedsSemicolon ; clang :: OpenMPDirectiveKind TargetCodeKind ; bool HasExtraBraces ; protected : clang :: ASTContext & Context ; clang :: PrintingPolicy PP ; public : TargetCodeFragment ( clang :: ASTContext & Context , TargetCodeFragmentKind Kind ) : Kind ( Kind ), NeedsSemicolon ( false ), TargetCodeKind ( clang :: OpenMPDirectiveKind :: OMPD_unknown ), HasExtraBraces ( false ), Context ( Context ), PP ( Context . getLangOpts ()) { PP . Indentation = 1 ; PP . SuppressSpecifiers = 0 ; PP . IncludeTagDefinition = 0 ; }; virtual ~ TargetCodeFragment () = 0 ; virtual std :: string PrintPretty () = 0 ; virtual clang :: SourceRange getRealRange () = 0 ; virtual clang :: SourceRange getInnerRange () { return getRealRange (); }; virtual clang :: SourceRange getSpellingRange () = 0 ; clang :: OpenMPDirectiveKind getTargetCodeKind () { return TargetCodeKind ; }; const clang :: LangOptions & GetLangOpts () { return Context . getLangOpts (); } clang :: PrintingPolicy getPP () { return PP ; }; }; class TargetCodeRegion : public TargetCodeFragment { public : static bool classof ( const TargetCodeFragment * TCF ) { return ( TCF -> getKind () == TCFK_TargetCodeRegion || TCF -> getKind () == TCFK_TargetCodeFragment ); }; private : clang :: CapturedStmt * CapturedStmtNode ; clang :: OMPExecutableDirective * TargetDirective ; clang :: FunctionDecl * ParentFunctionDecl ; std :: vector < TargetRegionVariable > CapturedVars ; std :: vector < clang :: OMPClause *> OMPClauses ; std :: vector < clang :: VarDecl *> OMPClausesParams ; std :: set < clang :: VarDecl *> PrivateVars ; public : TargetCodeRegion ( clang :: CapturedStmt * CapturedStmtNode , clang :: OMPExecutableDirective * TargetDirective , clang :: FunctionDecl * ParentFunctionDecl , clang :: ASTContext & Context ) : TargetCodeFragment ( Context , TCFK_TargetCodeRegion ), CapturedStmtNode ( CapturedStmtNode ), TargetDirective ( TargetDirective ), ParentFunctionDecl ( ParentFunctionDecl ){}; using captured_vars_const_iterator = std :: vector < TargetRegionVariable >:: const_iterator ; using captured_vars_const_range = llvm :: iterator_range < captured_vars_const_iterator > ; using private_vars_const_iterator = std :: set < clang :: VarDecl *>:: const_iterator ; using private_vars_const_range = llvm :: iterator_range < private_vars_const_iterator > ; using ompclauses_params_const_iterator = std :: vector < clang :: VarDecl *>:: const_iterator ; using ompclauses_params_const_range = llvm :: iterator_range < ompclauses_params_const_iterator > ; void addCapture ( const clang :: CapturedStmt :: Capture * Capture ); captured_vars_const_iterator getCapturedVarsBegin () { return CapturedVars . begin (); }; captured_vars_const_iterator getCapturedVarsEnd () { return CapturedVars . end (); }; captured_vars_const_range capturedVars () { return captured_vars_const_range ( getCapturedVarsBegin (), getCapturedVarsEnd ()); }; void addOMPClause ( clang :: OMPClause * Clause ); const std :: vector < clang :: OMPClause *> & getOMPClauses () const { return OMPClauses ; }; void setPrivateVars ( const std :: set < clang :: VarDecl *> & VarSet ) { PrivateVars = VarSet ; }; private_vars_const_range privateVars () { return private_vars_const_range ( PrivateVars . cbegin (), PrivateVars . cend ()); }; ompclauses_params_const_range ompClausesParams () { return ompclauses_params_const_range ( OMPClausesParams . cbegin (), OMPClausesParams . cend ()); }; void addOMPClauseParam ( clang :: VarDecl * Param ); bool hasCombineConstruct () { return TargetCodeKind != clang :: OpenMPDirectiveKind :: OMPD_target ; } virtual std :: string PrintPretty () override ; clang :: SourceRange getRealRange () override ; clang :: SourceRange getInnerRange () override ; clang :: SourceRange getSpellingRange () override ; clang :: SourceLocation getStartLoc (); clang :: SourceLocation getEndLoc (); const std :: string getParentFuncName (); clang :: SourceLocation getTargetDirectiveLocation (); std :: map < clang :: VarDecl * , clang :: Expr *> CapturedLowerBounds ; }; class TargetCodeDecl : public TargetCodeFragment { public : static bool classof ( const TargetCodeFragment * TCF ) { return ( TCF -> getKind () == TCFK_TargetCodeDecl || TCF -> getKind () == TCFK_TargetCodeFragment ); }; private : clang :: Decl * DeclNode ; public : TargetCodeDecl ( clang :: Decl * Node ) : TargetCodeFragment ( Node -> getASTContext (), TCFK_TargetCodeDecl ), DeclNode ( Node ){}; virtual std :: string PrintPretty () override ; clang :: SourceRange getRealRange () override ; clang :: SourceRange getSpellingRange () override ; };","title":"src/TargetCodeFragment.h"},{"location":"internal/doxygen/Files/TargetCodeFragment_8h/#srctargetcodefragmenth","text":"","title":"src/TargetCodeFragment.h"},{"location":"internal/doxygen/Files/TargetCodeFragment_8h/#namespaces","text":"Name clang","title":"Namespaces"},{"location":"internal/doxygen/Files/TargetCodeFragment_8h/#classes","text":"Name class TargetCodeFragment An abstract base class for all fragments of the original code (except header includes) that need to be copied to our generated source code. class TargetCodeRegion Represents one target region. class TargetCodeDecl This class represents a declaration, i.e.","title":"Classes"},{"location":"internal/doxygen/Files/TargetCodeFragment_8h/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 //===-- sotoc/src/TargetCodeFragment.h ------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// #pragma once #include <string> #include <vector> #include \"clang/AST/ASTContext.h\" #include \"clang/AST/OpenMPClause.h\" #include \"clang/AST/PrettyPrinter.h\" #include \"clang/AST/StmtOpenMP.h\" #include \"clang/Basic/OpenMPKinds.h\" #include \"TargetRegionVariable.h\" // forward declaration of clang types namespace clang { class SourceLocation ; class SourceRange ; class Decl ; class VarDecl ; class CapturedStmt ; } // namespace clang class TargetCodeFragment { public : enum TargetCodeFragmentKind { TCFK_TargetCodeFragment , TCFK_TargetCodeRegion , TCFK_TargetCodeDecl , }; protected : const TargetCodeFragmentKind Kind ; public : TargetCodeFragmentKind getKind () const { return Kind ; }; static bool classof ( const TargetCodeFragment * TCF ) { return TCF -> getKind () == TCFK_TargetCodeFragment ; } bool NeedsSemicolon ; clang :: OpenMPDirectiveKind TargetCodeKind ; bool HasExtraBraces ; protected : clang :: ASTContext & Context ; clang :: PrintingPolicy PP ; public : TargetCodeFragment ( clang :: ASTContext & Context , TargetCodeFragmentKind Kind ) : Kind ( Kind ), NeedsSemicolon ( false ), TargetCodeKind ( clang :: OpenMPDirectiveKind :: OMPD_unknown ), HasExtraBraces ( false ), Context ( Context ), PP ( Context . getLangOpts ()) { PP . Indentation = 1 ; PP . SuppressSpecifiers = 0 ; PP . IncludeTagDefinition = 0 ; }; virtual ~ TargetCodeFragment () = 0 ; virtual std :: string PrintPretty () = 0 ; virtual clang :: SourceRange getRealRange () = 0 ; virtual clang :: SourceRange getInnerRange () { return getRealRange (); }; virtual clang :: SourceRange getSpellingRange () = 0 ; clang :: OpenMPDirectiveKind getTargetCodeKind () { return TargetCodeKind ; }; const clang :: LangOptions & GetLangOpts () { return Context . getLangOpts (); } clang :: PrintingPolicy getPP () { return PP ; }; }; class TargetCodeRegion : public TargetCodeFragment { public : static bool classof ( const TargetCodeFragment * TCF ) { return ( TCF -> getKind () == TCFK_TargetCodeRegion || TCF -> getKind () == TCFK_TargetCodeFragment ); }; private : clang :: CapturedStmt * CapturedStmtNode ; clang :: OMPExecutableDirective * TargetDirective ; clang :: FunctionDecl * ParentFunctionDecl ; std :: vector < TargetRegionVariable > CapturedVars ; std :: vector < clang :: OMPClause *> OMPClauses ; std :: vector < clang :: VarDecl *> OMPClausesParams ; std :: set < clang :: VarDecl *> PrivateVars ; public : TargetCodeRegion ( clang :: CapturedStmt * CapturedStmtNode , clang :: OMPExecutableDirective * TargetDirective , clang :: FunctionDecl * ParentFunctionDecl , clang :: ASTContext & Context ) : TargetCodeFragment ( Context , TCFK_TargetCodeRegion ), CapturedStmtNode ( CapturedStmtNode ), TargetDirective ( TargetDirective ), ParentFunctionDecl ( ParentFunctionDecl ){}; using captured_vars_const_iterator = std :: vector < TargetRegionVariable >:: const_iterator ; using captured_vars_const_range = llvm :: iterator_range < captured_vars_const_iterator > ; using private_vars_const_iterator = std :: set < clang :: VarDecl *>:: const_iterator ; using private_vars_const_range = llvm :: iterator_range < private_vars_const_iterator > ; using ompclauses_params_const_iterator = std :: vector < clang :: VarDecl *>:: const_iterator ; using ompclauses_params_const_range = llvm :: iterator_range < ompclauses_params_const_iterator > ; void addCapture ( const clang :: CapturedStmt :: Capture * Capture ); captured_vars_const_iterator getCapturedVarsBegin () { return CapturedVars . begin (); }; captured_vars_const_iterator getCapturedVarsEnd () { return CapturedVars . end (); }; captured_vars_const_range capturedVars () { return captured_vars_const_range ( getCapturedVarsBegin (), getCapturedVarsEnd ()); }; void addOMPClause ( clang :: OMPClause * Clause ); const std :: vector < clang :: OMPClause *> & getOMPClauses () const { return OMPClauses ; }; void setPrivateVars ( const std :: set < clang :: VarDecl *> & VarSet ) { PrivateVars = VarSet ; }; private_vars_const_range privateVars () { return private_vars_const_range ( PrivateVars . cbegin (), PrivateVars . cend ()); }; ompclauses_params_const_range ompClausesParams () { return ompclauses_params_const_range ( OMPClausesParams . cbegin (), OMPClausesParams . cend ()); }; void addOMPClauseParam ( clang :: VarDecl * Param ); bool hasCombineConstruct () { return TargetCodeKind != clang :: OpenMPDirectiveKind :: OMPD_target ; } virtual std :: string PrintPretty () override ; clang :: SourceRange getRealRange () override ; clang :: SourceRange getInnerRange () override ; clang :: SourceRange getSpellingRange () override ; clang :: SourceLocation getStartLoc (); clang :: SourceLocation getEndLoc (); const std :: string getParentFuncName (); clang :: SourceLocation getTargetDirectiveLocation (); std :: map < clang :: VarDecl * , clang :: Expr *> CapturedLowerBounds ; }; class TargetCodeDecl : public TargetCodeFragment { public : static bool classof ( const TargetCodeFragment * TCF ) { return ( TCF -> getKind () == TCFK_TargetCodeDecl || TCF -> getKind () == TCFK_TargetCodeFragment ); }; private : clang :: Decl * DeclNode ; public : TargetCodeDecl ( clang :: Decl * Node ) : TargetCodeFragment ( Node -> getASTContext (), TCFK_TargetCodeDecl ), DeclNode ( Node ){}; virtual std :: string PrintPretty () override ; clang :: SourceRange getRealRange () override ; clang :: SourceRange getSpellingRange () override ; };","title":"Source code"},{"location":"internal/doxygen/Files/TargetCode_8cpp/","text":"src/TargetCode.cpp This file implements the class TargetCode , which can be used to add code fragments and to generate new code (i.e., for outlining OpenMP target region) from these fragments. Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 //===-- sotoc/src/TargetCode ------------------------ ---------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include <sstream> #include <string> #include \"clang/AST/Decl.h\" #include \"clang/AST/PrettyPrinter.h\" #include \"clang/AST/Stmt.h\" #include \"clang/AST/StmtOpenMP.h\" #include \"clang/Basic/SourceLocation.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Lex/Lexer.h\" #include \"llvm/ADT/APInt.h\" #include \"llvm/Support/FileSystem.h\" #include \"llvm/Support/Format.h\" #include \"llvm/Support/Process.h\" #include \"llvm/Support/raw_ostream.h\" #include \"Debug.h\" #include \"OmpPragma.h\" #include \"TargetCode.h\" bool TargetCode::addCodeFragment ( std :: shared_ptr < TargetCodeFragment > Frag , bool PushFront ) { for ( auto & F : CodeFragments ) { // Reject Fragments which are inside Fragments which we already have if (( SM . isPointWithin ( Frag -> getRealRange (). getBegin (), F -> getRealRange (). getBegin (), F -> getRealRange (). getEnd ()) && Frag -> getRealRange (). getBegin () != F -> getRealRange (). getBegin ()) && SM . isPointWithin ( Frag -> getRealRange (). getEnd (), F -> getRealRange (). getBegin (), F -> getRealRange (). getEnd ())) { return false ; } } if ( PushFront ) { CodeFragments . push_front ( Frag ); } else { CodeFragments . push_back ( Frag ); } return true ; } // TODO: Is this needed for something? bool TargetCode::addCodeFragmentFront ( std :: shared_ptr < TargetCodeFragment > Frag ) { return addCodeFragment ( Frag , true ); } void TargetCode::generateCode ( llvm :: raw_ostream & Out ) { bool stdlib = false ; bool unistd = false ; for ( auto & i : SystemHeaders ) { std :: string Header ( i ); size_t include_pos = Header . rfind ( \"nclude/\" ); if ( include_pos != std :: string :: npos ) { Header . erase ( 0 , include_pos + strlen ( \"nclude/\" )); } Out << \"#include <\" << Header << \"> \\n \" ; if ( Header . compare ( \"unistd.h\" ) == 0 ) { unistd = true ; } else if ( Header . compare ( \"stdlib.h\" ) == 0 ) { stdlib = true ; } } // Add extra libs for the debugging helper function if ( ! stdlib && std :: atoi ( llvm :: sys :: Process :: GetEnv ( \"NEC_TARGET_DELAY\" ) . getValueOr ( \"0\" ) . c_str ())) { Out << \"#include <stdlib.h> \\n \" ; } if ( ! unistd && std :: atoi ( llvm :: sys :: Process :: GetEnv ( \"NEC_TARGET_DELAY\" ) . getValueOr ( \"0\" ) . c_str ())) { Out << \"#include <unistd.h> \\n \" ; } // Override omp_is_initial_device() with macro, because this // Out << \"static inline int omp_is_initial_device(void) {return 0;}\\n\"; // fails with the clang compiler. This still might cause problems, if // someone tries to include the omp.h header after the prolouge. Out << \"#define omp_is_initial_device() 0 \\n \" ; Out << \"#define omp_get_thread_limit() omp_get_num_threads() \\n \" ; for ( auto i = CodeFragments . begin (), e = CodeFragments . end (); i != e ; ++ i ) { std :: shared_ptr < TargetCodeFragment > Frag = * i ; auto * TCR = llvm :: dyn_cast < TargetCodeRegion > ( Frag . get ()); if ( TCR ) { generateFunctionPrologue ( TCR , Out ); } Out << Frag -> PrintPretty (); if ( TCR ) { generateFunctionEpilogue ( TCR , Out ); } if ( Frag -> NeedsSemicolon ) { Out << \";\" ; } Out << \" \\n \" ; } Out << \"#undef omp_is_initial_device \\n \" ; Out << \"#undef omp_get_thread_limit \\n \" ; } void TargetCode::generateArgument ( const TargetRegionVariable & Arg , llvm :: raw_ostream & Out ) { std :: string LHSStore ; std :: string RHSStore ; llvm :: raw_string_ostream LHS ( LHSStore ); llvm :: raw_string_ostream RHS ( RHSStore ); for ( auto & Shape : Arg . shapes ()) { if ( Shape . isPointer ()) { LHS << \"(*\" ; RHS << \")\" ; } else if ( Shape . isConstantArray ()) { RHS << \"[\" << Shape . getConstantDimensionExpr () << \"]\" ; } else if ( Shape . isVariableArray ()) { RHS << \"[]\" ; } } Out << LHS . str () << Arg . name () << RHS . str (); } void TargetCode::generateVariableDecl ( const TargetRegionVariable & Var , llvm :: raw_ostream & Out ) { std :: string lValueStore = std :: string ( Var . name ());; std :: string rValueStore = std :: string (); for ( auto Shape : Var . shapes ()) { switch ( Shape . getKind ()) { case TargetRegionVariableShape :: ShapeKind :: Pointer : lValueStore = \"*\" + lValueStore ; rValueStore = \"*\" + rValueStore ; break ; case TargetRegionVariableShape :: ShapeKind :: Paren : if ( rValueStore . empty ()) { break ; } lValueStore = \"(\" + lValueStore + \")\" ; rValueStore = \"(\" + rValueStore + \")\" ; break ; case TargetRegionVariableShape :: ShapeKind :: ConstantArray : if ( rValueStore . empty ()) { // make first dimension of array implicit in cast lValueStore = \"(* \" + lValueStore + \")\" ; rValueStore = \"(*)\" ; break ; } lValueStore = lValueStore + \"[\" + Shape . getConstantDimensionExpr (). str () + \"]\" ; rValueStore = rValueStore + \"[\" + Shape . getConstantDimensionExpr (). str () + \"]\" ; break ; case TargetRegionVariableShape :: ShapeKind :: VariableArray : if ( rValueStore . empty ()) { // make first dimension of array implicit lValueStore = \"(* \" + lValueStore + \")\" ; rValueStore = \"(*)\" ; break ; } lValueStore = lValueStore + \"[\" + \"__sotoc_vla_dim\" + std :: to_string ( Shape . getVariableDimensionIndex ()) + \"_\" + Var . name (). str () + \"]\" ; rValueStore = rValueStore + \"[\" + \"__sotoc_vla_dim\" + std :: to_string ( Shape . getVariableDimensionIndex ()) + \"_\" + Var . name (). str () + \"]\" ; break ; } } // Finish the l-value (by adding the base type) lValueStore = Var . baseTypeName (). str () + \" \" + lValueStore ; // Finish the r-value (modify value and then add transferred variable name) if ( rValueStore . empty ()) { // Scalar being passed by pointer; dereference transferred value rValueStore = \"*\" ; } else { // Currently rValueStore contains a type usefull for an explicit cast of the // transferred variable, which would be completed as follows: //rValueStore = \"(\" + Var.baseTypeName().str() + rValueStore + \") \"; // We currently do not need this cast, so we simply empty rValueStore rValueStore = \"\" ; } rValueStore = rValueStore + \"__sotoc_var_\" + Var . name (). str (); // Output the finished declaration to the output stream Out << \" \" << lValueStore << \" = \" << rValueStore << \"; \\n \" ; } void TargetCode::generateFunctionPrologue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ) { bool first = true ; Out << \"void \" << generateFunctionName ( TCR ) << \"(\" ; for ( auto & Var : TCR -> capturedVars ()) { if ( ! first ) { Out << \", \" ; } else { first = false ; } if ( Var . containsArray ()) { for ( auto & d : Var . variableArrayShapes ()) { Out << \"unsigned long long __sotoc_vla_dim\" << d . getVariableDimensionIndex () << \"_\" << Var . name () << \", \" ; } } // Because arrays (and nested pointers) are passed by reference and // (for our purposes) their type is 'void', the rest of their handling // is the same as for scalars. if ( Var . containsArray () || Var . containsPointer ()) { Out << \"void \" ; } else { // In cases where we get a first-private float, we want to recieve the // full 64 bit we input into veo. We then later can change the type back // to float. I suspect some weirdness with IEEE 754 and the change of // variable length from 32 to 64 and back to 32 bit. if ( ! Var . passedByPointer () && Var . baseTypeName () == \"float\" ) { Out << \"unsigned long long __sotoc_conv_var_\" ; } else { Out << Var . baseTypeName () << \" \" ; } } if ( Var . passedByPointer ()) { Out << \"*__sotoc_var_\" << Var . name (); } else { generateArgument ( Var , Out ); } } unsigned int clauseParam = 0 ; for ( auto C : TCR -> getOMPClauses ()) { if (( C -> getClauseKind () == clang :: OpenMPClauseKind :: OMPC_num_threads || C -> getClauseKind () == clang :: OpenMPClauseKind :: OMPC_thread_limit ) && ! C -> isImplicit ()) { if ( ! first ) { Out << \", \" ; } else { first = false ; } Out << \"int __sotoc_clause_param_\" << std :: to_string ( clauseParam ) << \" \" ; clauseParam ++ ; } } Out << \") \\n { \\n \" ; // Target Delay if ( std :: atoi ( llvm :: sys :: Process :: GetEnv ( \"NEC_TARGET_DELAY\" ) . getValueOr ( \"0\" ) . c_str ())) { Out << \"sleep(atoi((getenv( \\\" NEC_TARGET_DELAY \\\" ) != NULL) ? \" \"getenv( \\\" NEC_TARGET_DELAY \\\" ) : \\\" 0 \\\" )); \\n \" ; } // bring captured scalars into scope for ( auto & Var : TCR -> capturedVars ()) { // Ignore everything not passed by reference here if ( Var . passedByPointer ()) { generateVariableDecl ( Var , Out ); // We may also have to adjust the array bounds if we only get a slice // of the array; Move the bounds if we have a slice here // (Only necessary in the first dimesion. All other dimensions should // not require adjustment as their slicing is ignored) if ( Var . containsArray ()) { // Move the bounds if we have a slice auto LowerBound = Var . arrayLowerBound (); if ( LowerBound . hasValue ()) { Out << \" \" << Var . name () << \" = \" << Var . name () << \" - \" ; LowerBound . getValue () -> printPretty ( Out , NULL , TCR -> getPP ()); Out << \"; \\n \" ; } } // After recieving floats as unsigned long long we want to change them // back to floats but without conversion as they already are formated // according to 32 bit floating point spec. } else if ( ! Var . passedByPointer () && Var . baseTypeName () == \"float\" ) { Out << \"float \" << Var . name () << \" = *(float*)&(__sotoc_conv_var_\" << Var . name () << \"); \\n \" ; } } // Generate local declarations. for ( auto * privateVar : TCR -> privateVars ()) { Out << \" \" << privateVar -> getType (). getAsString () << \" \" << privateVar -> getName () << \"; \\n \" ; } // The runtime can decide to only create one team. // Therfore, replace target teams constructs. if ( TCR -> hasCombineConstruct ()) { OmpPragma Pragma ( TCR ); Pragma . printReplacement ( Out ); if ( Pragma . needsStructuredBlock ()) { Out << \" \\n {\" ; } } Out << \" \\n \" ; } void TargetCode::generateFunctionEpilogue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ) { if ( OmpPragma ( TCR ). needsStructuredBlock ()) { Out << \" \\n }\" ; } Out << \" \\n \" ; // copy values from scalars from scoped vars back into pointers for ( auto & Var : TCR -> capturedVars ()) { if ( Var . passedByPointer () && ! Var . containsPointer () && ! Var . containsArray ()) { Out << \" \\n *__sotoc_var_\" << Var . name () << \" = \" << Var . name () << \";\" ; } else if ( Var . containsPointer ()){ Out << \" \\n __sotoc_var_\" << Var . name () << \" = \" << Var . name () << \";\" ; } } Out << \" \\n } \\n \" ; } std :: string TargetCode::generateFunctionName ( TargetCodeRegion * TCR ) { // TODO: this function needs error handling llvm :: sys :: fs :: UniqueID ID ; clang :: PresumedLoc PLoc = SM . getPresumedLoc ( TCR -> getTargetDirectiveLocation ()); llvm :: sys :: fs :: getUniqueID ( PLoc . getFilename (), ID ); uint64_t DeviceID = ID . getDevice (); uint64_t FileID = ID . getFile (); unsigned LineNum = PLoc . getLine (); std :: string FunctionName ; llvm :: raw_string_ostream fns ( FunctionName ); fns << \"__omp_offloading\" << llvm :: format ( \"_%x\" , DeviceID ) << llvm :: format ( \"_%x_\" , FileID ) << TCR -> getParentFuncName () << \"_l\" << LineNum ; return FunctionName ; }","title":"src/TargetCode.cpp"},{"location":"internal/doxygen/Files/TargetCode_8cpp/#srctargetcodecpp","text":"This file implements the class TargetCode , which can be used to add code fragments and to generate new code (i.e., for outlining OpenMP target region) from these fragments.","title":"src/TargetCode.cpp"},{"location":"internal/doxygen/Files/TargetCode_8cpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 //===-- sotoc/src/TargetCode ------------------------ ---------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include <sstream> #include <string> #include \"clang/AST/Decl.h\" #include \"clang/AST/PrettyPrinter.h\" #include \"clang/AST/Stmt.h\" #include \"clang/AST/StmtOpenMP.h\" #include \"clang/Basic/SourceLocation.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Lex/Lexer.h\" #include \"llvm/ADT/APInt.h\" #include \"llvm/Support/FileSystem.h\" #include \"llvm/Support/Format.h\" #include \"llvm/Support/Process.h\" #include \"llvm/Support/raw_ostream.h\" #include \"Debug.h\" #include \"OmpPragma.h\" #include \"TargetCode.h\" bool TargetCode::addCodeFragment ( std :: shared_ptr < TargetCodeFragment > Frag , bool PushFront ) { for ( auto & F : CodeFragments ) { // Reject Fragments which are inside Fragments which we already have if (( SM . isPointWithin ( Frag -> getRealRange (). getBegin (), F -> getRealRange (). getBegin (), F -> getRealRange (). getEnd ()) && Frag -> getRealRange (). getBegin () != F -> getRealRange (). getBegin ()) && SM . isPointWithin ( Frag -> getRealRange (). getEnd (), F -> getRealRange (). getBegin (), F -> getRealRange (). getEnd ())) { return false ; } } if ( PushFront ) { CodeFragments . push_front ( Frag ); } else { CodeFragments . push_back ( Frag ); } return true ; } // TODO: Is this needed for something? bool TargetCode::addCodeFragmentFront ( std :: shared_ptr < TargetCodeFragment > Frag ) { return addCodeFragment ( Frag , true ); } void TargetCode::generateCode ( llvm :: raw_ostream & Out ) { bool stdlib = false ; bool unistd = false ; for ( auto & i : SystemHeaders ) { std :: string Header ( i ); size_t include_pos = Header . rfind ( \"nclude/\" ); if ( include_pos != std :: string :: npos ) { Header . erase ( 0 , include_pos + strlen ( \"nclude/\" )); } Out << \"#include <\" << Header << \"> \\n \" ; if ( Header . compare ( \"unistd.h\" ) == 0 ) { unistd = true ; } else if ( Header . compare ( \"stdlib.h\" ) == 0 ) { stdlib = true ; } } // Add extra libs for the debugging helper function if ( ! stdlib && std :: atoi ( llvm :: sys :: Process :: GetEnv ( \"NEC_TARGET_DELAY\" ) . getValueOr ( \"0\" ) . c_str ())) { Out << \"#include <stdlib.h> \\n \" ; } if ( ! unistd && std :: atoi ( llvm :: sys :: Process :: GetEnv ( \"NEC_TARGET_DELAY\" ) . getValueOr ( \"0\" ) . c_str ())) { Out << \"#include <unistd.h> \\n \" ; } // Override omp_is_initial_device() with macro, because this // Out << \"static inline int omp_is_initial_device(void) {return 0;}\\n\"; // fails with the clang compiler. This still might cause problems, if // someone tries to include the omp.h header after the prolouge. Out << \"#define omp_is_initial_device() 0 \\n \" ; Out << \"#define omp_get_thread_limit() omp_get_num_threads() \\n \" ; for ( auto i = CodeFragments . begin (), e = CodeFragments . end (); i != e ; ++ i ) { std :: shared_ptr < TargetCodeFragment > Frag = * i ; auto * TCR = llvm :: dyn_cast < TargetCodeRegion > ( Frag . get ()); if ( TCR ) { generateFunctionPrologue ( TCR , Out ); } Out << Frag -> PrintPretty (); if ( TCR ) { generateFunctionEpilogue ( TCR , Out ); } if ( Frag -> NeedsSemicolon ) { Out << \";\" ; } Out << \" \\n \" ; } Out << \"#undef omp_is_initial_device \\n \" ; Out << \"#undef omp_get_thread_limit \\n \" ; } void TargetCode::generateArgument ( const TargetRegionVariable & Arg , llvm :: raw_ostream & Out ) { std :: string LHSStore ; std :: string RHSStore ; llvm :: raw_string_ostream LHS ( LHSStore ); llvm :: raw_string_ostream RHS ( RHSStore ); for ( auto & Shape : Arg . shapes ()) { if ( Shape . isPointer ()) { LHS << \"(*\" ; RHS << \")\" ; } else if ( Shape . isConstantArray ()) { RHS << \"[\" << Shape . getConstantDimensionExpr () << \"]\" ; } else if ( Shape . isVariableArray ()) { RHS << \"[]\" ; } } Out << LHS . str () << Arg . name () << RHS . str (); } void TargetCode::generateVariableDecl ( const TargetRegionVariable & Var , llvm :: raw_ostream & Out ) { std :: string lValueStore = std :: string ( Var . name ());; std :: string rValueStore = std :: string (); for ( auto Shape : Var . shapes ()) { switch ( Shape . getKind ()) { case TargetRegionVariableShape :: ShapeKind :: Pointer : lValueStore = \"*\" + lValueStore ; rValueStore = \"*\" + rValueStore ; break ; case TargetRegionVariableShape :: ShapeKind :: Paren : if ( rValueStore . empty ()) { break ; } lValueStore = \"(\" + lValueStore + \")\" ; rValueStore = \"(\" + rValueStore + \")\" ; break ; case TargetRegionVariableShape :: ShapeKind :: ConstantArray : if ( rValueStore . empty ()) { // make first dimension of array implicit in cast lValueStore = \"(* \" + lValueStore + \")\" ; rValueStore = \"(*)\" ; break ; } lValueStore = lValueStore + \"[\" + Shape . getConstantDimensionExpr (). str () + \"]\" ; rValueStore = rValueStore + \"[\" + Shape . getConstantDimensionExpr (). str () + \"]\" ; break ; case TargetRegionVariableShape :: ShapeKind :: VariableArray : if ( rValueStore . empty ()) { // make first dimension of array implicit lValueStore = \"(* \" + lValueStore + \")\" ; rValueStore = \"(*)\" ; break ; } lValueStore = lValueStore + \"[\" + \"__sotoc_vla_dim\" + std :: to_string ( Shape . getVariableDimensionIndex ()) + \"_\" + Var . name (). str () + \"]\" ; rValueStore = rValueStore + \"[\" + \"__sotoc_vla_dim\" + std :: to_string ( Shape . getVariableDimensionIndex ()) + \"_\" + Var . name (). str () + \"]\" ; break ; } } // Finish the l-value (by adding the base type) lValueStore = Var . baseTypeName (). str () + \" \" + lValueStore ; // Finish the r-value (modify value and then add transferred variable name) if ( rValueStore . empty ()) { // Scalar being passed by pointer; dereference transferred value rValueStore = \"*\" ; } else { // Currently rValueStore contains a type usefull for an explicit cast of the // transferred variable, which would be completed as follows: //rValueStore = \"(\" + Var.baseTypeName().str() + rValueStore + \") \"; // We currently do not need this cast, so we simply empty rValueStore rValueStore = \"\" ; } rValueStore = rValueStore + \"__sotoc_var_\" + Var . name (). str (); // Output the finished declaration to the output stream Out << \" \" << lValueStore << \" = \" << rValueStore << \"; \\n \" ; } void TargetCode::generateFunctionPrologue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ) { bool first = true ; Out << \"void \" << generateFunctionName ( TCR ) << \"(\" ; for ( auto & Var : TCR -> capturedVars ()) { if ( ! first ) { Out << \", \" ; } else { first = false ; } if ( Var . containsArray ()) { for ( auto & d : Var . variableArrayShapes ()) { Out << \"unsigned long long __sotoc_vla_dim\" << d . getVariableDimensionIndex () << \"_\" << Var . name () << \", \" ; } } // Because arrays (and nested pointers) are passed by reference and // (for our purposes) their type is 'void', the rest of their handling // is the same as for scalars. if ( Var . containsArray () || Var . containsPointer ()) { Out << \"void \" ; } else { // In cases where we get a first-private float, we want to recieve the // full 64 bit we input into veo. We then later can change the type back // to float. I suspect some weirdness with IEEE 754 and the change of // variable length from 32 to 64 and back to 32 bit. if ( ! Var . passedByPointer () && Var . baseTypeName () == \"float\" ) { Out << \"unsigned long long __sotoc_conv_var_\" ; } else { Out << Var . baseTypeName () << \" \" ; } } if ( Var . passedByPointer ()) { Out << \"*__sotoc_var_\" << Var . name (); } else { generateArgument ( Var , Out ); } } unsigned int clauseParam = 0 ; for ( auto C : TCR -> getOMPClauses ()) { if (( C -> getClauseKind () == clang :: OpenMPClauseKind :: OMPC_num_threads || C -> getClauseKind () == clang :: OpenMPClauseKind :: OMPC_thread_limit ) && ! C -> isImplicit ()) { if ( ! first ) { Out << \", \" ; } else { first = false ; } Out << \"int __sotoc_clause_param_\" << std :: to_string ( clauseParam ) << \" \" ; clauseParam ++ ; } } Out << \") \\n { \\n \" ; // Target Delay if ( std :: atoi ( llvm :: sys :: Process :: GetEnv ( \"NEC_TARGET_DELAY\" ) . getValueOr ( \"0\" ) . c_str ())) { Out << \"sleep(atoi((getenv( \\\" NEC_TARGET_DELAY \\\" ) != NULL) ? \" \"getenv( \\\" NEC_TARGET_DELAY \\\" ) : \\\" 0 \\\" )); \\n \" ; } // bring captured scalars into scope for ( auto & Var : TCR -> capturedVars ()) { // Ignore everything not passed by reference here if ( Var . passedByPointer ()) { generateVariableDecl ( Var , Out ); // We may also have to adjust the array bounds if we only get a slice // of the array; Move the bounds if we have a slice here // (Only necessary in the first dimesion. All other dimensions should // not require adjustment as their slicing is ignored) if ( Var . containsArray ()) { // Move the bounds if we have a slice auto LowerBound = Var . arrayLowerBound (); if ( LowerBound . hasValue ()) { Out << \" \" << Var . name () << \" = \" << Var . name () << \" - \" ; LowerBound . getValue () -> printPretty ( Out , NULL , TCR -> getPP ()); Out << \"; \\n \" ; } } // After recieving floats as unsigned long long we want to change them // back to floats but without conversion as they already are formated // according to 32 bit floating point spec. } else if ( ! Var . passedByPointer () && Var . baseTypeName () == \"float\" ) { Out << \"float \" << Var . name () << \" = *(float*)&(__sotoc_conv_var_\" << Var . name () << \"); \\n \" ; } } // Generate local declarations. for ( auto * privateVar : TCR -> privateVars ()) { Out << \" \" << privateVar -> getType (). getAsString () << \" \" << privateVar -> getName () << \"; \\n \" ; } // The runtime can decide to only create one team. // Therfore, replace target teams constructs. if ( TCR -> hasCombineConstruct ()) { OmpPragma Pragma ( TCR ); Pragma . printReplacement ( Out ); if ( Pragma . needsStructuredBlock ()) { Out << \" \\n {\" ; } } Out << \" \\n \" ; } void TargetCode::generateFunctionEpilogue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ) { if ( OmpPragma ( TCR ). needsStructuredBlock ()) { Out << \" \\n }\" ; } Out << \" \\n \" ; // copy values from scalars from scoped vars back into pointers for ( auto & Var : TCR -> capturedVars ()) { if ( Var . passedByPointer () && ! Var . containsPointer () && ! Var . containsArray ()) { Out << \" \\n *__sotoc_var_\" << Var . name () << \" = \" << Var . name () << \";\" ; } else if ( Var . containsPointer ()){ Out << \" \\n __sotoc_var_\" << Var . name () << \" = \" << Var . name () << \";\" ; } } Out << \" \\n } \\n \" ; } std :: string TargetCode::generateFunctionName ( TargetCodeRegion * TCR ) { // TODO: this function needs error handling llvm :: sys :: fs :: UniqueID ID ; clang :: PresumedLoc PLoc = SM . getPresumedLoc ( TCR -> getTargetDirectiveLocation ()); llvm :: sys :: fs :: getUniqueID ( PLoc . getFilename (), ID ); uint64_t DeviceID = ID . getDevice (); uint64_t FileID = ID . getFile (); unsigned LineNum = PLoc . getLine (); std :: string FunctionName ; llvm :: raw_string_ostream fns ( FunctionName ); fns << \"__omp_offloading\" << llvm :: format ( \"_%x\" , DeviceID ) << llvm :: format ( \"_%x_\" , FileID ) << TCR -> getParentFuncName () << \"_l\" << LineNum ; return FunctionName ; }","title":"Source code"},{"location":"internal/doxygen/Files/TargetCode_8h/","text":"src/TargetCode.h Namespaces Name clang Classes Name class TargetCode A collection of all code from the input file that needs to be copied to the target source file. Types Name using std::deque< std::shared_ptr< TargetCodeFragment >> TargetCodeFragmentDeque Attributes Name int clauseparam Types Documentation using TargetCodeFragmentDeque 1 using TargetCodeFragmentDeque = std :: deque < std :: shared_ptr < TargetCodeFragment >> ; Attributes Documentation variable clauseparam 1 int clauseparam ; Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 //===-- sotoc/src/TargetCode.h --------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// #pragma once #include <deque> #include <memory> #include <set> #include <string> #include \"clang/Rewrite/Core/Rewriter.h\" #include \"TargetCodeFragment.h\" namespace clang { class SourceManager ; } using TargetCodeFragmentDeque = std :: deque < std :: shared_ptr < TargetCodeFragment >> ; extern int clauseparam ; class TargetCode { TargetCodeFragmentDeque CodeFragments ; std :: set < std :: string > SystemHeaders ; clang :: Rewriter & TargetCodeRewriter ; clang :: SourceManager & SM ; public : TargetCode ( clang :: Rewriter & TargetCodeRewriter ) : TargetCodeRewriter ( TargetCodeRewriter ), SM ( TargetCodeRewriter . getSourceMgr ()){}; bool addCodeFragment ( std :: shared_ptr < TargetCodeFragment > Frag , bool PushFront = false ); bool addCodeFragmentFront ( std :: shared_ptr < TargetCodeFragment > Fag ); void generateCode ( llvm :: raw_ostream & Out ); TargetCodeFragmentDeque :: const_iterator getCodeFragmentsBegin () { return CodeFragments . begin (); } TargetCodeFragmentDeque :: const_iterator getCodeFragmentsEnd () { return CodeFragments . end (); } void addHeader ( const std :: string & Header ) { SystemHeaders . insert ( Header ); } private : void generateVariableDecl ( const TargetRegionVariable & Var , llvm :: raw_ostream & Out ); void generateFunctionPrologue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ); void generateFunctionEpilogue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ); std :: string generateFunctionName ( TargetCodeRegion * TCR ); void generateArgument ( const TargetRegionVariable & Aarg , llvm :: raw_ostream & Out ); };","title":"src/TargetCode.h"},{"location":"internal/doxygen/Files/TargetCode_8h/#srctargetcodeh","text":"","title":"src/TargetCode.h"},{"location":"internal/doxygen/Files/TargetCode_8h/#namespaces","text":"Name clang","title":"Namespaces"},{"location":"internal/doxygen/Files/TargetCode_8h/#classes","text":"Name class TargetCode A collection of all code from the input file that needs to be copied to the target source file.","title":"Classes"},{"location":"internal/doxygen/Files/TargetCode_8h/#types","text":"Name using std::deque< std::shared_ptr< TargetCodeFragment >> TargetCodeFragmentDeque","title":"Types"},{"location":"internal/doxygen/Files/TargetCode_8h/#attributes","text":"Name int clauseparam","title":"Attributes"},{"location":"internal/doxygen/Files/TargetCode_8h/#types-documentation","text":"","title":"Types Documentation"},{"location":"internal/doxygen/Files/TargetCode_8h/#using-targetcodefragmentdeque","text":"1 using TargetCodeFragmentDeque = std :: deque < std :: shared_ptr < TargetCodeFragment >> ;","title":"using TargetCodeFragmentDeque"},{"location":"internal/doxygen/Files/TargetCode_8h/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"internal/doxygen/Files/TargetCode_8h/#variable-clauseparam","text":"1 int clauseparam ;","title":"variable clauseparam"},{"location":"internal/doxygen/Files/TargetCode_8h/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 //===-- sotoc/src/TargetCode.h --------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// #pragma once #include <deque> #include <memory> #include <set> #include <string> #include \"clang/Rewrite/Core/Rewriter.h\" #include \"TargetCodeFragment.h\" namespace clang { class SourceManager ; } using TargetCodeFragmentDeque = std :: deque < std :: shared_ptr < TargetCodeFragment >> ; extern int clauseparam ; class TargetCode { TargetCodeFragmentDeque CodeFragments ; std :: set < std :: string > SystemHeaders ; clang :: Rewriter & TargetCodeRewriter ; clang :: SourceManager & SM ; public : TargetCode ( clang :: Rewriter & TargetCodeRewriter ) : TargetCodeRewriter ( TargetCodeRewriter ), SM ( TargetCodeRewriter . getSourceMgr ()){}; bool addCodeFragment ( std :: shared_ptr < TargetCodeFragment > Frag , bool PushFront = false ); bool addCodeFragmentFront ( std :: shared_ptr < TargetCodeFragment > Fag ); void generateCode ( llvm :: raw_ostream & Out ); TargetCodeFragmentDeque :: const_iterator getCodeFragmentsBegin () { return CodeFragments . begin (); } TargetCodeFragmentDeque :: const_iterator getCodeFragmentsEnd () { return CodeFragments . end (); } void addHeader ( const std :: string & Header ) { SystemHeaders . insert ( Header ); } private : void generateVariableDecl ( const TargetRegionVariable & Var , llvm :: raw_ostream & Out ); void generateFunctionPrologue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ); void generateFunctionEpilogue ( TargetCodeRegion * TCR , llvm :: raw_ostream & Out ); std :: string generateFunctionName ( TargetCodeRegion * TCR ); void generateArgument ( const TargetRegionVariable & Aarg , llvm :: raw_ostream & Out ); };","title":"Source code"},{"location":"internal/doxygen/Files/TargetRegionVariable_8cpp/","text":"src/TargetRegionVariable.cpp This file implements the class TargetRegionVariable . Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 //===-- sotoc/src/TargetRegionVariable.cpp --------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \"clang/AST/Decl.h\" #include \"clang/AST/Expr.h\" #include \"clang/AST/Type.h\" #include \"TargetRegionVariable.h\" TargetRegionVariable :: TargetRegionVariable ( const clang :: CapturedStmt :: Capture * Capture , const std :: map < clang :: VarDecl * , clang :: Expr *> & MappingLowerBounds ) : Capture ( Capture ), Decl ( Capture -> getCapturedVar ()), NumVariableArrayDims ( 0 ), OmpMappingLowerBound ( MappingLowerBounds ) { VarName = Decl -> getDeclName (). getAsString (); determineShapes ( Decl -> getType ()); } void TargetRegionVariable :: determineShapes ( const clang :: QualType T ) { // We want to determine the shapes of this variable from it's qualifiers if ( const auto * AT = llvm :: dyn_cast < clang :: ArrayType > ( T . getTypePtr ())) { // We have a constant or variable length array if ( const auto * CAT = llvm :: dyn_cast < clang :: ConstantArrayType > ( AT )) { Shapes . push_back ( TargetRegionVariableShape ( CAT )); } else if ( const auto * VAT = llvm :: dyn_cast < clang :: VariableArrayType > ( AT )) { Shapes . push_back ( TargetRegionVariableShape ( VAT , NumVariableArrayDims )); } // The variable NumVariableArrayDims is basically stored to keep track how // many array dimensions there are. Each variable length array dimension we // record gets an index, later used to generate the __sotoc_vla_dimX // parameters in which the host sends the variable size to the target // region. NumVariableArrayDims ++ ; return determineShapes ( AT -> getElementType ()); } else if ( auto * PT = llvm :: dyn_cast < clang :: PointerType > ( T . getTypePtr ())) { // Pointers are easy: just record that we have a pointer (default constructed) Shapes . push_back ( TargetRegionVariableShape ()); return determineShapes ( PT -> getPointeeType ()); } else if ( auto * PT = llvm :: dyn_cast < clang :: ParenType > ( T . getTypePtr ())) { // Clang uses ParenType as when there are parenthesis in the type declaration. Shapes . push_back ( TargetRegionVariableShape ( PT )); return determineShapes ( PT -> getInnerType ()); } else { // We have found the base type (without array dimensions or pointer specifiers). BaseTypeName = T . getAsString (); } } bool TargetRegionVariable :: containsArray () const { if ( ! Shapes . empty ()) { for ( auto Shape : Shapes ) { if ( Shape . isArray ()) { return true ; } } } return false ; } bool TargetRegionVariable :: containsPointer () const { if ( ! Shapes . empty ()) { for ( auto Shape : Shapes ) { if ( Shape . isPointer ()) { return true ; } } } return false ; } //TODO: We might not need this anymore bool TargetRegionVariable :: passedByPointer () const { if ( containsArray () || containsPointer ()) { // Arrays are always passed by pointer return true ; } return Capture -> capturesVariable (); } llvm :: Optional < clang :: Expr *> TargetRegionVariable :: arrayLowerBound () const { auto FindBound = OmpMappingLowerBound . find ( Decl ); if ( FindBound != OmpMappingLowerBound . cend ()) { return llvm :: Optional < clang :: Expr *> ( FindBound -> second ); } return llvm :: Optional < clang :: Expr *> (); }","title":"src/TargetRegionVariable.cpp"},{"location":"internal/doxygen/Files/TargetRegionVariable_8cpp/#srctargetregionvariablecpp","text":"This file implements the class TargetRegionVariable .","title":"src/TargetRegionVariable.cpp"},{"location":"internal/doxygen/Files/TargetRegionVariable_8cpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 //===-- sotoc/src/TargetRegionVariable.cpp --------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include \"clang/AST/Decl.h\" #include \"clang/AST/Expr.h\" #include \"clang/AST/Type.h\" #include \"TargetRegionVariable.h\" TargetRegionVariable :: TargetRegionVariable ( const clang :: CapturedStmt :: Capture * Capture , const std :: map < clang :: VarDecl * , clang :: Expr *> & MappingLowerBounds ) : Capture ( Capture ), Decl ( Capture -> getCapturedVar ()), NumVariableArrayDims ( 0 ), OmpMappingLowerBound ( MappingLowerBounds ) { VarName = Decl -> getDeclName (). getAsString (); determineShapes ( Decl -> getType ()); } void TargetRegionVariable :: determineShapes ( const clang :: QualType T ) { // We want to determine the shapes of this variable from it's qualifiers if ( const auto * AT = llvm :: dyn_cast < clang :: ArrayType > ( T . getTypePtr ())) { // We have a constant or variable length array if ( const auto * CAT = llvm :: dyn_cast < clang :: ConstantArrayType > ( AT )) { Shapes . push_back ( TargetRegionVariableShape ( CAT )); } else if ( const auto * VAT = llvm :: dyn_cast < clang :: VariableArrayType > ( AT )) { Shapes . push_back ( TargetRegionVariableShape ( VAT , NumVariableArrayDims )); } // The variable NumVariableArrayDims is basically stored to keep track how // many array dimensions there are. Each variable length array dimension we // record gets an index, later used to generate the __sotoc_vla_dimX // parameters in which the host sends the variable size to the target // region. NumVariableArrayDims ++ ; return determineShapes ( AT -> getElementType ()); } else if ( auto * PT = llvm :: dyn_cast < clang :: PointerType > ( T . getTypePtr ())) { // Pointers are easy: just record that we have a pointer (default constructed) Shapes . push_back ( TargetRegionVariableShape ()); return determineShapes ( PT -> getPointeeType ()); } else if ( auto * PT = llvm :: dyn_cast < clang :: ParenType > ( T . getTypePtr ())) { // Clang uses ParenType as when there are parenthesis in the type declaration. Shapes . push_back ( TargetRegionVariableShape ( PT )); return determineShapes ( PT -> getInnerType ()); } else { // We have found the base type (without array dimensions or pointer specifiers). BaseTypeName = T . getAsString (); } } bool TargetRegionVariable :: containsArray () const { if ( ! Shapes . empty ()) { for ( auto Shape : Shapes ) { if ( Shape . isArray ()) { return true ; } } } return false ; } bool TargetRegionVariable :: containsPointer () const { if ( ! Shapes . empty ()) { for ( auto Shape : Shapes ) { if ( Shape . isPointer ()) { return true ; } } } return false ; } //TODO: We might not need this anymore bool TargetRegionVariable :: passedByPointer () const { if ( containsArray () || containsPointer ()) { // Arrays are always passed by pointer return true ; } return Capture -> capturesVariable (); } llvm :: Optional < clang :: Expr *> TargetRegionVariable :: arrayLowerBound () const { auto FindBound = OmpMappingLowerBound . find ( Decl ); if ( FindBound != OmpMappingLowerBound . cend ()) { return llvm :: Optional < clang :: Expr *> ( FindBound -> second ); } return llvm :: Optional < clang :: Expr *> (); }","title":"Source code"},{"location":"internal/doxygen/Files/TargetRegionVariable_8h/","text":"src/TargetRegionVariable.h Namespaces Name clang Classes Name class TargetRegionVariableShape Describes the shape, i.e. class TargetRegionVariable Represents a variable captured by a target region. class TargetRegionVariable::shape_const_kind_iterator Iterator which acts as a filter over std::vector ::const_iterator (the base_iter) which only passes on TargetRegionVariableShape of the kind specified in Kind . Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 //===-- sotoc/src/TargetRegionVariable.h ----------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// #pragma once #include <map> #include <vector> #include \"llvm/ADT/StringExtras.h\" namespace clang { class Expr ; class VarDecl ; class CapturedStmt ; } // namespace clang class TargetRegionVariableShape { public : enum ShapeKind { Pointer , Paren , ConstantArray , VariableArray }; private : unsigned int VariableDimensionIndex ; std :: string ConstantDimensionExpr ; ShapeKind Kind ; public : inline ShapeKind getKind () const { return Kind ; } inline bool isVariableArray () const { return Kind == ShapeKind :: VariableArray ; } inline bool isConstantArray () const { return Kind == ShapeKind :: ConstantArray ; } inline bool isArray () const { return Kind == ShapeKind :: VariableArray || Kind == ShapeKind :: ConstantArray ; } inline bool isPointer () const { return Kind == ShapeKind :: Pointer ; } inline unsigned int getVariableDimensionIndex () const { return VariableDimensionIndex ; } inline llvm :: StringRef getConstantDimensionExpr () const { return llvm :: StringRef ( ConstantDimensionExpr ); } TargetRegionVariableShape () : Kind ( ShapeKind :: Pointer ){}; TargetRegionVariableShape ( const clang :: ParenType * Paren ) : Kind ( ShapeKind :: Paren ){}; TargetRegionVariableShape ( const clang :: VariableArrayType * Array , unsigned int DimIndex ) : VariableDimensionIndex ( DimIndex ), Kind ( ShapeKind :: VariableArray ){}; TargetRegionVariableShape ( const clang :: ConstantArrayType * Array ) : Kind ( ShapeKind :: ConstantArray ) { ConstantDimensionExpr = toString ( Array -> getSize (), 10 , false ); } }; class TargetRegionVariable { public : using shape_const_iterator = std :: vector < TargetRegionVariableShape >:: const_iterator ; using shape_const_range = llvm :: iterator_range < shape_const_iterator > ; // https://clang.llvm.org/doxygen/Redeclarable_8h_source.html#l00239 class shape_const_kind_iterator { public : using base_iter = std :: vector < TargetRegionVariableShape >:: const_iterator ; using value_type = TargetRegionVariableShape ; using reference = const TargetRegionVariableShape & ; using pointer = const TargetRegionVariableShape * ; using iterator_category = std :: forward_iterator_tag ; using difference_type = std :: ptrdiff_t ; using ShapeKind = TargetRegionVariableShape :: ShapeKind ; private : base_iter It ; base_iter End ; TargetRegionVariableShape :: ShapeKind Kind ; public : shape_const_kind_iterator () = delete ; explicit shape_const_kind_iterator ( ShapeKind Kind , base_iter I ) : It ( I ), End ( I ), Kind ( Kind ) {} explicit shape_const_kind_iterator ( ShapeKind Kind , base_iter I , base_iter End ) : It ( I ), End ( End ), Kind ( Kind ) { while ( It -> getKind () != Kind && It != End ) { It ++ ; } }; shape_const_kind_iterator & operator ++ () { if ( It != End ) { It ++ ; } while ( It != End && It -> getKind () != Kind ) { It ++ ; } return * this ; } shape_const_kind_iterator operator ++ ( int ) { shape_const_kind_iterator tmp ( * this ); ++ ( * this ); return tmp ; } reference operator * () const { return * It ; } pointer operator -> () { return It . operator -> (); } friend bool operator == ( shape_const_kind_iterator X , shape_const_kind_iterator Y ) { return X . Kind == Y . Kind && X . It == Y . It ; } friend bool operator != ( shape_const_kind_iterator X , shape_const_kind_iterator Y ) { return X . Kind != Y . Kind || X . It != Y . It ; } }; using shape_const_kind_range = llvm :: iterator_range < shape_const_kind_iterator > ; private : const clang :: CapturedStmt :: Capture * Capture ; clang :: VarDecl * Decl ; std :: string VarName ; std :: string BaseTypeName ; std :: vector < TargetRegionVariableShape > Shapes ; unsigned int NumVariableArrayDims ; void determineShapes ( clang :: QualType T ); const std :: map < clang :: VarDecl * , clang :: Expr *> & OmpMappingLowerBound ; public : llvm :: StringRef name () const { return llvm :: StringRef ( VarName ); }; llvm :: StringRef baseTypeName () const { return llvm :: StringRef ( BaseTypeName ); }; clang :: VarDecl * getDecl () const { return Decl ; }; bool containsArray () const ; bool containsPointer () const ; bool passedByPointer () const ; llvm :: Optional < clang :: Expr *> arrayLowerBound () const ; bool operator == ( const TargetRegionVariable & Other ) const { return Decl == Other . Decl ; } shape_const_range shapes () const { return shape_const_range ( Shapes . cbegin (), Shapes . cend ()); } shape_const_kind_range variableArrayShapes () const { return shape_const_kind_range ( shape_const_kind_iterator ( TargetRegionVariableShape :: ShapeKind :: VariableArray , Shapes . cbegin (), Shapes . cend ()), shape_const_kind_iterator ( TargetRegionVariableShape :: ShapeKind :: VariableArray , Shapes . end ())); } TargetRegionVariable ( const clang :: CapturedStmt :: Capture * Capture , const std :: map < clang :: VarDecl * , clang :: Expr *> & MappingLowerBounds ); };","title":"src/TargetRegionVariable.h"},{"location":"internal/doxygen/Files/TargetRegionVariable_8h/#srctargetregionvariableh","text":"","title":"src/TargetRegionVariable.h"},{"location":"internal/doxygen/Files/TargetRegionVariable_8h/#namespaces","text":"Name clang","title":"Namespaces"},{"location":"internal/doxygen/Files/TargetRegionVariable_8h/#classes","text":"Name class TargetRegionVariableShape Describes the shape, i.e. class TargetRegionVariable Represents a variable captured by a target region. class TargetRegionVariable::shape_const_kind_iterator Iterator which acts as a filter over std::vector ::const_iterator (the base_iter) which only passes on TargetRegionVariableShape of the kind specified in Kind .","title":"Classes"},{"location":"internal/doxygen/Files/TargetRegionVariable_8h/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 //===-- sotoc/src/TargetRegionVariable.h ----------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// #pragma once #include <map> #include <vector> #include \"llvm/ADT/StringExtras.h\" namespace clang { class Expr ; class VarDecl ; class CapturedStmt ; } // namespace clang class TargetRegionVariableShape { public : enum ShapeKind { Pointer , Paren , ConstantArray , VariableArray }; private : unsigned int VariableDimensionIndex ; std :: string ConstantDimensionExpr ; ShapeKind Kind ; public : inline ShapeKind getKind () const { return Kind ; } inline bool isVariableArray () const { return Kind == ShapeKind :: VariableArray ; } inline bool isConstantArray () const { return Kind == ShapeKind :: ConstantArray ; } inline bool isArray () const { return Kind == ShapeKind :: VariableArray || Kind == ShapeKind :: ConstantArray ; } inline bool isPointer () const { return Kind == ShapeKind :: Pointer ; } inline unsigned int getVariableDimensionIndex () const { return VariableDimensionIndex ; } inline llvm :: StringRef getConstantDimensionExpr () const { return llvm :: StringRef ( ConstantDimensionExpr ); } TargetRegionVariableShape () : Kind ( ShapeKind :: Pointer ){}; TargetRegionVariableShape ( const clang :: ParenType * Paren ) : Kind ( ShapeKind :: Paren ){}; TargetRegionVariableShape ( const clang :: VariableArrayType * Array , unsigned int DimIndex ) : VariableDimensionIndex ( DimIndex ), Kind ( ShapeKind :: VariableArray ){}; TargetRegionVariableShape ( const clang :: ConstantArrayType * Array ) : Kind ( ShapeKind :: ConstantArray ) { ConstantDimensionExpr = toString ( Array -> getSize (), 10 , false ); } }; class TargetRegionVariable { public : using shape_const_iterator = std :: vector < TargetRegionVariableShape >:: const_iterator ; using shape_const_range = llvm :: iterator_range < shape_const_iterator > ; // https://clang.llvm.org/doxygen/Redeclarable_8h_source.html#l00239 class shape_const_kind_iterator { public : using base_iter = std :: vector < TargetRegionVariableShape >:: const_iterator ; using value_type = TargetRegionVariableShape ; using reference = const TargetRegionVariableShape & ; using pointer = const TargetRegionVariableShape * ; using iterator_category = std :: forward_iterator_tag ; using difference_type = std :: ptrdiff_t ; using ShapeKind = TargetRegionVariableShape :: ShapeKind ; private : base_iter It ; base_iter End ; TargetRegionVariableShape :: ShapeKind Kind ; public : shape_const_kind_iterator () = delete ; explicit shape_const_kind_iterator ( ShapeKind Kind , base_iter I ) : It ( I ), End ( I ), Kind ( Kind ) {} explicit shape_const_kind_iterator ( ShapeKind Kind , base_iter I , base_iter End ) : It ( I ), End ( End ), Kind ( Kind ) { while ( It -> getKind () != Kind && It != End ) { It ++ ; } }; shape_const_kind_iterator & operator ++ () { if ( It != End ) { It ++ ; } while ( It != End && It -> getKind () != Kind ) { It ++ ; } return * this ; } shape_const_kind_iterator operator ++ ( int ) { shape_const_kind_iterator tmp ( * this ); ++ ( * this ); return tmp ; } reference operator * () const { return * It ; } pointer operator -> () { return It . operator -> (); } friend bool operator == ( shape_const_kind_iterator X , shape_const_kind_iterator Y ) { return X . Kind == Y . Kind && X . It == Y . It ; } friend bool operator != ( shape_const_kind_iterator X , shape_const_kind_iterator Y ) { return X . Kind != Y . Kind || X . It != Y . It ; } }; using shape_const_kind_range = llvm :: iterator_range < shape_const_kind_iterator > ; private : const clang :: CapturedStmt :: Capture * Capture ; clang :: VarDecl * Decl ; std :: string VarName ; std :: string BaseTypeName ; std :: vector < TargetRegionVariableShape > Shapes ; unsigned int NumVariableArrayDims ; void determineShapes ( clang :: QualType T ); const std :: map < clang :: VarDecl * , clang :: Expr *> & OmpMappingLowerBound ; public : llvm :: StringRef name () const { return llvm :: StringRef ( VarName ); }; llvm :: StringRef baseTypeName () const { return llvm :: StringRef ( BaseTypeName ); }; clang :: VarDecl * getDecl () const { return Decl ; }; bool containsArray () const ; bool containsPointer () const ; bool passedByPointer () const ; llvm :: Optional < clang :: Expr *> arrayLowerBound () const ; bool operator == ( const TargetRegionVariable & Other ) const { return Decl == Other . Decl ; } shape_const_range shapes () const { return shape_const_range ( Shapes . cbegin (), Shapes . cend ()); } shape_const_kind_range variableArrayShapes () const { return shape_const_kind_range ( shape_const_kind_iterator ( TargetRegionVariableShape :: ShapeKind :: VariableArray , Shapes . cbegin (), Shapes . cend ()), shape_const_kind_iterator ( TargetRegionVariableShape :: ShapeKind :: VariableArray , Shapes . end ())); } TargetRegionVariable ( const clang :: CapturedStmt :: Capture * Capture , const std :: map < clang :: VarDecl * , clang :: Expr *> & MappingLowerBounds ); };","title":"Source code"},{"location":"internal/doxygen/Files/Visitors_8cpp/","text":"src/Visitors.cpp This file implements the classes DiscoverTypesInDeclVisitor and FindTargetCodeVisitor . Classes Name class CollectOMPClauseParamsVarsVisitor OMP clause visitor. class CollectOMPClauseParamsVisitor OMP clause parameter visitor. Functions Name bool stmtNeedsSemicolon (const clang::Stmt * S) Determine whether a statement needs a semicolon. Functions Documentation function stmtNeedsSemicolon 1 2 3 static bool stmtNeedsSemicolon ( const clang :: Stmt * S ) Determine whether a statement needs a semicolon. Parameters : S Statement to check Return : true If a semicolon is needed false If no semicolon is needed Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 //===-- sotoc/src/Visitor.cpp ---------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include <sstream> #include <string> #include \"clang/AST/ASTContext.h\" #include \"clang/AST/Attr.h\" #include \"clang/AST/Decl.h\" #include \"clang/AST/ExprOpenMP.h\" #include \"clang/AST/Stmt.h\" #include \"clang/AST/StmtOpenMP.h\" #include \"clang/Basic/OpenMPKinds.h\" #include \"clang/Basic/SourceLocation.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Rewrite/Core/Rewriter.h\" #include \"Debug.h\" #include \"DeclResolver.h\" #include \"TargetCode.h\" #include \"TargetCodeFragment.h\" #include \"Visitors.h\" static bool stmtNeedsSemicolon ( const clang :: Stmt * S ) { while ( 1 ) { if ( auto * CS = llvm :: dyn_cast < clang :: CapturedStmt > ( S )) { S = CS -> getCapturedStmt (); } else if ( auto * OS = llvm :: dyn_cast < clang :: OMPExecutableDirective > ( S )) { S = OS -> getInnermostCapturedStmt (); } else { break ; } } if ( llvm :: isa < clang :: CompoundStmt > ( S ) || llvm :: isa < clang :: ForStmt > ( S ) || llvm :: isa < clang :: IfStmt > ( S )) { return false ; } return true ; } bool FindTargetCodeVisitor::TraverseDecl ( clang :: Decl * D ) { if ( ! D ) return false ; if ( auto * FD = llvm :: dyn_cast < clang :: FunctionDecl > ( D )) { LastVisitedFuncDecl . push ( FD ); } bool ret = clang :: RecursiveASTVisitor < FindTargetCodeVisitor >:: TraverseDecl ( D ); if ( auto * FD = llvm :: dyn_cast < clang :: FunctionDecl > ( D )) { LastVisitedFuncDecl . pop (); } return ret ; } bool FindTargetCodeVisitor::VisitStmt ( clang :: Stmt * S ) { if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetDirective > ( S )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetTeamsDirective > ( S )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetParallelDirective > ( S )) { processTargetRegion ( TD ); } else if ( auto * LD = llvm :: dyn_cast < clang :: OMPLoopDirective > ( S )) { if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetParallelForDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetParallelForSimdDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetSimdDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetTeamsDistributeDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetTeamsDistributeParallelForDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetTeamsDistributeParallelForSimdDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetTeamsDistributeSimdDirective > ( LD )) { processTargetRegion ( TD ); } } return true ; } class CollectOMPClauseParamsVarsVisitor : public clang :: RecursiveASTVisitor < CollectOMPClauseParamsVarsVisitor > { std :: shared_ptr < TargetCodeRegion > TCR ; public : CollectOMPClauseParamsVarsVisitor ( std :: shared_ptr < TargetCodeRegion > & TCR ) : TCR ( TCR ) {}; bool VisitStmt ( clang :: Stmt * S ) { if ( auto * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( S )) { if ( auto * VD = llvm :: dyn_cast < clang :: VarDecl > ( DRE -> getDecl ())) { TCR -> addOMPClauseParam ( VD -> getCanonicalDecl ()); } } return true ; }; }; class CollectOMPClauseParamsVisitor : public clang :: RecursiveASTVisitor < CollectOMPClauseParamsVisitor > { CollectOMPClauseParamsVarsVisitor VarsVisitor ; bool InExplicitCast ; public : CollectOMPClauseParamsVisitor ( std :: shared_ptr < TargetCodeRegion > & TCR ) : VarsVisitor ( TCR ), InExplicitCast ( false ) {}; bool VisitStmt ( clang :: Stmt * S ) { // This relies on the captured statement being the last child if ( llvm :: isa < clang :: CapturedStmt > ( S )) { return false ; } if ( llvm :: isa < clang :: ImplicitCastExpr > ( S )) { InExplicitCast = true ; return true ; } auto * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( S ); if ( DRE && InExplicitCast ) { if ( auto * VD = llvm :: dyn_cast < clang :: VarDecl > ( DRE -> getDecl ())) { VarsVisitor . TraverseStmt ( VD -> getInit ()); } } InExplicitCast = false ; return true ; }; }; bool FindTargetCodeVisitor::processTargetRegion ( clang :: OMPExecutableDirective * TargetDirective ) { // TODO: Not sure why to iterate the children, because I think there // is only one child. For me this looks wrong. for ( auto i = TargetDirective -> child_begin (), e = TargetDirective -> child_end (); i != e ; ++ i ) { if ( auto * CS = llvm :: dyn_cast < clang :: CapturedStmt > ( * i )) { while ( auto * NCS = llvm :: dyn_cast < clang :: CapturedStmt > ( CS -> getCapturedStmt ())) { CS = NCS ; } auto TCR = std :: make_shared < TargetCodeRegion > ( CS , TargetDirective , LastVisitedFuncDecl . top (), Context ); // if the target region cannot be added we dont want to parse its args if ( TargetCodeInfo . addCodeFragment ( TCR )) { FindArraySectionVisitor ( TCR -> CapturedLowerBounds ). TraverseStmt ( TargetDirective ); for ( auto C : TargetDirective -> clauses ()) { TCR -> addOMPClause ( C ); } // For more complex data types (like structs) we need to traverse the // tree DiscoverTypeVisitor . TraverseStmt ( CS ); DiscoverFunctionVisitor . TraverseStmt ( CS ); addTargetRegionArgs ( CS , TargetDirective , TCR ); TCR -> NeedsSemicolon = stmtNeedsSemicolon ( CS ); TCR -> TargetCodeKind = TargetDirective -> getDirectiveKind (); } } } return true ; } void FindTargetCodeVisitor::addTargetRegionArgs ( clang :: CapturedStmt * S , clang :: OMPExecutableDirective * TargetDirective , std :: shared_ptr < TargetCodeRegion > TCR ) { DEBUGP ( \"Add target region args\" ); for ( const auto & i : S -> captures ()) { if ( ! ( i . capturesVariableArrayType ())) { DEBUGP ( \"captured Var: \" + i . getCapturedVar () -> getNameAsString ()); TCR -> addCapture ( & i ); } else { // Not sure what exactly is caputred here. It looks like we have an // additional capture in cases of VATs. DEBUGP ( \"Current capture is a variable-length array type (skipped)\" ); } } // Find all not locally declared variables in the region FindPrivateVariablesVisitor PrivateVarsVisitor ( S -> getBeginLoc (), Context . getSourceManager ()); PrivateVarsVisitor . TraverseStmt ( S ); // Remove any not locally declared variables which are already captured auto VarSet = PrivateVarsVisitor . getVarSet (); for ( auto & CapturedVar : TCR -> capturedVars ()) { VarSet . erase ( CapturedVar . getDecl ()); } // Add variables used in OMP clauses which are not captured as first-private // variables CollectOMPClauseParamsVisitor ( TCR ). TraverseStmt ( TargetDirective ); // Add non-local, non-capured variable as private variables TCR -> setPrivateVars ( VarSet ); } bool FindTargetCodeVisitor::VisitDecl ( clang :: Decl * D ) { auto * FD = llvm :: dyn_cast < clang :: FunctionDecl > ( D ); if ( FD ) { auto search = FuncDeclWithoutBody . find ( FD -> getNameAsString ()); if ( search != FuncDeclWithoutBody . end ()) { Functions . addDecl ( D ); FuncDeclWithoutBody . erase ( search ); } } // search Decl attributes for 'omp declare target' attr for ( auto & attr : D -> attrs ()) { if ( attr -> getKind () == clang :: attr :: OMPDeclareTargetDecl ) { Functions . addDecl ( D ); if ( FD ) { if ( FD -> hasBody () && ! FD -> doesThisDeclarationHaveABody ()) { FuncDeclWithoutBody . insert ( FD -> getNameAsString ()); } } return true ; } } return true ; } bool FindLoopStmtVisitor::VisitStmt ( clang :: Stmt * S ) { if ( auto LS = llvm :: dyn_cast < clang :: ForStmt > ( S )) { FindDeclRefVisitor . TraverseStmt ( LS -> getInit ()); } return true ; } bool FindDeclRefExprVisitor::VisitStmt ( clang :: Stmt * S ) { if ( auto DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( S )) { if ( auto DD = llvm :: dyn_cast < clang :: DeclaratorDecl > ( DRE -> getDecl ())) { if ( auto VD = llvm :: dyn_cast < clang :: VarDecl > ( DD )) { if ( VD -> getNameAsString () != \".reduction.lhs\" ) { VarSet . insert ( VD ); } } } } return true ; } bool DiscoverTypesInDeclVisitor::VisitDecl ( clang :: Decl * D ) { if ( auto * VD = llvm :: dyn_cast < clang :: ValueDecl > ( D )) { if ( const clang :: Type * TP = VD -> getType (). getTypePtrOrNull ()) { processType ( TP ); } } return true ; } bool DiscoverTypesInDeclVisitor::VisitExpr ( clang :: Expr * E ) { if ( auto * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( E )) { if ( auto * ECD = llvm :: dyn_cast < clang :: EnumConstantDecl > ( DRE -> getDecl ())) { OnEachTypeRef ( llvm :: cast < clang :: EnumDecl > ( ECD -> getDeclContext ())); return true ; } } if ( const clang :: Type * TP = E -> getType (). getTypePtrOrNull ()) { if ( TP -> isPointerType ()) { TP = TP -> getPointeeOrArrayElementType (); } processType ( TP ); } return true ; } bool DiscoverTypesInDeclVisitor::VisitType ( clang :: Type * T ) { processType ( T ); return true ; } void DiscoverTypesInDeclVisitor::processType ( const clang :: Type * TP ) { if ( const clang :: TypedefType * TDT = TP -> getAs < clang :: TypedefType > ()) { OnEachTypeRef ( TDT -> getDecl ()); } else if ( auto * TD = TP -> getAsTagDecl ()) { OnEachTypeRef ( TD ); } } DiscoverTypesInDeclVisitor :: DiscoverTypesInDeclVisitor ( TypeDeclResolver & Types ) { OnEachTypeRef = [ & Types ]( clang :: Decl * D ) { Types . addDecl ( D ); }; } DiscoverFunctionsInDeclVisitor :: DiscoverFunctionsInDeclVisitor ( FunctionDeclResolver & Functions ) { OnEachFuncRef = [ & Functions ]( clang :: FunctionDecl * FD ) { Functions . addDecl ( FD ); }; } bool DiscoverFunctionsInDeclVisitor :: VisitExpr ( clang :: Expr * E ) { clang :: DeclRefExpr * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( E ); if ( DRE != nullptr ) { if ( auto * D = DRE -> getDecl ()) { if ( auto * FD = llvm :: dyn_cast < clang :: FunctionDecl > ( D )) { OnEachFuncRef ( FD ); auto * FDDefinition = FD -> getDefinition (); if ( FDDefinition != FD && FDDefinition != NULL ) { OnEachFuncRef ( FDDefinition ); } } } } return true ; } bool FindArraySectionVisitor :: VisitExpr ( clang :: Expr * E ) { if ( auto * ASE = llvm :: dyn_cast < clang :: OMPArraySectionExpr > ( E )) { clang :: Expr * Base = ASE -> getBase (); if ( llvm :: isa < clang :: OMPArraySectionExpr > ( Base )) { return true ; } if ( auto * CastBase = llvm :: dyn_cast < clang :: CastExpr > ( Base )) { Base = CastBase -> getSubExpr (); if ( auto * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( Base )) { auto * VarDecl = llvm :: dyn_cast < clang :: VarDecl > ( DRE -> getDecl ()); if ( ! VarDecl ) { llvm :: errs () << \"VALDECL != VARDECL \\n \" ; return true ; } clang :: Expr * LowerBound = ASE -> getLowerBound (); if ( ! LowerBound ) { return true ; } if ( auto * IntegerLiteral = llvm :: dyn_cast < clang :: IntegerLiteral > ( LowerBound )) { if ( IntegerLiteral -> getValue () == 0 ) { return true ; } } LowerBoundsMap . emplace ( VarDecl , LowerBound ); } } } return true ; } bool FindPrivateVariablesVisitor :: VisitExpr ( clang :: Expr * E ) { if ( auto * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( E )) { if ( auto * VD = llvm :: dyn_cast < clang :: VarDecl > ( DRE -> getDecl ())) { // We do not collect variables in 'collect target' declarations. for ( auto & attr : VD -> attrs ()) { if ( attr -> getKind () == clang :: attr :: OMPDeclareTargetDecl ) { return true ; } } // If the variable is declared outside of the target region it may be a // private variable if ( SM . isBeforeInTranslationUnit ( VD -> getLocation (), RegionTopSourceLocation )) { // Add the Variable to our set VarSet . insert ( VD ); } } } return true ; }","title":"src/Visitors.cpp"},{"location":"internal/doxygen/Files/Visitors_8cpp/#srcvisitorscpp","text":"This file implements the classes DiscoverTypesInDeclVisitor and FindTargetCodeVisitor .","title":"src/Visitors.cpp"},{"location":"internal/doxygen/Files/Visitors_8cpp/#classes","text":"Name class CollectOMPClauseParamsVarsVisitor OMP clause visitor. class CollectOMPClauseParamsVisitor OMP clause parameter visitor.","title":"Classes"},{"location":"internal/doxygen/Files/Visitors_8cpp/#functions","text":"Name bool stmtNeedsSemicolon (const clang::Stmt * S) Determine whether a statement needs a semicolon.","title":"Functions"},{"location":"internal/doxygen/Files/Visitors_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"internal/doxygen/Files/Visitors_8cpp/#function-stmtneedssemicolon","text":"1 2 3 static bool stmtNeedsSemicolon ( const clang :: Stmt * S ) Determine whether a statement needs a semicolon. Parameters : S Statement to check Return : true If a semicolon is needed false If no semicolon is needed","title":"function stmtNeedsSemicolon"},{"location":"internal/doxygen/Files/Visitors_8cpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 //===-- sotoc/src/Visitor.cpp ---------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include <sstream> #include <string> #include \"clang/AST/ASTContext.h\" #include \"clang/AST/Attr.h\" #include \"clang/AST/Decl.h\" #include \"clang/AST/ExprOpenMP.h\" #include \"clang/AST/Stmt.h\" #include \"clang/AST/StmtOpenMP.h\" #include \"clang/Basic/OpenMPKinds.h\" #include \"clang/Basic/SourceLocation.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Rewrite/Core/Rewriter.h\" #include \"Debug.h\" #include \"DeclResolver.h\" #include \"TargetCode.h\" #include \"TargetCodeFragment.h\" #include \"Visitors.h\" static bool stmtNeedsSemicolon ( const clang :: Stmt * S ) { while ( 1 ) { if ( auto * CS = llvm :: dyn_cast < clang :: CapturedStmt > ( S )) { S = CS -> getCapturedStmt (); } else if ( auto * OS = llvm :: dyn_cast < clang :: OMPExecutableDirective > ( S )) { S = OS -> getInnermostCapturedStmt (); } else { break ; } } if ( llvm :: isa < clang :: CompoundStmt > ( S ) || llvm :: isa < clang :: ForStmt > ( S ) || llvm :: isa < clang :: IfStmt > ( S )) { return false ; } return true ; } bool FindTargetCodeVisitor::TraverseDecl ( clang :: Decl * D ) { if ( ! D ) return false ; if ( auto * FD = llvm :: dyn_cast < clang :: FunctionDecl > ( D )) { LastVisitedFuncDecl . push ( FD ); } bool ret = clang :: RecursiveASTVisitor < FindTargetCodeVisitor >:: TraverseDecl ( D ); if ( auto * FD = llvm :: dyn_cast < clang :: FunctionDecl > ( D )) { LastVisitedFuncDecl . pop (); } return ret ; } bool FindTargetCodeVisitor::VisitStmt ( clang :: Stmt * S ) { if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetDirective > ( S )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetTeamsDirective > ( S )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetParallelDirective > ( S )) { processTargetRegion ( TD ); } else if ( auto * LD = llvm :: dyn_cast < clang :: OMPLoopDirective > ( S )) { if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetParallelForDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetParallelForSimdDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetSimdDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetTeamsDistributeDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetTeamsDistributeParallelForDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetTeamsDistributeParallelForSimdDirective > ( LD )) { processTargetRegion ( TD ); } else if ( auto * TD = llvm :: dyn_cast < clang :: OMPTargetTeamsDistributeSimdDirective > ( LD )) { processTargetRegion ( TD ); } } return true ; } class CollectOMPClauseParamsVarsVisitor : public clang :: RecursiveASTVisitor < CollectOMPClauseParamsVarsVisitor > { std :: shared_ptr < TargetCodeRegion > TCR ; public : CollectOMPClauseParamsVarsVisitor ( std :: shared_ptr < TargetCodeRegion > & TCR ) : TCR ( TCR ) {}; bool VisitStmt ( clang :: Stmt * S ) { if ( auto * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( S )) { if ( auto * VD = llvm :: dyn_cast < clang :: VarDecl > ( DRE -> getDecl ())) { TCR -> addOMPClauseParam ( VD -> getCanonicalDecl ()); } } return true ; }; }; class CollectOMPClauseParamsVisitor : public clang :: RecursiveASTVisitor < CollectOMPClauseParamsVisitor > { CollectOMPClauseParamsVarsVisitor VarsVisitor ; bool InExplicitCast ; public : CollectOMPClauseParamsVisitor ( std :: shared_ptr < TargetCodeRegion > & TCR ) : VarsVisitor ( TCR ), InExplicitCast ( false ) {}; bool VisitStmt ( clang :: Stmt * S ) { // This relies on the captured statement being the last child if ( llvm :: isa < clang :: CapturedStmt > ( S )) { return false ; } if ( llvm :: isa < clang :: ImplicitCastExpr > ( S )) { InExplicitCast = true ; return true ; } auto * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( S ); if ( DRE && InExplicitCast ) { if ( auto * VD = llvm :: dyn_cast < clang :: VarDecl > ( DRE -> getDecl ())) { VarsVisitor . TraverseStmt ( VD -> getInit ()); } } InExplicitCast = false ; return true ; }; }; bool FindTargetCodeVisitor::processTargetRegion ( clang :: OMPExecutableDirective * TargetDirective ) { // TODO: Not sure why to iterate the children, because I think there // is only one child. For me this looks wrong. for ( auto i = TargetDirective -> child_begin (), e = TargetDirective -> child_end (); i != e ; ++ i ) { if ( auto * CS = llvm :: dyn_cast < clang :: CapturedStmt > ( * i )) { while ( auto * NCS = llvm :: dyn_cast < clang :: CapturedStmt > ( CS -> getCapturedStmt ())) { CS = NCS ; } auto TCR = std :: make_shared < TargetCodeRegion > ( CS , TargetDirective , LastVisitedFuncDecl . top (), Context ); // if the target region cannot be added we dont want to parse its args if ( TargetCodeInfo . addCodeFragment ( TCR )) { FindArraySectionVisitor ( TCR -> CapturedLowerBounds ). TraverseStmt ( TargetDirective ); for ( auto C : TargetDirective -> clauses ()) { TCR -> addOMPClause ( C ); } // For more complex data types (like structs) we need to traverse the // tree DiscoverTypeVisitor . TraverseStmt ( CS ); DiscoverFunctionVisitor . TraverseStmt ( CS ); addTargetRegionArgs ( CS , TargetDirective , TCR ); TCR -> NeedsSemicolon = stmtNeedsSemicolon ( CS ); TCR -> TargetCodeKind = TargetDirective -> getDirectiveKind (); } } } return true ; } void FindTargetCodeVisitor::addTargetRegionArgs ( clang :: CapturedStmt * S , clang :: OMPExecutableDirective * TargetDirective , std :: shared_ptr < TargetCodeRegion > TCR ) { DEBUGP ( \"Add target region args\" ); for ( const auto & i : S -> captures ()) { if ( ! ( i . capturesVariableArrayType ())) { DEBUGP ( \"captured Var: \" + i . getCapturedVar () -> getNameAsString ()); TCR -> addCapture ( & i ); } else { // Not sure what exactly is caputred here. It looks like we have an // additional capture in cases of VATs. DEBUGP ( \"Current capture is a variable-length array type (skipped)\" ); } } // Find all not locally declared variables in the region FindPrivateVariablesVisitor PrivateVarsVisitor ( S -> getBeginLoc (), Context . getSourceManager ()); PrivateVarsVisitor . TraverseStmt ( S ); // Remove any not locally declared variables which are already captured auto VarSet = PrivateVarsVisitor . getVarSet (); for ( auto & CapturedVar : TCR -> capturedVars ()) { VarSet . erase ( CapturedVar . getDecl ()); } // Add variables used in OMP clauses which are not captured as first-private // variables CollectOMPClauseParamsVisitor ( TCR ). TraverseStmt ( TargetDirective ); // Add non-local, non-capured variable as private variables TCR -> setPrivateVars ( VarSet ); } bool FindTargetCodeVisitor::VisitDecl ( clang :: Decl * D ) { auto * FD = llvm :: dyn_cast < clang :: FunctionDecl > ( D ); if ( FD ) { auto search = FuncDeclWithoutBody . find ( FD -> getNameAsString ()); if ( search != FuncDeclWithoutBody . end ()) { Functions . addDecl ( D ); FuncDeclWithoutBody . erase ( search ); } } // search Decl attributes for 'omp declare target' attr for ( auto & attr : D -> attrs ()) { if ( attr -> getKind () == clang :: attr :: OMPDeclareTargetDecl ) { Functions . addDecl ( D ); if ( FD ) { if ( FD -> hasBody () && ! FD -> doesThisDeclarationHaveABody ()) { FuncDeclWithoutBody . insert ( FD -> getNameAsString ()); } } return true ; } } return true ; } bool FindLoopStmtVisitor::VisitStmt ( clang :: Stmt * S ) { if ( auto LS = llvm :: dyn_cast < clang :: ForStmt > ( S )) { FindDeclRefVisitor . TraverseStmt ( LS -> getInit ()); } return true ; } bool FindDeclRefExprVisitor::VisitStmt ( clang :: Stmt * S ) { if ( auto DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( S )) { if ( auto DD = llvm :: dyn_cast < clang :: DeclaratorDecl > ( DRE -> getDecl ())) { if ( auto VD = llvm :: dyn_cast < clang :: VarDecl > ( DD )) { if ( VD -> getNameAsString () != \".reduction.lhs\" ) { VarSet . insert ( VD ); } } } } return true ; } bool DiscoverTypesInDeclVisitor::VisitDecl ( clang :: Decl * D ) { if ( auto * VD = llvm :: dyn_cast < clang :: ValueDecl > ( D )) { if ( const clang :: Type * TP = VD -> getType (). getTypePtrOrNull ()) { processType ( TP ); } } return true ; } bool DiscoverTypesInDeclVisitor::VisitExpr ( clang :: Expr * E ) { if ( auto * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( E )) { if ( auto * ECD = llvm :: dyn_cast < clang :: EnumConstantDecl > ( DRE -> getDecl ())) { OnEachTypeRef ( llvm :: cast < clang :: EnumDecl > ( ECD -> getDeclContext ())); return true ; } } if ( const clang :: Type * TP = E -> getType (). getTypePtrOrNull ()) { if ( TP -> isPointerType ()) { TP = TP -> getPointeeOrArrayElementType (); } processType ( TP ); } return true ; } bool DiscoverTypesInDeclVisitor::VisitType ( clang :: Type * T ) { processType ( T ); return true ; } void DiscoverTypesInDeclVisitor::processType ( const clang :: Type * TP ) { if ( const clang :: TypedefType * TDT = TP -> getAs < clang :: TypedefType > ()) { OnEachTypeRef ( TDT -> getDecl ()); } else if ( auto * TD = TP -> getAsTagDecl ()) { OnEachTypeRef ( TD ); } } DiscoverTypesInDeclVisitor :: DiscoverTypesInDeclVisitor ( TypeDeclResolver & Types ) { OnEachTypeRef = [ & Types ]( clang :: Decl * D ) { Types . addDecl ( D ); }; } DiscoverFunctionsInDeclVisitor :: DiscoverFunctionsInDeclVisitor ( FunctionDeclResolver & Functions ) { OnEachFuncRef = [ & Functions ]( clang :: FunctionDecl * FD ) { Functions . addDecl ( FD ); }; } bool DiscoverFunctionsInDeclVisitor :: VisitExpr ( clang :: Expr * E ) { clang :: DeclRefExpr * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( E ); if ( DRE != nullptr ) { if ( auto * D = DRE -> getDecl ()) { if ( auto * FD = llvm :: dyn_cast < clang :: FunctionDecl > ( D )) { OnEachFuncRef ( FD ); auto * FDDefinition = FD -> getDefinition (); if ( FDDefinition != FD && FDDefinition != NULL ) { OnEachFuncRef ( FDDefinition ); } } } } return true ; } bool FindArraySectionVisitor :: VisitExpr ( clang :: Expr * E ) { if ( auto * ASE = llvm :: dyn_cast < clang :: OMPArraySectionExpr > ( E )) { clang :: Expr * Base = ASE -> getBase (); if ( llvm :: isa < clang :: OMPArraySectionExpr > ( Base )) { return true ; } if ( auto * CastBase = llvm :: dyn_cast < clang :: CastExpr > ( Base )) { Base = CastBase -> getSubExpr (); if ( auto * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( Base )) { auto * VarDecl = llvm :: dyn_cast < clang :: VarDecl > ( DRE -> getDecl ()); if ( ! VarDecl ) { llvm :: errs () << \"VALDECL != VARDECL \\n \" ; return true ; } clang :: Expr * LowerBound = ASE -> getLowerBound (); if ( ! LowerBound ) { return true ; } if ( auto * IntegerLiteral = llvm :: dyn_cast < clang :: IntegerLiteral > ( LowerBound )) { if ( IntegerLiteral -> getValue () == 0 ) { return true ; } } LowerBoundsMap . emplace ( VarDecl , LowerBound ); } } } return true ; } bool FindPrivateVariablesVisitor :: VisitExpr ( clang :: Expr * E ) { if ( auto * DRE = llvm :: dyn_cast < clang :: DeclRefExpr > ( E )) { if ( auto * VD = llvm :: dyn_cast < clang :: VarDecl > ( DRE -> getDecl ())) { // We do not collect variables in 'collect target' declarations. for ( auto & attr : VD -> attrs ()) { if ( attr -> getKind () == clang :: attr :: OMPDeclareTargetDecl ) { return true ; } } // If the variable is declared outside of the target region it may be a // private variable if ( SM . isBeforeInTranslationUnit ( VD -> getLocation (), RegionTopSourceLocation )) { // Add the Variable to our set VarSet . insert ( VD ); } } } return true ; }","title":"Source code"},{"location":"internal/doxygen/Files/Visitors_8h/","text":"src/Visitors.h Namespaces Name clang Classes Name class DiscoverTypesInDeclVisitor Traverses (parts of) the AST to find DeclRefExpr that refer to types that need to be present for that part of the AST to compile correctly. class DiscoverFunctionsInDeclVisitor Traverses (parts of) the AST to find DeclRefExpr that refer to functions that need to be present for that part of the AST to compile correctly. class FindDeclRefExprVisitor class FindLoopStmtVisitor class FindTargetCodeVisitor Traverses the AST to find target and process target regions and function and variables that are annotated by an 'omp declare target' target pragma. class FindArraySectionVisitor class FindPrivateVariablesVisitor Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 //===-- sotoc/src/Visitor.h -----------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// #pragma once #include <unordered_set> #include \"DeclResolver.h\" #include \"clang/AST/RecursiveASTVisitor.h\" #include \"llvm/ADT/Optional.h\" namespace clang { class Stmt ; class Decl ; class Type ; class CapturedStmt ; class OMPExecutableDirective ; class SourceLocation ; class FunctionDecl ; class Attr ; class Rewriter ; class ASTContext ; } // namespace clang class TargetCode ; class TargetCodeFragment ; class TargetCodeRegion ; class TypeDeclResolver ; class DiscoverTypesInDeclVisitor : public clang :: RecursiveASTVisitor < DiscoverTypesInDeclVisitor > { std :: function < void ( clang :: TypeDecl * ) > OnEachTypeRef ; void processType ( const clang :: Type * D ); public : DiscoverTypesInDeclVisitor ( TypeDeclResolver & Types ); DiscoverTypesInDeclVisitor ( std :: function < void ( clang :: TypeDecl * ) > F ) : OnEachTypeRef ( F ){}; bool VisitDecl ( clang :: Decl * D ); bool VisitExpr ( clang :: Expr * D ); bool VisitType ( clang :: Type * T ); }; class DiscoverFunctionsInDeclVisitor : public clang :: RecursiveASTVisitor < DiscoverFunctionsInDeclVisitor > { std :: function < void ( clang :: FunctionDecl * ) > OnEachFuncRef ; public : DiscoverFunctionsInDeclVisitor ( FunctionDeclResolver & Functions ); DiscoverFunctionsInDeclVisitor ( std :: function < void ( clang :: FunctionDecl * ) > F ) : OnEachFuncRef ( F ){}; bool VisitExpr ( clang :: Expr * E ); }; class FindDeclRefExprVisitor : public clang :: RecursiveASTVisitor < FindDeclRefExprVisitor > { std :: unordered_set < clang :: VarDecl *> VarSet ; public : FindDeclRefExprVisitor () {} bool VisitStmt ( clang :: Stmt * S ); // bool VisitDecl(clang::Decl *D); std :: unordered_set < clang :: VarDecl *> * getVarSet () { return & VarSet ; } }; class FindLoopStmtVisitor : public clang :: RecursiveASTVisitor < FindLoopStmtVisitor > { FindDeclRefExprVisitor FindDeclRefVisitor ; public : FindLoopStmtVisitor () {} bool VisitStmt ( clang :: Stmt * S ); std :: unordered_set < clang :: VarDecl *> * getVarSet () { return FindDeclRefVisitor . getVarSet (); } }; class FindTargetCodeVisitor : public clang :: RecursiveASTVisitor < FindTargetCodeVisitor > { clang :: ASTContext & Context ; TargetCode & TargetCodeInfo ; DiscoverTypesInDeclVisitor DiscoverTypeVisitor ; DiscoverFunctionsInDeclVisitor DiscoverFunctionVisitor ; FunctionDeclResolver & Functions ; FindDeclRefExprVisitor FindDeclRefVisitor ; std :: stack < clang :: FunctionDecl *> LastVisitedFuncDecl ; std :: unordered_set < std :: string > FuncDeclWithoutBody ; public : FindTargetCodeVisitor ( TargetCode & Code , TypeDeclResolver & Types , FunctionDeclResolver & Functions , clang :: ASTContext & Context ) : Context ( Context ), TargetCodeInfo ( Code ), DiscoverTypeVisitor ( Types ), DiscoverFunctionVisitor ( Functions ), Functions ( Functions ){}; bool TraverseDecl ( clang :: Decl * D ); bool VisitStmt ( clang :: Stmt * S ); bool VisitDecl ( clang :: Decl * D ); private : bool processTargetRegion ( clang :: OMPExecutableDirective * TargetDirective ); void addTargetRegionArgs ( clang :: CapturedStmt * S , clang :: OMPExecutableDirective * TargetDirective , std :: shared_ptr < TargetCodeRegion > TCR ); }; class FindArraySectionVisitor : public clang :: RecursiveASTVisitor < FindArraySectionVisitor > { std :: map < clang :: VarDecl * , clang :: Expr *> & LowerBoundsMap ; public : FindArraySectionVisitor ( std :: map < clang :: VarDecl * , clang :: Expr *> & LowerBoundsMap ) : LowerBoundsMap ( LowerBoundsMap ) {} bool VisitExpr ( clang :: Expr * E ); }; class FindPrivateVariablesVisitor : public clang :: RecursiveASTVisitor < FindPrivateVariablesVisitor > { clang :: SourceManager & SM ; clang :: SourceLocation RegionTopSourceLocation ; std :: set < clang :: VarDecl *> VarSet ; public : FindPrivateVariablesVisitor ( clang :: SourceLocation TopSourceLocation , clang :: SourceManager & SM ) : SM ( SM ), RegionTopSourceLocation ( TopSourceLocation ) {} bool VisitExpr ( clang :: Expr * E ); std :: set < clang :: VarDecl *> & getVarSet () { return VarSet ; } };","title":"src/Visitors.h"},{"location":"internal/doxygen/Files/Visitors_8h/#srcvisitorsh","text":"","title":"src/Visitors.h"},{"location":"internal/doxygen/Files/Visitors_8h/#namespaces","text":"Name clang","title":"Namespaces"},{"location":"internal/doxygen/Files/Visitors_8h/#classes","text":"Name class DiscoverTypesInDeclVisitor Traverses (parts of) the AST to find DeclRefExpr that refer to types that need to be present for that part of the AST to compile correctly. class DiscoverFunctionsInDeclVisitor Traverses (parts of) the AST to find DeclRefExpr that refer to functions that need to be present for that part of the AST to compile correctly. class FindDeclRefExprVisitor class FindLoopStmtVisitor class FindTargetCodeVisitor Traverses the AST to find target and process target regions and function and variables that are annotated by an 'omp declare target' target pragma. class FindArraySectionVisitor class FindPrivateVariablesVisitor","title":"Classes"},{"location":"internal/doxygen/Files/Visitors_8h/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 //===-- sotoc/src/Visitor.h -----------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// #pragma once #include <unordered_set> #include \"DeclResolver.h\" #include \"clang/AST/RecursiveASTVisitor.h\" #include \"llvm/ADT/Optional.h\" namespace clang { class Stmt ; class Decl ; class Type ; class CapturedStmt ; class OMPExecutableDirective ; class SourceLocation ; class FunctionDecl ; class Attr ; class Rewriter ; class ASTContext ; } // namespace clang class TargetCode ; class TargetCodeFragment ; class TargetCodeRegion ; class TypeDeclResolver ; class DiscoverTypesInDeclVisitor : public clang :: RecursiveASTVisitor < DiscoverTypesInDeclVisitor > { std :: function < void ( clang :: TypeDecl * ) > OnEachTypeRef ; void processType ( const clang :: Type * D ); public : DiscoverTypesInDeclVisitor ( TypeDeclResolver & Types ); DiscoverTypesInDeclVisitor ( std :: function < void ( clang :: TypeDecl * ) > F ) : OnEachTypeRef ( F ){}; bool VisitDecl ( clang :: Decl * D ); bool VisitExpr ( clang :: Expr * D ); bool VisitType ( clang :: Type * T ); }; class DiscoverFunctionsInDeclVisitor : public clang :: RecursiveASTVisitor < DiscoverFunctionsInDeclVisitor > { std :: function < void ( clang :: FunctionDecl * ) > OnEachFuncRef ; public : DiscoverFunctionsInDeclVisitor ( FunctionDeclResolver & Functions ); DiscoverFunctionsInDeclVisitor ( std :: function < void ( clang :: FunctionDecl * ) > F ) : OnEachFuncRef ( F ){}; bool VisitExpr ( clang :: Expr * E ); }; class FindDeclRefExprVisitor : public clang :: RecursiveASTVisitor < FindDeclRefExprVisitor > { std :: unordered_set < clang :: VarDecl *> VarSet ; public : FindDeclRefExprVisitor () {} bool VisitStmt ( clang :: Stmt * S ); // bool VisitDecl(clang::Decl *D); std :: unordered_set < clang :: VarDecl *> * getVarSet () { return & VarSet ; } }; class FindLoopStmtVisitor : public clang :: RecursiveASTVisitor < FindLoopStmtVisitor > { FindDeclRefExprVisitor FindDeclRefVisitor ; public : FindLoopStmtVisitor () {} bool VisitStmt ( clang :: Stmt * S ); std :: unordered_set < clang :: VarDecl *> * getVarSet () { return FindDeclRefVisitor . getVarSet (); } }; class FindTargetCodeVisitor : public clang :: RecursiveASTVisitor < FindTargetCodeVisitor > { clang :: ASTContext & Context ; TargetCode & TargetCodeInfo ; DiscoverTypesInDeclVisitor DiscoverTypeVisitor ; DiscoverFunctionsInDeclVisitor DiscoverFunctionVisitor ; FunctionDeclResolver & Functions ; FindDeclRefExprVisitor FindDeclRefVisitor ; std :: stack < clang :: FunctionDecl *> LastVisitedFuncDecl ; std :: unordered_set < std :: string > FuncDeclWithoutBody ; public : FindTargetCodeVisitor ( TargetCode & Code , TypeDeclResolver & Types , FunctionDeclResolver & Functions , clang :: ASTContext & Context ) : Context ( Context ), TargetCodeInfo ( Code ), DiscoverTypeVisitor ( Types ), DiscoverFunctionVisitor ( Functions ), Functions ( Functions ){}; bool TraverseDecl ( clang :: Decl * D ); bool VisitStmt ( clang :: Stmt * S ); bool VisitDecl ( clang :: Decl * D ); private : bool processTargetRegion ( clang :: OMPExecutableDirective * TargetDirective ); void addTargetRegionArgs ( clang :: CapturedStmt * S , clang :: OMPExecutableDirective * TargetDirective , std :: shared_ptr < TargetCodeRegion > TCR ); }; class FindArraySectionVisitor : public clang :: RecursiveASTVisitor < FindArraySectionVisitor > { std :: map < clang :: VarDecl * , clang :: Expr *> & LowerBoundsMap ; public : FindArraySectionVisitor ( std :: map < clang :: VarDecl * , clang :: Expr *> & LowerBoundsMap ) : LowerBoundsMap ( LowerBoundsMap ) {} bool VisitExpr ( clang :: Expr * E ); }; class FindPrivateVariablesVisitor : public clang :: RecursiveASTVisitor < FindPrivateVariablesVisitor > { clang :: SourceManager & SM ; clang :: SourceLocation RegionTopSourceLocation ; std :: set < clang :: VarDecl *> VarSet ; public : FindPrivateVariablesVisitor ( clang :: SourceLocation TopSourceLocation , clang :: SourceManager & SM ) : SM ( SM ), RegionTopSourceLocation ( TopSourceLocation ) {} bool VisitExpr ( clang :: Expr * E ); std :: set < clang :: VarDecl *> & getVarSet () { return VarSet ; } };","title":"Source code"},{"location":"internal/doxygen/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"src Files Name src/Debug.h This file defines a debug macro for sotoc. src/DeclResolver.cpp This file implements the class DeclResolver . src/DeclResolver.h This file implements the class DeclResolver which is used to record and order types and functions in the input code that are required by the target regions. src/main.cpp This file implements sotoc, a clang to to enable outlining of OpenMP target region, which can be used by different compiler. src/OmpPragma.cpp This file implements the class OmpPragma , which is used to generate repla- cement pragmas for teams and team combined constructs. src/OmpPragma.h src/TargetCode.cpp This file implements the class TargetCode , which can be used to add code fragments and to generate new code (i.e., for outlining OpenMP target region) from these fragments. src/TargetCode.h src/TargetCodeFragment.cpp This file implements the classes TargetCodeDecl and TargetCodeRegion . src/TargetCodeFragment.h src/TargetRegionVariable.cpp This file implements the class TargetRegionVariable . src/TargetRegionVariable.h src/Visitors.cpp This file implements the classes DiscoverTypesInDeclVisitor and FindTargetCodeVisitor . src/Visitors.h","title":"src"},{"location":"internal/doxygen/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#src","text":"","title":"src"},{"location":"internal/doxygen/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Name src/Debug.h This file defines a debug macro for sotoc. src/DeclResolver.cpp This file implements the class DeclResolver . src/DeclResolver.h This file implements the class DeclResolver which is used to record and order types and functions in the input code that are required by the target regions. src/main.cpp This file implements sotoc, a clang to to enable outlining of OpenMP target region, which can be used by different compiler. src/OmpPragma.cpp This file implements the class OmpPragma , which is used to generate repla- cement pragmas for teams and team combined constructs. src/OmpPragma.h src/TargetCode.cpp This file implements the class TargetCode , which can be used to add code fragments and to generate new code (i.e., for outlining OpenMP target region) from these fragments. src/TargetCode.h src/TargetCodeFragment.cpp This file implements the classes TargetCodeDecl and TargetCodeRegion . src/TargetCodeFragment.h src/TargetRegionVariable.cpp This file implements the class TargetRegionVariable . src/TargetRegionVariable.h src/Visitors.cpp This file implements the classes DiscoverTypesInDeclVisitor and FindTargetCodeVisitor . src/Visitors.h","title":"Files"},{"location":"internal/doxygen/Files/index_files/","text":"Files dir src file src/Debug.h This file defines a debug macro for sotoc. file src/DeclResolver.cpp This file implements the class DeclResolver . file src/DeclResolver.h This file implements the class DeclResolver which is used to record and order types and functions in the input code that are required by the target regions. file src/OmpPragma.cpp This file implements the class OmpPragma , which is used to generate repla- cement pragmas for teams and team combined constructs. file src/OmpPragma.h file src/TargetCode.cpp This file implements the class TargetCode , which can be used to add code fragments and to generate new code (i.e., for outlining OpenMP target region) from these fragments. file src/TargetCode.h file src/TargetCodeFragment.cpp This file implements the classes TargetCodeDecl and TargetCodeRegion . file src/TargetCodeFragment.h file src/TargetRegionVariable.cpp This file implements the class TargetRegionVariable . file src/TargetRegionVariable.h file src/Visitors.cpp This file implements the classes DiscoverTypesInDeclVisitor and FindTargetCodeVisitor . file src/Visitors.h file src/main.cpp This file implements sotoc, a clang to to enable outlining of OpenMP target region, which can be used by different compiler.","title":"Files"},{"location":"internal/doxygen/Files/index_files/#files","text":"dir src file src/Debug.h This file defines a debug macro for sotoc. file src/DeclResolver.cpp This file implements the class DeclResolver . file src/DeclResolver.h This file implements the class DeclResolver which is used to record and order types and functions in the input code that are required by the target regions. file src/OmpPragma.cpp This file implements the class OmpPragma , which is used to generate repla- cement pragmas for teams and team combined constructs. file src/OmpPragma.h file src/TargetCode.cpp This file implements the class TargetCode , which can be used to add code fragments and to generate new code (i.e., for outlining OpenMP target region) from these fragments. file src/TargetCode.h file src/TargetCodeFragment.cpp This file implements the classes TargetCodeDecl and TargetCodeRegion . file src/TargetCodeFragment.h file src/TargetRegionVariable.cpp This file implements the class TargetRegionVariable . file src/TargetRegionVariable.h file src/Visitors.cpp This file implements the classes DiscoverTypesInDeclVisitor and FindTargetCodeVisitor . file src/Visitors.h file src/main.cpp This file implements sotoc, a clang to to enable outlining of OpenMP target region, which can be used by different compiler.","title":"Files"},{"location":"internal/doxygen/Files/main_8cpp/","text":"src/main.cpp This file implements sotoc, a clang to to enable outlining of OpenMP target region, which can be used by different compiler. Namespaces Name clang::tooling llvm Classes Name class TargetRegionTransformer class SourceTransformAction Functions Name llvm::cl::OptionCategory SotocCategory (\"sotoc options\" ) llvm::cl::extrahelp MoreHelp (\"\\nExtracts code in OpenMP target regions from source file and \"\"generates target function code\" ) int main (int argc, const char ** argv) Attributes Name int SotocDebugLevel Functions Documentation function SotocCategory 1 2 3 static llvm :: cl :: OptionCategory SotocCategory ( \"sotoc options\" ) function MoreHelp 1 2 3 static llvm :: cl :: extrahelp MoreHelp ( \" \\n Extracts code in OpenMP target regions from source file and \"\"generates target function code\" ) function main 1 2 3 4 int main ( int argc , const char ** argv ) Attributes Documentation variable SotocDebugLevel 1 int SotocDebugLevel = 0 ; Source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 //===-- sotoc/src/main.cpp ------------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include <cstdlib> #include <memory> #include <sstream> #include <string> #include \"clang/Frontend/FrontendActions.h\" #include \"clang/Tooling/CommonOptionsParser.h\" #include \"clang/Tooling/Tooling.h\" // Declares llvm::cl::extrahelp. #include \"clang/AST/ASTConsumer.h\" #include \"clang/AST/ASTContext.h\" #include \"clang/AST/RecursiveASTVisitor.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Frontend/CompilerInstance.h\" #include \"clang/Rewrite/Core/Rewriter.h\" #include \"llvm/Support/CommandLine.h\" #include \"llvm/Support/Process.h\" #include \"llvm/Support/raw_ostream.h\" #include \"Debug.h\" #include \"DeclResolver.h\" #include \"TargetCode.h\" #include \"TargetCodeFragment.h\" #include \"Visitors.h\" using namespace clang :: tooling ; using namespace llvm ; class TargetRegionTransformer : public clang :: ASTConsumer { TargetCode & Code ; clang :: Rewriter & TargetCodeRewriter ; public : TargetRegionTransformer ( TargetCode & Code , clang :: Rewriter & TargetCodeRewriter ) : Code ( Code ), TargetCodeRewriter ( TargetCodeRewriter ) {} void HandleTranslationUnit ( clang :: ASTContext & Context ) final { // create space to store information types and functions TypeDeclResolver Types ; // Functinos are... special because they can reference new types FunctionDeclResolver Functions ( Types ); // read target code information from AST into TargetCode FindTargetCodeVisitor FindCodeVisitor ( Code , Types , Functions , Context ); FindCodeVisitor . TraverseDecl ( Context . getTranslationUnitDecl ()); Functions . orderAndAddFragments ( Code ); Types . orderAndAddFragments ( Code ); } }; class SourceTransformAction : public clang :: ASTFrontendAction { clang :: Rewriter TargetCodeRewriter ; TargetCode * Code ; public : void EndSourceFileAction () override { // std::error_code error_code; // llvm::raw_fd_ostream outFile(\"output.txt\", error_code, // llvm::sys::fs::F_Append); DEBUGP ( \"Generating Code\" ); Code -> generateCode ( llvm :: outs ()); // outFile.close(); delete Code ; } std :: unique_ptr < clang :: ASTConsumer > CreateASTConsumer ( clang :: CompilerInstance & CI , clang :: StringRef ) final { TargetCodeRewriter . setSourceMgr ( CI . getSourceManager (), CI . getLangOpts ()); // TargetCode holds all necessary information about source locations of // target regions to extract that code Code = new TargetCode ( TargetCodeRewriter ); return std :: unique_ptr < clang :: ASTConsumer > ( new TargetRegionTransformer ( * Code , TargetCodeRewriter )); } }; int SotocDebugLevel = 0 ; static llvm :: cl :: OptionCategory SotocCategory ( \"sotoc options\" ); static llvm :: cl :: extrahelp MoreHelp ( \" \\n Extracts code in OpenMP target regions from source file and \" \"generates target function code\" ); int main ( int argc , const char ** argv ) { auto option = clang :: tooling :: CommonOptionsParser :: create ( argc , argv , SotocCategory ); if ( ! option ) { return -1 ; } clang :: tooling :: ClangTool tool ( option -> getCompilations (), option -> getSourcePathList ()); #ifdef SOTOC_DEBUG SotocDebugLevel = std :: atoi ( sys :: Process :: GetEnv ( \"SOTOC_DEBUG\" ). getValueOr ( \"0\" ). c_str ()); #endif DEBUGP ( \"Starting source transformation tool\" ); return tool . run ( clang :: tooling :: newFrontendActionFactory < SourceTransformAction > (). get ()); }","title":"src/main.cpp"},{"location":"internal/doxygen/Files/main_8cpp/#srcmaincpp","text":"This file implements sotoc, a clang to to enable outlining of OpenMP target region, which can be used by different compiler.","title":"src/main.cpp"},{"location":"internal/doxygen/Files/main_8cpp/#namespaces","text":"Name clang::tooling llvm","title":"Namespaces"},{"location":"internal/doxygen/Files/main_8cpp/#classes","text":"Name class TargetRegionTransformer class SourceTransformAction","title":"Classes"},{"location":"internal/doxygen/Files/main_8cpp/#functions","text":"Name llvm::cl::OptionCategory SotocCategory (\"sotoc options\" ) llvm::cl::extrahelp MoreHelp (\"\\nExtracts code in OpenMP target regions from source file and \"\"generates target function code\" ) int main (int argc, const char ** argv)","title":"Functions"},{"location":"internal/doxygen/Files/main_8cpp/#attributes","text":"Name int SotocDebugLevel","title":"Attributes"},{"location":"internal/doxygen/Files/main_8cpp/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"internal/doxygen/Files/main_8cpp/#function-sotoccategory","text":"1 2 3 static llvm :: cl :: OptionCategory SotocCategory ( \"sotoc options\" )","title":"function SotocCategory"},{"location":"internal/doxygen/Files/main_8cpp/#function-morehelp","text":"1 2 3 static llvm :: cl :: extrahelp MoreHelp ( \" \\n Extracts code in OpenMP target regions from source file and \"\"generates target function code\" )","title":"function MoreHelp"},{"location":"internal/doxygen/Files/main_8cpp/#function-main","text":"1 2 3 4 int main ( int argc , const char ** argv )","title":"function main"},{"location":"internal/doxygen/Files/main_8cpp/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"internal/doxygen/Files/main_8cpp/#variable-sotocdebuglevel","text":"1 int SotocDebugLevel = 0 ;","title":"variable SotocDebugLevel"},{"location":"internal/doxygen/Files/main_8cpp/#source-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 //===-- sotoc/src/main.cpp ------------------------------------------------===// // // The LLVM Compiler Infrastructure // // This file is distributed under the University of Illinois Open Source // License. See LICENSE.TXT for details. // //===----------------------------------------------------------------------===// //===----------------------------------------------------------------------===// #include <cstdlib> #include <memory> #include <sstream> #include <string> #include \"clang/Frontend/FrontendActions.h\" #include \"clang/Tooling/CommonOptionsParser.h\" #include \"clang/Tooling/Tooling.h\" // Declares llvm::cl::extrahelp. #include \"clang/AST/ASTConsumer.h\" #include \"clang/AST/ASTContext.h\" #include \"clang/AST/RecursiveASTVisitor.h\" #include \"clang/Basic/SourceManager.h\" #include \"clang/Frontend/CompilerInstance.h\" #include \"clang/Rewrite/Core/Rewriter.h\" #include \"llvm/Support/CommandLine.h\" #include \"llvm/Support/Process.h\" #include \"llvm/Support/raw_ostream.h\" #include \"Debug.h\" #include \"DeclResolver.h\" #include \"TargetCode.h\" #include \"TargetCodeFragment.h\" #include \"Visitors.h\" using namespace clang :: tooling ; using namespace llvm ; class TargetRegionTransformer : public clang :: ASTConsumer { TargetCode & Code ; clang :: Rewriter & TargetCodeRewriter ; public : TargetRegionTransformer ( TargetCode & Code , clang :: Rewriter & TargetCodeRewriter ) : Code ( Code ), TargetCodeRewriter ( TargetCodeRewriter ) {} void HandleTranslationUnit ( clang :: ASTContext & Context ) final { // create space to store information types and functions TypeDeclResolver Types ; // Functinos are... special because they can reference new types FunctionDeclResolver Functions ( Types ); // read target code information from AST into TargetCode FindTargetCodeVisitor FindCodeVisitor ( Code , Types , Functions , Context ); FindCodeVisitor . TraverseDecl ( Context . getTranslationUnitDecl ()); Functions . orderAndAddFragments ( Code ); Types . orderAndAddFragments ( Code ); } }; class SourceTransformAction : public clang :: ASTFrontendAction { clang :: Rewriter TargetCodeRewriter ; TargetCode * Code ; public : void EndSourceFileAction () override { // std::error_code error_code; // llvm::raw_fd_ostream outFile(\"output.txt\", error_code, // llvm::sys::fs::F_Append); DEBUGP ( \"Generating Code\" ); Code -> generateCode ( llvm :: outs ()); // outFile.close(); delete Code ; } std :: unique_ptr < clang :: ASTConsumer > CreateASTConsumer ( clang :: CompilerInstance & CI , clang :: StringRef ) final { TargetCodeRewriter . setSourceMgr ( CI . getSourceManager (), CI . getLangOpts ()); // TargetCode holds all necessary information about source locations of // target regions to extract that code Code = new TargetCode ( TargetCodeRewriter ); return std :: unique_ptr < clang :: ASTConsumer > ( new TargetRegionTransformer ( * Code , TargetCodeRewriter )); } }; int SotocDebugLevel = 0 ; static llvm :: cl :: OptionCategory SotocCategory ( \"sotoc options\" ); static llvm :: cl :: extrahelp MoreHelp ( \" \\n Extracts code in OpenMP target regions from source file and \" \"generates target function code\" ); int main ( int argc , const char ** argv ) { auto option = clang :: tooling :: CommonOptionsParser :: create ( argc , argv , SotocCategory ); if ( ! option ) { return -1 ; } clang :: tooling :: ClangTool tool ( option -> getCompilations (), option -> getSourcePathList ()); #ifdef SOTOC_DEBUG SotocDebugLevel = std :: atoi ( sys :: Process :: GetEnv ( \"SOTOC_DEBUG\" ). getValueOr ( \"0\" ). c_str ()); #endif DEBUGP ( \"Starting source transformation tool\" ); return tool . run ( clang :: tooling :: newFrontendActionFactory < SourceTransformAction > (). get ()); }","title":"Source code"},{"location":"internal/doxygen/Modules/index_groups/","text":"Modules","title":"Modules"},{"location":"internal/doxygen/Modules/index_groups/#modules","text":"","title":"Modules"},{"location":"internal/doxygen/Namespaces/index_namespaces/","text":"Namespaces namespace clang namespace clang::tooling namespace llvm","title":"Namespaces"},{"location":"internal/doxygen/Namespaces/index_namespaces/#namespaces","text":"namespace clang namespace clang::tooling namespace llvm","title":"Namespaces"},{"location":"internal/doxygen/Namespaces/namespaceclang/","text":"clang","title":"clang"},{"location":"internal/doxygen/Namespaces/namespaceclang/#clang","text":"","title":"clang"},{"location":"internal/doxygen/Namespaces/namespaceclang_1_1tooling/","text":"clang::tooling","title":"clang::tooling"},{"location":"internal/doxygen/Namespaces/namespaceclang_1_1tooling/#clangtooling","text":"","title":"clang::tooling"},{"location":"internal/doxygen/Namespaces/namespacellvm/","text":"llvm","title":"llvm"},{"location":"internal/doxygen/Namespaces/namespacellvm/#llvm","text":"","title":"llvm"},{"location":"internal/doxygen/Pages/index_pages/","text":"Pages page sotoc - Source Transformation for OpenMP Code","title":"Pages"},{"location":"internal/doxygen/Pages/index_pages/#pages","text":"page sotoc - Source Transformation for OpenMP Code","title":"Pages"}]}